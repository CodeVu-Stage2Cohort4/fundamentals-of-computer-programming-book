Detailed Table of Contents

Contents	2
Detailed Table of Contents	5
Preface	13
About the Book	13
C# and .NET Framework	17
How Ňî Read This Book?	22
Why Are Data Structures and Algorithms Emphasized?	25
Do You Really Want to Become a Programmer?	26
A Look at the Book’s Contents	29
History: How Did This Book Come to Be?	38
Authors and Contributors	40
The Book Is Free of Charge!	53
Reviews	53
License	64
Resources Coming with the Book	65
Chapter 1. Introduction to Programming	69
In This Chapter	69
What Does It Mean "To Program"?	69
Stages in Software Development	71
Our First C# Program	75
The C# Language and the .NET Platform	79
Visual Studio IDE	93
Alternatives to Visual Studio	104
Decompiling Code	104
C# in Linux, iOS and Android	107
Other .NET Languages	107
Exercises	108
Solutions and Guidelines	108
Chapter 2. Primitive Types and Variables	111
In This Chapter	111
What Is a Variable?	111
Data Types	111
Variables	123
Value and Reference Types	128
Literals	131
Exercises	135
Solutions and Guidelines	136
Chapter 3. Operators and Expressions	139
In This Chapter	139
Operators	139
Type Conversion and Casting	152
Expressions	158
Exercises	160
Solutions and Guidelines	161
Chapter 4. Console Input and Output	165
In This Chapter	165
What Is the Console?	165
Standard Input-Output	169
Printing to the Console	169
Console Input	183
Console Input and Output – Examples	190
Exercises	192
Solutions and Guidelines	193
Chapter 5. Conditional Statements	195
In This Chapter	195
Comparison Operators and Boolean Expressions	195
Conditional Statements "if" and "if-else"	200
Conditional Statement "switch-case"	206
Exercises	208
Solutions and Guidelines	209
Chapter 6. Loops	211
In This Chapter	211
What Is a "Loop"?	211
While Loops	211
Do-While Loops	216
For Loops	221
Foreach Loops	225
Nested Loops	226
Exercises	231
Solutions and Guidelines	233
Chapter 7. Arrays	235
In This Chapter	235
What Is an "Array"?	235
Declaration and Allocation of Memory for Arrays	235
Access to the Elements of an Array	238
Reading an Array from the Console	241
Printing an Array to the Console	243
Iteration through Elements of an Array	244
Multidimensional Arrays	246
Arrays of Arrays	253
Exercises	257
Solutions and Guidelines	259
Chapter 8. Numeral Systems	265
In This Chapter	265
History in a Nutshell	265
Numeral Systems	266
Representation of Numbers	276
Exercises	289
Solutions and Guidelines	290
Chapter 9. Methods	293
In This Chapter	293
Subroutines in Programming	293
What Is a "Method"?	293
Why to Use Methods?	294
How to Declare, Implement and Invoke a Method?	295
Declaring Our Own Method	295
Implementation (Creation) of Own Method	300
Invoking a Method	301
Parameters in Methods	303
Returning a Result from a Method	328
Best Practices when Using Methods	345
Exercises	347
Solutions and Guidelines	348
Chapter 10. Recursion	351
In This Chapter	351
What Is Recursion?	351
Example of Recursion	351
Direct and Indirect Recursion	352
Bottom of Recursion	352
Creating Recursive Methods	352
Recursive Calculation of Factorial	353
Recursion or Iteration?	355
Simulation of N Nested Loops	356
Which is Better: Recursion or Iteration?	362
Using Recursion – Conclusions	378
Exercises	378
Solutions and Guidelines	380
Chapter 11. Creating and Using Objects	385
In This Chapter	385
Classes and Objects	385
Classes in C#	387
Creating and Using Objects	390
Namespaces	405
Exercises	410
Solutions and Guidelines	412
Chapter 12. Exception Handling	415
In This Chapter	415
What Is an Exception?	415
Exceptions Hierarchy	424
Throwing and Catching Exceptions	426
The try-finally Construct	432
IDisposable and the "using" Statement	437
Advantages of Using Exceptions	439
Best Practices when Using Exceptions	445
Exercises	453
Solutions and Guidelines	454
Chapter 13. Strings and Text Processing	457
In This Chapter	457
Strings	457
Strings Operations	462
Constructing Strings: the StringBuilder Class	480
String Formatting	488
Exercises	491
Solutions and Guidelines	496
Chapter 14. Defining Classes	499
In This Chapter	499
Custom Classes	499
Usage of Class and Objects	502
Organizing Classes in Files and Namespaces	505
Modifiers and Access Levels (Visibility)	508
Declaring Classes	509
The Reserved Word "this"	511
Fields	512
Methods	518
Accessing Non-Static Data of the Class	519
Hiding Fields with Local Variables	522
Visibility of Fields and Methods	524
Constructors	531
Properties	549
Static Classes and Static Members	559
Structures	580
Enumerations	584
Inner Classes (Nested Classes)	590
Generics	594
Exercises	610
Solutions and Guidelines	613
Chapter 15. Text Files	615
In This Chapter	615
Streams	615
Reading from a Text File	620
Writing to a Text File	628
Input / Output Exception Handling	630
Text Files – More Examples	631
Exercises	636
Solutions and Guidelines	638
Chapter 16. Linear Data Structures	641
In This Chapter	641
Abstract Data Structures	641
List Data Structures	642
Exercises	676
Solutions and Guidelines	678
Chapter 17. Trees and Graphs	681
In This Chapter	681
Tree Data Structures	681
Trees	681
Graphs	714
Exercises	722
Solutions and Guidelines	723
Chapter 18. Dictionaries, Hash-Tables and Sets	727
In This Chapter	727
Dictionary Data Structure	727
Hash-Tables	735
The "Set" Data Structure	760
Exercises	765
Solutions and Guidelines	767
Chapter 19. Data Structures and Algorithm Complexity	769
In This Chapter	769
Why Are Data Structures So Important?	769
Algorithm Complexity	770
Comparison between Basic Data Structures	779
When to Use a Particular Data Structure?	779
Choosing a Data Structure – Examples	786
External Libraries with .NET Collections	801
Exercises	803
Solutions and Guidelines	804
Chapter 20. Object-Oriented Programming Principles	807
In This Chapter	807
Let’s Review: Classes and Objects	807
Object-Oriented Programming (OOP)	807
Fundamental Principles of OOP	808
Inheritance	809
Abstraction	824
Encapsulation	828
Polymorphism	830
Cohesion and Coupling	836
Object-Oriented Modeling (OOM)	842
UML Notation	844
Design Patterns	847
Exercises	851
Solutions and Guidelines	852
Chapter 21. High-Quality Programming Code	853
In This Chapter	853
Why Is Code Quality Important?	853
What Does Quality Programming Code Mean?	854
Why Should We Write Quality Code?	854
Identifier Naming	857
Code Formatting	866
High-Quality Classes	874
High-Quality Methods	878
Proper Use of Variables	883
Proper Use of Expressions	890
Use of Constants	891
Proper Use of Control Flow Statements	894
Defensive Programming	898
Code Documentation	900
Code Refactoring	904
Unit Testing	905
Additional Resources	912
Exercises	912
Solutions and Guidelines	913
Chapter 22. Lambda Expressions and LINQ	915
In This Chapter	915
Extension Methods	915
Anonymous Types	918
Lambda Expressions	920
LINQ Queries	924
Nested LINQ Queries	930
LINQ Performance	930
Exercises	933
Solutions and Guidelines	933
Chapter 23. Methodology of Problem Solving	935
In This Chapter	935
Basic Principles of Solving Computer Programming Problems	935
Use Pen and Paper	936
Generate Ideas and Give Them a Try!	937
Decompose the Task into Smaller Subtasks	938
Verify Your Ideas!	941
If a Problem Occurs, Invent a New Idea!	943
Choose Appropriate Data Structures!	946
Think about the Efficiency!	950
Implement Your Algorithm!	953
Write the Code Step by Step!	954
Test Your Solution!	967
General Conclusions	979
Exercises	980
Solutions and Guidelines	983
Chapter 24. Sample Programming Exam – Topic #1	985
In This Chapter	985
Problem 1: Extract Text from HTML Document	985
Problem 2: Escape from Labyrinth	1012
Problem 3: Store for Car Parts	1026
Exercises	1038
Solutions and Guidelines	1040
Chapter 25. Sample Programming Exam – Topic #2	1041
In This Chapter	1041
Problem 1: Counting the Uppercase / Lowercase Words in a Text	1041
Problem 2: A Matrix of Prime Numbers	1054
Problem 3: Evaluate an Arithmetic Expression	1060
Exercises	1069
Solutions and Guidelines	1069
Chapter 26. Sample Programming Exam – Topic #3	1071
In This Chapter	1071
Problem 1: Spiral Matrix	1071
Problem 2: Counting Words in a Text File	1078
Problem 3: School	1099
Exercises	1117
Solutions and Guidelines	1118
Conclusion	1119
Did You Solve All Problems?	1119
Have You Encountered Difficulties with the Exercises?	1119
How Do You Proceed After Reading the Book?	1120
Free Courses at Telerik Software Academy	1121
Good Luck to Everyone!	1121


Preface

If you want to take up programming seriously, you’ve come across the right book. For real! This is the book with which you can make your first steps in programming. It will give a flying start to your long journey into learning modern programming languages and software development technologies. This book teaches the fundamental principles and concepts of programming, which have not changed significantly in the past 15 years.
Do not hesitate to read this book even if C# is not the language you would like to pursue. Whatever language you move on to, the knowledge we will give you here will stick, because this book will teach you to think like programmers. We will show you and teach you how to write programs for solving practical algorithmic problems, form the skills in you to come up with (and implement) algorithms, and use various data structures.
As improbable as it might seem to you, the basic principles of writing computer programs have not changed all that much in the past 15 years. Programming languages change, technologies get modernized, integrated development environments get more and more advanced but the fundamental principles of programming remain the same. When beginners learn to think algorithmically, and then learn to divide a problem instinctively into a series of steps to solve it, as well as when they learn to select the appropriate data structures and write high-quality programming code that is when they become programmers. Once you acquire these skills, you can easily learn new languages and various technologies – like Web programming, HTML5 and JavaScript, mobile development, databases and SQL, XML, REST, ASP.NET, Java EE, Python, Ruby and hundreds more.
About the Book
This book is designed specifically to teach you to think like a programmer and the C# language is just a tool that can be replaced by any other modern programming languages, such as Java, C++, PHP or Python. This is a book on programming, not a book on C#!
Please Excuse Us for the Bugs in the Translation!
This book was originally written in Bulgarian language by a large team of volunteer software engineers and later translated into English. None of the authors, translators, editors and the other contributors is a native English speaker so you might find many mistakes and imprecise translation. Please, excuse us! Over 70 people have participated in this project (mostly Bulgarians): authors, editors, translators, correctors, bug submitters, etc. and still the quality could be improved. The entire team congratulates you on your choice to read this book and we believe the content in it is more important that the small mistakes and inaccuracies you might find. Enjoy!
Who Is This Book Aimed At?
This book is best suited for beginners. It is intended for anyone who so far has not engaged seriously in programming and would like to begin doing it. This book starts from scratch and introduces you step by step into the fundamentals of programming. It won’t teach you absolutely everything you might need for becoming a software engineer and working at a software company, but it will lay the groundwork on which you can build up technological knowledge and skills, and through them you will be able to turn programming into your profession.
If you’ve never written a computer program, don’t worry. There is always a first time. In this book we will teach you how to program from scratch. We do not expect any previous knowledge or abilities. All you need is some basic computer literacy and a desire to take up programming. The rest you will learn from the book.
If you can already write simple programs or if you have studied programming at school or in college, or you’ve coded with friends, do not assume you know everything! Read this book and you’ll become aware of how many things you’ve missed. This book is indeed for beginners, but it teaches concepts and skills that even experienced professional programmers lack. Software companies are riddled with a shocking amount of self-taught amateurs who, despite having programmed on a salary for years, have no grasp of the fundamentals of programming and have no idea what a hash table is, how polymorphism works and how to work with bitwise operations. Don’t be like them! Learn the basics of programming first and then the technologies. Otherwise you risk having your programming skills crippled, more or less, for years, if not for life.
If, on the other hand, you have programming experience, examine this book in details and see if you are familiar with all subjects we have covered, in order to decide whether it is for you or not. Take a close look especially at the chapters "Data Structures and Algorithms Complexity", "Object-Oriented Programming Principles", "Methodology of Problem Solving" and "High-Quality Programming Code". It is very likely that, even if you have several years of experience, you might not be able to work well with data structures; you might not be able to evaluate the complexity of an algorithm; you might not have mastered in depth the concepts of object-oriented programming (including UML and design patterns); and you might not be acquainted with the best practices for writing high-quality programming code. These are very important topics that are not covered in all books on programming, so don’t skip them!
Previous Knowledge Is Not Required!
In this book we do not expect any previous programming knowledge from the readers. It is not necessary for you to have studied information technology or computer science, in order to read and comprehend the book content. The book starts from scratch and gradually gets you involved in programming. All technical terms you will come across will have been explained beforehand and it is not necessary for you to know them from other sources. If you don’t know what a compiler, debugger, integrated develop¬ment environment, variable, array, loop, console, string, data structure, algorithm, algorithm complexity, class or object are, don’t be alarmed. From this book, you will learn all these terms and many more and gradually get accustomed to using them constantly in your everyday work. Just read the book consistently and do the exercises.
Certainly, if, after all, you do have prior knowledge in computer science and information technologies, they will by all means be of use to you. If, at university, you major in the field of computer science or if you study information technology at school, this will only help you, but it is not a must. If you major in tourism, law or other discipline that has little in common with computer technology, you could still become a good programmer, as long as you have the desire. The software industry is full of good developers without a computer science or related degree.
It is expected for you to have basic computer literacy, since we would not be explaining what a file, hard disk and network adapter is, nor how to move the mouse or how to write on a keyboard. We expect you to know how to work with a computer and how to use the Internet.
It is recommended that the readers have at least some basic knowledge of English. The entire documentation you will be using every day and almost all of the websites on programming you would be reading at all times are in English. In the profession of a programmer, English is absolutely essential. The sooner you learn it, the better. We hope that you already speak English; otherwise how do you read this text?
 	Make no illusion you can become a programmer without learning even a little English! This is simply a naive expectation. If you don’t speak English, complete a course of some sort and then start reading technical literature, make note of any unfamiliar words and learn them. You will see for yourselves that Technical English is easy to learn and it doesn’t take much time.
What Is the Scope of This Book?
This book covers the fundamentals of programming. It will teach you how to define and use variables, how to work with primitive data structures (such as numbers), how to organize logical statements, conditional statements and loops, how to print on the console, how to use arrays, how to work with numeral systems, how to define and use methods, and how to create and use objects. Along with the basic programming knowledge, this book will help you understand more complicated concepts such as string processing, exception handling, using complex data structures (like trees and hash tables), working with text files, defining custom classes and working with LINQ queries. The concepts of object-oriented programming (OOP) – an established approach in modern software development – will be covered in depth. Finally, you’ll be faced with the practices for writing high-quality programs and solving real-world programming problems. This book presents a complete methodology for solving programming problems, as well as algorithmic problems in general, and shows how to implement it with a few sample subjects and programming exams. This is something you will not find in any other book on programming!
What Will This Book Not Teach You?
This book will not award you the profession "software engineer"! This book won’t teach you how to use the entire .NET platform, how to work with databases, how to create dynamic web sites and develop mobile applications, how to create window-based graphical user interface (GUI) and rich Internet applications (RIA). You won’t learn how to develop complex software applications and systems like Skype, Firefox, MS Word or social networks like Facebook and retail sites like Amazon.com. And no other single book will. These kinds of projects require many, many years of work and experience and the knowledge in this book is just a wonderful beginning for the future programmer geek.
From this book, you won’t learn software engineering, team work and you won’t be able to prepare for working on real projects in a software company. In order to learn all of this, you will need a few more books and extra courses, but do not regret the time you will spend on this book. You are making the right choice by starting with the fundamentals of programming rather than directly with Web development, mobile applications and databases. This gives you the opportunity to become a master programmer who has in-depth knowledge of programming and technology. After you acquire the fundamentals of programming, it will become much easier for you to read and learn databases and web applications, and you will understand what you read much easier and in greater depth rather than if you directly begin learning SQL, ASP.NET, AJAX, XAML or WinRT.
Some of your colleagues directly begin programming with Web or mobile applications and databases without knowing what an array, a list or hash table is. Do not envy them! They have set out to do it the hard way, backwards. They will learn to make low-quality websites with PHP and MySQL, but they will find it infinitely difficult to become real professionals. You, too, will learn web technologies and databases, but before you take them up, learn how to program! This is much more important. Learning one technology or another is very easy once you know the basics, when you can think algorithmically and you know how to tackle programming problems.
 	Starting to program with web applications or/and databases is just as incorrect as studying up a foreign language from some classical novel rather than from the alphabet and a textbook for beginners. It is not impossible, but if you lack the basics, it is much more difficult. It is highly-probable that you would end up lacking vital fundamental knowledge and being the laughing-stock of your colleagues/peers.
How Is the Information Presented?
Despite the large number of authors, co-authors and editors, we have done our best to make the style of the book similar in all chapters and highly comprehensible. The content is presented in a well-structured manner; it is broken up into many titles and subtitles, which make its reception easy and looking up information in the text quick.
The present book is written by programmers for programmers. The authors are active software developers, colleagues with genuine experience in both software development and training future programmers. Due to this, the quality of the content presentation is at a very good level, as you will see for yourself.
All authors are distinctly aware that the sample source code is one of the most important things in a book on programming. Due to this very reason, the text is accompanied with many, many examples, illustrations and figures.
When every chapter is written by a different author, there is no way to completely avoid differences in the style of speech and the quality of chapters. Some authors put a lot of work (for months) and a lot of efforts to make their chapters perfect. Others could not invest too much effort and that is why some chapters are not as good as the best ones. Last but not least, the experience of the authors varies – some have been programming professionally for 2-3 years, while others – for 15 years. This affects the quality, no doubt, but we assure you that every chapter has been reviewed and meets the quality standards of Svetlin Nakov and his team.
C# and .NET Framework
This book is about programming. It is intended to teach you to think as a programmer, to write code, to think in data structures and algorithms and to solve problems.
We use C# and Microsoft .NET Framework (the platform behind C#) only as means for writing programming code and we do not scrutinize the language’s specifics. This same book can be found in versions for other languages like Java and C++, but the differences are not very significant.
Nevertheless, let’s give a short account of C# (pronounced "see sharp").
 	C# is a modern programming language for development of software applications.
If the words "C#" and ".NET Framework" are unknown to you, you’ll learn in details about them and their connection in the next chapter. Now let’s explain briefly what C#, .NET, .NET Framework, CLR and the other technologies related to C# are.
The C# Programming Language
C# is a modern object-oriented, general-purpose programming language, created and developed by Microsoft together with the .NET platform. There is highly diverse software developed with C# and on the .NET platform: office applications, web applications, websites, desktop applications, mobile applications, games and many others.
C# is a high-level language that is similar to Java and C++ and, to some extent, languages like Delphi, VB.NET and C. All C# programs are object-oriented. They consist of a set of definitions in classes that contain methods and the methods contain the program logic – the instructions which the computer executes. You will find out more details on what a class, a method and C# programs are in the next chapter.
Nowadays C# is one of the most popular programming languages. It is used by millions of developers worldwide. Because C# is developed by Microsoft as part of their modern platform for development and execution of applications, the .NET Framework, the language is widely spread among Microsoft-oriented companies, organizations and individual developers. For better or for worse, as of this book writing, the C# language and the .NET platform are maintained and managed entirely by Microsoft and are not open to third parties. Because of this, all other large software corporations like IBM, Oracle and SAP base their solutions on the Java platform and use Java as their primary language for developing their own software products.
Unlike C# and the .NET Framework, the Java language and platform are open-source projects that an entire community of software companies, organizations and individual developers take part in. The standards, the specifications and all the new features in the world of Java are developed by workgroups formed out of the entire Java community, rather than a single company (as the case of C# and .NET Framework).
The C# language is distributed together with a special environment on which it is executed, called the Common Language Runtime (CLR). This environment is part of the platform .NET Framework, which includes CLR, a bundle of standard libraries providing basic functionality, compilers, debuggers and other development tools. Thanks to the framework CLR programs are portable and, once written they can function with little or no changes on various hardware platforms and operating systems. C# programs are most commonly run on MS Windows, but the .NET Framework and CLR also support mobile phones and other portable devices based on Windows Mobile, Windows Phone and Windows 8. C# programs can still be run under Linux, FreeBSD, iOS, Android, MacOS X and other operating systems through the free .NET Framework implementation Mono, which, however, is not officially supported by Microsoft.
The Microsoft .NET Framework
The C# language is not distributed as a standalone product – it is a part of the Microsoft .NET Framework platform (pronounced "Microsoft dot net framework"). .NET Framework generally consists of an environment for the development and execution of programs, written in C# or some other language, compatible with .NET (like VB.NET, Managed C++, J# or F#). It consists of:
	the .NET programming languages (C#, VB.NET and others);
	an environment for the execution of managed code (CLR), which executes C# programs in a controlled manner;
	a set of development tools, such as the csc compiler, which turns C# programs into intermediate code (called MSIL) that the CLR can understand;
	a set of standard libraries, like ADO.NET, which allow access to databases (such as MS SQL Server or MySQL) and WCF which connects applications through standard communication frameworks and protocols like HTTP, REST, JSON, SOAP and TCP sockets.
The .NET Framework is part of every modern Windows distribution and is available in different versions. The latest version can be downloaded and installed from Microsoft’s website. As of this book’s publishing, the latest version of the .NET Framework is 4.5. Windows Vista includes out-of-the-box .NET Framework 2.0, Windows 7 – .NET 3.5 and Windows 8 – .NET 4.5.
Why C#?
There are many reasons why we chose C# for our book. It is a modern programming language, widely spread, used by millions of programmers around the entire world. At the same time C# is a very simple and easy to learn (unlike C and C++). It is natural to start with a language that is suitable for beginners while still widely used in the industry by many large companies, making it one of the most popular programming languages nowadays.
C# or Java?
Although this can be extensively discussed, it is commonly acknowledged that Java is the most serious competitor to C#. We will not make a comparison between Java and C#, because C# is undisputedly the better, more powerful, richer and just better engineered. But, for the purposes of this book, we have to emphasize that any modern programming language will be sufficient to learn programming and algorithms. We chose C#, because it is easier to learn and is distributed with highly convenient, free integrated development environment (e.g. Visual C# Express Edition). Those who prefer Java can prefer to use the Java version of this book, which can be found here: www.introprogramming.info.
Why Not PHP?
With regards to programing languages popularity, besides C# and Java, another widely used language is PHP. It is suitable for developing small web sites and web applications, but it gives rise to serious difficulties when implementing large and complicated software systems. In the software industry PHP is used first and foremost for small projects, because it can easily lead developers into writing code that is bad, disorganized and hard to maintain, making it inconvenient for more substantial projects. This subject is also debatable, but it is commonly accepted that, because of its antiquated concepts and origins it is built on and because of various evolutionary reasons, PHP is a language that tends towards low-quality programming, writing bad code and creating hard to maintain software. PHP is a procedural language in concept and although it supports the paradigms of modern object-oriented programming, most PHP programmers write procedurally. PHP is known as the language of "code monkeys" in the software engineering profession, because most PHP programmers write terrifyingly low-quality code. Because of the tendency to write low-quality, badly structured and badly organized programming code, the entire concept of the PHP language and platform is considered wrong and serious companies (like Microsoft, Google, SAP, Oracle and their partners) avoid it. Due to this reason, if you want to become a serious software engineer, start with C# or Java and avoid PHP (as much as possible).
Certainly, PHP has its uses in the world of programming (for example creating a blog with WordPress, a small web site with Joomla or Drupal, or a discussion board with PhpBB), but the entire PHP platform is not well-organized and engineered for large systems like .NET and Java. When it comes to non-web-based applications and large industrial projects, PHP is not by a long shot among the available options. Lots and lots of experience is necessary to use PHP correctly and to develop high-quality professional projects with it. PHP developers usually learn from tutorials, articles and low-quality books and pick up bad practices and habits, which then are hard to eradicate. Therefore, do not learn PHP as your first development language. Start with C# or Java.
Based on the large experience of the authors' collective we advise you to begin programming with C# and ignore languages such as C, C++ and PHP until the moment you have to use them.
Why Not C or C++?
Although this is also debatable, the C and C++ languages are considered rather primitive, old and decaying. They still have their uses and are suitable for low-level programming (e.g. programming for specialized hardware devices), but we do not advise you to pursue them.
You can program in pure C, if you have to write an operating system, a hardware device driver or if you want to program an embedded device, because of the lack of alternatives and the need to control the hardware very carefully. The C language is morally old and in no way do we advise you to begin programming with it. A programmer’s productivity under pure C is many times lower compared to their productivity under modern general-purpose programming languages like C# and Java. A variant of C is used among Apple / iPhone developers, but not because it is a good language, but because there is no decent alternative. Most Apple-oriented programmers do not like Objective-C, but they have no choice in writing in something else.
C++ is acceptable when you have to program applications that require very close work with the hardware or that have special performance requirements (like 3D games). For all other purposes (like web applications development or business software) C++ is phenomenally inadequate. We do not advise you to pursue it, if you are starting with programming just now. The reason it is still being studied in some schools and universities is hereditary, because these institutions are very conservative. For example, the International Olympiad in Informatics (IOI) continues to promote C++ as the only language permitted to use at programming contests, although C++ is rarely used in the industry. If you don’t believe this, look through some job search site and count the percentage of job advertisements with C++.
The C++ language lost its popularity mainly because of the inability to quickly write quality software with it. In order to write high-quality software in C++, you have to be an incredibly smart and experienced programmer, whereas the same is not strictly required for C# and Java. Learning C++ takes much more time and very few programmers know it really well. The productivity of C++ programmers is many times lower than C#’s and that is why C++ is losing ground. Because of all these reasons, the C++ language is slowly fading away and therefore we do not advise you to learn it.
Advantages of C#
C# is an object-oriented programming language. Such are all modern programming languages used for serious software systems (like Java and C++). The advantages of object-oriented programming are brought up in many passages throughout the book, but, for the moment, you can think of object-oriented languages as languages that allow working with objects from the real world (for example student, school, textbook, book and others). Objects have properties (e.g. name, color, etc.) and can perform actions (e.g. move, speak, etc.).
By starting to program with C# and the .NET Framework platform, you are on a very perspective track. If you open a website with job offers for programmers, you’ll see for yourself that the demand for C# and .NET specialists is huge and is close to the demand for Java programmers. At the same time, the demand for PHP, C++ and other technology specialists is far lower than the demand for C# and Java engineers.
For the good programmer, the language they use is of no significant meaning, because they know how to program. Whatever language and technology they might need, they will master it quickly. Our goal is not to teach you C#, but rather teach you programming! After you master the fundamentals of programming and learn to think algorithmically, when you acquaint with other programming languages,  you will see for yourself how much in common they have with C# and how easy it will be to learn them. Programming is built upon principles that change very slowly over the years and this book teaches you these very principles.
Examples Are Given in C# 5 and Visual Studio 2012
All examples in this book are with regard to version 5.0 of the C# language and the .NET Framework 4.5 platform, which is the latest as of this book’s publishing. All examples on using the Visual Studio integrated development environment are with regard to version 2012 of the product, which were also the latest at the time of writing this book.
The Microsoft Visual Studio 2012 integrated development environment (IDE) has a free version, suitable for beginner C# programmers, called Microsoft Visual Studio Express 2012 for Windows Desktop. The difference between the free and the full version of Visual Studio (which is a commercial software product) lies in the availability of some functionalities, which we will not need in this book.
Although we use C# 5 and Visual Studio 2012, most examples in this book will work flawlessly under .NET Framework 2.0 / 3.5 / 4.0 and C# 2.0 / 3.5 / 4.0 and can be compiled under Visual Studio 2005 / 2008 / 2010.
It is of no great significance which version of C# and Visual Studio you’ll use while you learn programming. What matters is that you learn the principles of programming and algorithmic thinking! The C# language, the .NET Framework platform and the Visual Studio integrated development environment are just tools and you can exchange them for others at any time. If you read this book and VS2012 is not currently the latest, be sure almost all of this book’s content will still be the same due to backward compatibility.
How Ňî Read This Book?
Reading this book has to be accompanied with lots and lots of practice. You won’t learn programming, if you don’t practice! It would be like trying to learn how to swim from a book without actually trying it. There is no other way! The more you work on the problems after every chapter, the more you will learn from the book.
Everything you read here, you would have to try for yourself on a computer. Otherwise you won’t learn anything. For example, once you read about Visual Studio and how to write your first simple program, you must by all means download and install Microsoft Visual Studio (or Visual C# Express) and try to write a program. Otherwise you won’t learn! In theory, everything seems easy, but programming means practice. Remember this and try to solve the problems from this book. They are carefully selected – they are neither too hard to discourage you, nor too easy, so you’ll be motivated to perceive solving them as a challenge. If you encounter difficulties, look for help at the discussion group for the "C# Programming Fundamentals" training course at Telerik Software Academy: http://forums.academy.telerik.com (the forum is intended for Bulgarian developers but the people "living" in it speak English and will answer your questions regarding this book, don’t worry). Thousands students solve the exercises from this book every year so you will find many solutions to each problem from the book. We will also publish official solutions + tests for every exercise in the book at its web site.
 	Reading this book without practicing is meaningless! You must spend much more time on writing programs than reading the text itself. It is just like learning to drive: no one can learn driving by reading books. To learn driving, you need to drive many times in different situations, roads, cars, etc. To learn programming, you need to program!
Everybody has studied math in school and knows that learning how to solve math problems requires lots of practice. No matter how much they watch and listen to their teachers, without actually sitting down and solving problems, they won’t learn. The same goes for programming. You need lots of practice. You need to write a lot, to solve problems, to experiment, to endeavor in and to struggle with problems, to make mistakes and correct them, to try and fail, to try anew and experience the moments when things finally work out. You need lots and lots of practice. This is the only way you will make progress.
So people say that to become a developer you might need to write at least 50,000 – 100,000 lines of code, but the correct number can vary a lot. Some people are fast learners or just have problem-solving experience. Others may need more practice, but in all cases practicing programming is very important! You need to solve problems and to write code to become a developer. There is no other way!
Do Not Skip the Exercises!
At the end of each chapter there is a considerable list of exercises. Do not skip them! Without exercises, you will not learn a thing. After you read a chapter, you should sit in front of the computer and play with the examples you have seen in the book. Then you should set about solving all problems. If you cannot solve them all, you should at least try. If you don’t have all the time necessary, you must at least attempt solving the first few problems from each chapter. Do not carry on without solving problems after every chapter, it would just be meaningless! The problems are small feasible situations where you apply the stuff you have read. In practice, once you have become programmers, you would solve similar problems every day, but on a larger and more complex scale.
 	You must at all cost strive to solve the exercise problems after every chapter from the book! Otherwise you risk not learning anything and simply wasting your time.
How Much Time Will We Need for This Book?
Mastering the fundamentals of programming is a crucial task and takes a lot of time. Even if you’re incredibly good at it, there is no way that you will learn programming on a good level for a week or two. To learn any human skill, you need to read, see or be shown how it is done and then try doing it yourselves and practice a lot. The same goes for programming – you must either read, see or listen how it is done, then try doing it yourself. Then you would succeed or you would not and you would try again, until you finally realize you have learned it. Learning is done step by step, consecutively, in series, with a lot of effort and consistency.
If you want to read, understand, learn and acquire thoroughly and in-depth the subject matter in this book, you have to invest at least 2 months for daylong activity or at least 4-5 months, if you read and exercise a little every day. This is the minimum amount of time it would take you to be able to grasp in depth the fundamentals of programming.
The necessity of such an amount of lessons is confirmed by the free trainings at Telerik Software Academy (http://academy.telerik.com), which follow this very book. The hundreds of students, who have participated in trainings based on the lectures from this book, usually learn all subjects from this book within 3-4 months of full-time work. Thousands of students every year solve all exercise problems from this book and successfully sit on programming exams covering the book’s content. Statistics shows that anyone without prior exposure to programming, who has spent less than the equivalent of 3-4 months daylong activity on this book and the corresponding courses at Telerik Academy, fails the exams.
The main subject matter in the book is presented in more than 1100 pages, which will take you a month (daylong) just to read them carefully and test the sample programs. Of course, you have to spend enough time on the exercises (few more months); without them you would hardly learn programming.
Exercises: Complex or Easy?
The exercises in the book consist of about 350 problems with varying difficulty. For some of them you will need a few minutes, for others several hours (if you can solve them at all without help). This means you would need a month or two of daylong exercising or several months, if you do it little by little.
The exercises at each chapter are ordered in increasing level of difficulty. The first few exercises are easy, similar to the examples in the chapter. The last few exercises are usually complex. You might need to use external resources (like information from Wikipedia) to solve them. Intentionally, the last few exercises in each chapter require skills outside of the chapter. We want to push you to perform a search in your favorite search engine. You need to learn searching on the Internet! This is an essential skill for any programmer. You need to learn how to learn. Programming is about learning every day. Technologies constantly change and you can’t know everything. To be a programmer means to learn new APIs, frameworks, technologies and tools every day. This cannot be avoided, just prepare yourself. You will find many problems in the exercises, which require searching on the Internet. Sometimes you will need the skills from the next chapter, sometimes some well-known algorithm, sometimes something else, but in all cases searching on the Internet is an essential skill you need to acquire.
Solving the exercises in the book takes a few months, really. If you don’t have that much time at your disposal, ask yourselves if you really want to pursue programming. This is a very serious initiative in which you must invest a really great deal of efforts. If you really want to learn programming on a good level, schedule enough time and follow the book or the video lectures based on it.
Why Are Data Structures and Algorithms Emphasized?
This book teaches you, in addition to the basic knowledge in programming, proper algorithmic thinking and using basic data structures in programming. Data structures and algorithms are a programmer’s most important fundamental skills! If you have a good grasp of them, you will not have any trouble becoming proficient in any software technology, development tool, framework or API. That is what the most serious software companies rely on when hiring employees. Proof of this are job interviews at large companies like Google and Microsoft that rely exclusively on algorithmic thinking and knowledge of all basic data structures and algorithms.
The information below comes from Svetlin Nakov, the leading author of this book, who passed software engineering interviews at Microsoft and Google in 2007-2008 and shares his own experience.
Job Interviews at Google
100% of the questions at job interviews for software engineers at Google, Zurich, are about data structures, algorithms and algorithmic thinking. At such an interview you may have to implement on a white board a linked list (see the chapter "Linear Data Structures") or come up with an algorithm for filling a raster polygon (given in the form of a GIF image) with some sort of color (see Breadth-first search in the chapter "Trees and Graphs"). It seems like Google are interested in hiring people who can think algorithmically and who have a grasp of basic data structures and computer algorithms. Any technology that candidates would afterwards use in their line of work can be quickly learned. Needless to say, do not assume this book will give you all the knowledge and skills to pass a job interview at Google. The knowledge in the book is absolutely a necessary minimum, but not completely sufficient. It only marks the first steps.
Job Interviews at Microsoft
A lot of questions at job interviews for software engineers at Microsoft, Dublin, focus on data structures, algorithms and algorithmic thinking. For example, you could be asked to reverse the words in a string (see the chapter "Strings and Text Processing" or to implement topological sorting in an undirected graph (see the chapter "Trees and Graphs"). Unlike Google, Microsoft asks a lot of engineering questions related to software architectures, multithreading, writing secure code, working with large amounts of data and software testing. This book is far from sufficient for applying at Microsoft, but the knowledge in it will surely be of use to you for the majority of questions.
About the LINQ Technology
The book includes a chapter on the popular .NET technology LINQ (Language Integrated Query), which allows execution of various queries (such as searching, sorting, summation and other group operations) on arrays, lists and other objects. It is placed towards the end on purpose, after the chapters on data structures and algorithms complexity. The reason behind this is that the good programmer must know what happens when they sort a list or search in an array according to criteria and how many operations these actions take. If LINQ is used, it is not obvious how a given query works and how much time it takes. LINQ is a very powerful and widely-used technology, but it has to be mastered at a later stage (at the end of the book), after you are well familiar with the basics of programming, the main algorithms and data structures. Otherwise you risk learning how to write inefficient code without realizing how it works and how many operations it performs in the background.
Do You Really Want to Become a Programmer?
If you want to become a programmer, you have to be aware that true programmers are serious, persevering, thinking and questioning people who handle all kinds of problems. It is important for them to master quickly all modern or legacy platforms, technologies, libraries, APIs, programming tools, programming languages and development tools necessary for their job and to feel programming as a part of their life.
Good programmers spend an extraordinary amount of time on advancing their engineering skills, on learning new technologies, new programming languages and paradigms, new ways to do their job, new platforms and new development tools every day. They are capable of logical thinking; reasoning on problems and coming up with algorithms for solving them; imagining solutions as a series of steps; modeling the surrounding world using technological means; implementing their ideas as programs or program components; testing their algorithms and programs; seeing issues; foreseeing the exceptional circumstances that can come about and handling them properly; listening to the advice of more experienced people; adapting their applications’ user interface to the user’s needs; adapting their algorithms to the capabilities of the machines and the environment they will be executed on and interacted with.
Good programmers constantly read books, articles or blogs on programming and are interested in new technologies; they constantly enrich their knowledge and constantly improve the way they work and the quality of software they write. Some of them become obsessed to such an extent that they even forget to eat or sleep when confronted with a serious problem or simply inspired by some interesting lecture or presentation. If you have the tendency to get motivated to such an extent to do something (like playing video games incessantly), you can learn programming very quickly by getting into the mindset that programming is the most interesting thing in this world for you, in this period of your life.
Good programmers have one or more computers, an Internet connection and live in constant reach with technologies. They regularly visit websites and blogs related to new technologies, communicate everyday with their colleagues, visit technology lectures, seminars and other events, even if they have no use for them at the moment. They experiment with or research the new means and new ways for making a piece of software or a part of their work. They examine new libraries, learn new languages, try new frameworks and play with new development tools. That way they develop their skills and maintain their level of awareness, competence and professionalism.
True programmers know that they can never master their profession to its full extent, because it constantly changes. They live with the firm belief that they have to learn their entire lives; they enjoy this and it satisfies them. True programmers are curious and questioning people that want to know how everything works – from a simple analog clock to a GPS system, Internet technology, programming languages, operation systems, compilers, computer graphics, games, hardware, artificial intelligence and everything else related to computers and technologies. The more they learn, the more knowledge and skills they crave after. Their life is tied to technologies and they change with them, enjoying the development of computer science, technologies and the software industry.
Everything we tell you about true programmers, we know firsthand. We are convinced that programmer is a profession that requires your full devotion and complete attention, in order to be a really good specialist – experienced, competent, informed, thinking, reasoning, knowing, capable and able to deal with non-standard situations. Anyone who takes up programming "among other things" is fated to being a mediocre programmer. Programming requires complete devotion for years. If you are ready for all of this, continue reading and take into account that the next few months you will spend on this book on programming are just a small start. And then you will learn for years until you turn programming into your profession. Once that happens, you would still learn something every day and compete with technologies, so that you can maintain your level, until one day programming develops your thinking and skills enough, so that you may take up another profession, because few programmers reach retirement; but there are quite a lot of successful people who have begun their careers with programming.
Motivate Yourself to Become a Programmer or Find Another Job!
If you still haven’t given up on becoming a good programmer and if you have already come to the understanding deep down that the next months and years will be tied every day to constant diligent work on mastering the secrets of programming, software development, computer science and software technologies, you may use an old technique for self-motivation and confident achievement of goals that can be found in many books and ancient teachings under one form or another. Keep imagining that you are programmers and that you have succeeded in becoming ones; you engage every day in programming; it is your profession; you can write all the software in the world (provided you have enough time); you can solve any problem that experienced programmers can solve. Keep thinking constantly and incessantly of your goal. Keep telling yourself, sometimes even out loud: "I want to become a good programmer and I have to work hard for this, I have to read a lot and learn a lot, I have to solve a lot of problems, every day, constantly and diligently". Put programming books everywhere around you, even stick a sign that says "I’ll become a good programmer" by your bed, so that you can see it every evening when you go to bed and every morning when you wake up. Program every day (no exceptions!), solve problems, have fun, learn new technologies, experiment; try writing a game, making a website, writing a compiler, a database and hundreds of other programs you may come up with original ideas for. In order to become good programmers, program every day and think about programming every day and keep imagining the future moment when you are an excellent programmer. You can, as long as you deeply believe that you can! Everybody can, as long as they believe that they can and pursue their goals constantly without giving up. No-one would motivate you better than yourselves. Everything depends on you and this book is your first step.
 	A great way to really learn programming is to program every day for a year. If you program every day (without exception) and you do it for a long time (e.g. year or two) there is no way to not become a programmer. Anyone who practices programming every day for years will become good someday. This is valid for any other skill: if you want to learn it, just practice every day for a long time.
A Look at the Book’s Contents
Now let’s take a glance at what we are about to encounter in the next chapters of the book. We will give an account of each of them with a few sentences, so that you know what you are about to learn.
Chapter 0: Preface
The preface (the current chapter) introduces the readers to the book, its content, what the reader will learn and what will not, how to read the book, why we use the C# language, why we focus on data structures and algorithms, etc. The preface also describes the history of the book, the content of its chapter one by one, the team of authors, editors and translators from Bulgarian to English. In contains the full reviews written by famous software engineers from Microsoft, Google, SAP, VMware, Telerik and other leading software companies from all over the world.
Author of the preface is Svetlin Nakov (with little contribution from Veselin Kolev and Mihail Stoynov). Translation to English: by Ivan Nenchovski (edited by Mihail Stoynov, Veselina Raykova, Yoan Krumov and Hristo Radkov).
Chapter 1: Introduction to Programming
In the chapter "Introduction to Programming", we will take a look at the basic terminology in programming and write our first program. We will familiarize ourselves with what programming is and what connection to computers and programming languages it has. We will briefly review the main stages in software development, introduce the C# language, the .NET platform and the different Microsoft technologies used in software development. We will examine what auxiliary tools we need to program in C# and use the C# language to write our first computer program, compile it and run it using the command line, as well as Microsoft Visual Studio integrated development environment. We will familiarize ourselves with the MSDN Library – the documentation for the .NET Framework, which will help us in our study of the language’s capabilities.
Author of the chapter is Pavel Donchev; editors are Teodor Bozhikov and Svetlin Nakov. The content of the chapter is somewhat based on the work of Luchesar Cekov from the book "Introduction to Programming with Java". Translation to English: by Atanas Valchev (edited by Vladimir Tsenev and Hristo Radkov).
Chapter 2: Primitive Types and Variables
In the chapter "Primitive Types and Variables", we will examine primitive types and variables in C# – what they are and how to work with them. First, we will focus on data types – integer types, real floating-point types, Boolean, character types, strings and object types. We will continue with variables, what they and their characteristics are, how to declare them, how they are assigned a value and what variable initialization is. We will familiarize ourselves with the main categories of data types in C# – value and reference types. Finally, we will focus on literals, what they are and what kinds of literals there are.
Authors of the chapter are Veselin Georgiev and Svetlin Nakov; editor is Nikolay Vasilev. The content of the entire chapter is based on the work of Hristo Todorov and Svetlin Nakov from the book "Introduction to Programming with Java". Translation to English: by Lora Borisova (edited by Angel Angelov and Hristo Radkov).
Chapter 3: Operators and Expressions
In the chapter "Operators and Expressions", we will familiarize ourselves with the operators in C# and the operations they perform on the various data types. We will clarify the priorities of operators and familiarize ourselves with the types of operators, according to the count of the arguments they take and the operations they perform. Then, we will examine typecasting, why it is necessary and how to work with it. Finally, we will describe and illustrate expressions and how they are utilized.
Authors of the chapter are Dilyan Dimitrov and Svetlin Nakov; editor is Marin Georgiev. The content of the entire chapter is based on the work of Lachezar Bozhkov from the book "Introduction to Programming with Java". Translation to English: by Angel Angelov (edited by Martin Yankov and Hristo Radkov).
Chapter 4: Console Input and Output
In the chapter "Console Input and Output", we will get familiar with the console as a means for data input and output. We will explain what it is, when and how it is used, what the concepts of most programming languages for accessing the console are. We will familiarize ourselves with some of the features in C# for user interaction and will examine the main streams for input-output operations Console.In, Console.Out and Console.Error, the class Console and the utilization of format strings for printing data in various formats. We will see how to convert text into a number (parsing), since this is the way to enter numbers in C#.
Author of the chapter is Iliyan Murdanliev and editor is Svetlin Nakov. The content of the entire chapter is largely based on the work of Boris Valkov from the book "Introduction to Programming with Java". Translation to English: by Lora Borisova (edited by Dyanko Petkov).
Chapter 5: Conditional Statements
In the chapter "Conditional Statements" we will cover the conditional statements in C#, which we can use to execute different actions depending on some condition. We will explain the syntax of the conditional operators: if and if-else with suitable examples and explain the practical applications of the selection control operator switch. We will focus on the best practices that must be followed, in order to achieve a better style of programming when utilizing nested or other types of conditional statements.
Author of the chapter is Svetlin Nakov and editor is Marin Georgiev. The content of the entire chapter is based on the work of Marin Georgiev from the book "Introduction to Programming with Java". Translation to English: by George Vaklinov (edited by Momchil Rogelov).
Chapter 6: Loops
In the chapter "Loops", we will examine the loop mechanisms, through which we can execute a snippet of code repeatedly. We will discuss how conditional repetitions (while and do-while loops) are implemented and how to work with for loops. We will give examples of the various means for defining a loop, the way they are constructed and some of their key applications. Finally, we will see how we can use multiple loops within each other (nested loops).
Author of the chapter is Stanislav Zlatinov and editor is Svetlin Nakov. The content of the entire chapter is based on the work of Rumyana Topalska from the book "Introduction to Programming with Java". Translation to English: by Angel Angelov (edited by Lora Borisova).
Chapter 7: Arrays
In the chapter "Arrays", we will familiarize ourselves with arrays as a means for working with a sequence of elements of the same type. We will explain what they are, how we can declare, create and instantiate arrays and how to provide access to their elements. We will examine one-dimensional and multidimensional arrays. We will learn the various ways for iterating through an array, reading from the standard input and writing to the standard output. We will give many exercises as examples, which can be solved using arrays, and show you how useful they are.
Author of the chapter is Hristo Germanov and editor is Radoslav Todorov. The content of the chapter is based on the work of Mariyan Nenchev from the book "Introduction to Programming with Java". Translation to English: by Boyan Dimitrov (edited by Radoslav Todorov and Zhelyazko Dimitrov).
Chapter 8: Numeral Systems
In the chapter "Numeral Systems", we will take a look at the means for working with various numeral systems and the representation of numbers in them. We will pay special attention to the way numbers are represented in decimal, binary and hexadecimal numeral systems, because they are widely used in computers, communications and programming. We will also explain the methods for encoding numeral data in a computer and the types of encodings, namely signed magnitude, one’s complement, two’s complement and binary-coded decimals.
Author of the chapter is Teodor Bozhikov and editor is Mihail Stoynov. The content of the entire chapter is based on the work of Petar Velev and Svetlin Nakov from the book "Introduction to Programming with Java". Translation to English: by Atanas Valchev (edited by Veselina Raykova).
Chapter 9: Methods
In the chapter "Methods", we will get to know in details the subroutines in programming, which are called methods in C#. We will explain when and why methods are used; will show how methods are declared and what a method signature is. We will learn how to create a custom method and how to use (invoke) it subsequently, and will demonstrate how we can use parameters in methods and how to return a result from a method. Finally, we will discuss some established practices when working with methods. All of this will be backed up with examples explained in details and with extra exercises.
Author of the chapter is Yordan Pavlov; editors are Radoslav Todorov and Nikolay Vasilev. The content of the entire chapter is based on the work of Nikolay Vasilev from the book "Introduction to Programming with Java". Translation to English: by Ivaylo Dyankov (edited by Vladimir Amiorkov and Franz Fischbach).
Chapter 10: Recursion
In the chapter "Recursion", we will familiarize ourselves with recursion and its applications. Recursion is a powerful programming technique where a method invokes itself. By means of recursion we can solve complicated combinatorial problems where we can easily exhaust different combinatorial configurations. We will demonstrate many examples of correct and incorrect recursion usage and we will convince you how useful it can be.
Author of the chapter is Radoslav Ivanov and editor is Svetlin Nakov. The content of the entire chapter is based on the work of Radoslav Ivanov and Svetlin Nakov from the book "Introduction to Programming with Java". Translation to English: by Vasya Stankova (edited by Yoan Krumov).
Chapter 11: Creating and Using Objects
In the chapter "Creating and Using Objects", we will get to know the basic concepts of object-oriented programming – classes and objects – and we will explain how to use classes from the standard libraries of the .NET Framework. We will focus on some commonly used system classes and will show how to create and use their instances (objects). We will discuss how to access properties of an object, how to call constructors and how to work with static fields in classes. Finally, we will focus on the term "namespaces" – how they help us, how to include and use them.
Author of the chapter is Teodor Stoev and editor is Stefan Staev. The content of the entire chapter is based on the work of Teodor Stoev and Stefan Staev from the book "Introduction to Programming with Java". Translation to English: by Vasya Stankova (edited by Todor Mitev).
Chapter 12: Exception Handling
In the chapter "Exception Handling", we will get to know exceptions in object-oriented programming and in C# in particular. We will learn how to catch exceptions using the try-catch clause, how to pass them to the calling methods and how to throw standard, custom or caught exceptions using the throw statement. We will give a number of examples of their utilization and will look at the types of exceptions and the exceptions hierarchy they form in the .NET Framework. Finally, we will look at the advantages of using exceptions and how to apply them in specific situations.
Author of the chapter is Mihail Stoynov and editor is Radoslav Kirilov. The content of the entire chapter is based on the work of Luchesar Cekov, Mihail Stoynov and Svetlin Nakov from the book "Introduction to Programming with Java". Translation to English: by Dimitar Bonev and George Todorov (edited by Doroteya Agayna).
Chapter 13: Strings and Text Processing
In the chapter "Strings and Text Processing", we will familiarize ourselves with strings: how they are implemented in C# and how we can process text content. We will go through different methods for manipulating text; and learn how to extract substrings according to passed parameters, how to search for keywords as well as how to split a string by separator characters. We will provide useful information on regular expressions and we will learn how to extract data matching a specific pattern. Finally, we will take a look at the methods and classes for achieving more elegant and strict formatting of text content on the console, with various ways for printing numbers and dates.
Author of the chapter is Veselin Georgiev and editor is Radoslav Todorov. The content of the entire chapter is based on the work of Mario Peshev from the book "Introduction to Programming with Java". Translation to English: by Vesselin Georgiev (edited by Todor Mitev and Vladimir Amiorkov).
Chapter 14: Defining Classes
In the chapter "Defining Classes", we will show how we can define custom classes and what the elements of a class are. We will learn to declare fields, constructors and properties in classes and will again recall what a method is but will broaden our knowledge on methods and their access modifiers. We will focus on the characteristics of constructors and we will explain in details how program objects exist in the heap (dynamic memory) and how their fields are initialized. Finally, will explain what class static elements – fields (including constants), properties and methods – are and how to utilize them. In this chapter, we will also introduce generic types (generics), enumerated types (enumerations) and nested classes.
Authors of the chapter are Nikolay Vasilev, Svetlin Nakov, Mira Bivas and Pavlina Hadjieva. The content of the entire chapter is based on the work of Nikolay Vasilev from the book "Introduction to Programming with Java". Translation to English: by Radoslav Todorov, Yoan Krumov, Teodor Rusev and Stanislav Vladimirov (edited by Vladimir Amiorkov, Pavel Benov and Nencho Nenchev). This is the largest chapter in the book, so lots of contributors worked on it to prepare it to a high quality standard for you.
Chapter 15: Text Files
In the chapter "Text Files", we will familiarize ourselves with working with text files in the .NET Framework. We will explain what a stream is, what its purpose is and how it is used. We will describe what a text file is and how to read and write data in text files and will present and elaborate on the best practices for catching and handling exceptions when working with text files. Naturally, we will visualize and demonstrate in practice all of this with a lot of examples.
Author of the chapter is Radoslav Kirilov and editor is Stanislav Zlatinov. The content of the entire chapter is based on the work of Danail Alexiev from the book "Introduction to Programming with Java". Translation to English: by Nikolay Angelov (edited by Martin Gebov).
Chapter 16: Linear Data Structures
In the chapter "Linear Data Structures", we will familiarize ourselves with some of the basic representations of data in programming and with linear data structures, because very often, in order to solve a given problem, we need to work with a sequence of elements. For example, to read this book we have to read consecutively every single page, e.g. we have to traverse consecutively every single element of its set of pages. We are going to see how for a specific problem some data structure is more efficient and convenient than another. Then we will examine the linear structures "list", "stack" and "queue" and their applications and will get to know in details some implementations of these structures.
Author of the chapter is Tsvyatko Konov and editors are Dilyan Dimitrov and Svetlin Nakov. The content of the entire chapter is largely based on the work of Tsvyatko Konov and Svetlin Nakov from the book "Introduction to Programming with Java". Translation to English: by Vasya Stankova (edited by Ivaylo Gergov).
Chapter 17: Trees and Graphs
In the chapter "Trees and Graphs", we will look at the so called tree-like data structures, which are trees and graphs. Knowing the properties of these structures is important for modern programming. Every one of these structures is used for modeling real-life problems that can be efficiently solved with their help. We will examine in details what tree-like data structures are and show their primary advantages and disadvantages. Also, we will provide sample implementations and exercises, demonstrating their practical utiliza¬tion. Further, we will scrutinize binary trees, binary search trees and balanced trees and then examine the data structure "graph", the types of graphs and their usage. We will also show which parts of the .NET Framework make use of binary search trees.
Author of the chapter is Veselin Kolev and editors are Iliyan Murdanliev and Svetlin Nakov. The content of the entire chapter is based on the work of Veselin Kolev from the book "Introduction to Programming with Java". Translation to English: by Kristian Dimitrov and Todor Mitev (edited by Nedjaty Mehmed and Dyanko Petkov).
Chapter 18: Dictionaries, Hash Tables and Sets
In the chapter "Dictionaries, Hash Tables and Sets", we will analyze more complex data structures like dictionaries and sets, and their implementa¬tions with hash tables and balanced trees. We will explain in details what hashing and hash tables mean, and why they are such important parts of programming. We will discuss the concept of "collisions" and how they can occur when implementing hash tables. We will also suggest various approaches for solving them. We will look at the abstract data structure "set" and explain how it can be implemented with a dictionary or a balanced tree. We will provide examples that illustrate the applications of these data structures in everyday practice.
Author of the chapter is Mihail Valkov and editors are Tsvyatko Konov and Svetlin Nakov. The content of the entire chapter is partially based on the work of Vladimir Tsanev (Tsachev) from the book "Introduction to Programming with Java". Translation to English: by George Mitev and George K. Georgiev (edited by martin Gebov and Ivaylo Dyankov).
Chapter 19: Data Structures and Algorithm Complexity
In the chapter "Data Structures and Algorithm Complexity", we will compare the data structures we have learned so far based on their performance for basic operations (addition, searching, deletion, etc.). We will give recommendations for the most appropriate data structures in certain cases. We will explain when it is preferable to use a hash table, an array, a dynamic array, a set implemented by a hash table or a balanced tree. There is an implementation in the .NET Framework for every one of these structures. We only have to learn how to decide when to use a particular data structure, so that we can write efficient and reliable source code.
Authors of the chapter are Nikolay Nedyalkov and Svetlin Nakov; editor is Veselin Kolev. The content of the entire chapter is based on the work of Svetlin Nakov and Nikolay Nedyalkov from the book "Introduction to Programming with Java". Translation to English: by George Halachev and Tihomir Iliev (edited by Martin Yankov).
Chapter 20: Object-Oriented Programming Principles
In the chapter "Object-Oriented Programming Principles", we will familiarize ourselves with the principles of object-oriented programming (OOP): class inheritance, interfaces implementation, data and behavior abstraction, data encapsulation and hiding implementation details, polymorphism and virtual methods. We will explain in detail the principles of cohesion and coupling. We will also briefly outline object-oriented modeling and object model creation based on a specific business problem and will get to know UML and its role in object oriented modeling. Finally, we will briefly discuss design patterns and provide examples for design patterns commonly used in practice.
Author of the chapter is Mihail Stoynov and editor is Mihail Valkov. The content of the entire chapter is based on the work of Mihail Stoynov from the book "Introduction to Programming with Java". Translation to English: by Vasya Stankova and Momchil Rogelov (edited by Ivan Nenchovski).
Chapter 21: High-Quality Programming Code
In the chapter "High-Quality Programming Code", we will take a look at the basic rules for writing high-quality programming code. We will focus on naming conventions for program elements (variables, methods, classes and others), formatting and code layout guidelines, best practices for creating high-quality classes and methods, and the principles of high-quality code documentation. Many examples of high-quality and low-quality code will be given. In the course of work, it will be explained how to use an integrated development environment, in order to automate some operations like formatting and refactoring existing code, when it is necessary. Unit testing as an industrial method to automated testing will also be discussed.
Authors of the chapter are Mihail Stoynov and Svetlin Nakov. Editor is Pavel Donchev. The content of the entire chapter is partially based on the work of Mihail Stoynov, Svetlin Nakov and Nikolay Vasilev from the book "Introduction to Programming with Java". Translation to English: by Blagovest Buyukliev (edited by Dyanko Petkov, Mihail Stoynov and Martin Yankov).
Chapter 22: Lambda Expressions and LINQ
In the chapter "Lambda Expressions and LINQ", we will introduce some of the more sophisticated capabilities of C#. To be more specific, we will pay special attention to clarifying how to make queries to collections using lambda expressions and LINQ. We will explain how to add functionality to already created classes, using extension methods. We will familiarize ourselves with anonymous types and briefly describe their nature and usage. We will also discuss lambda expressions and show in practice how most of the built-in lambda functions work. Afterwards we will dive into the LINQ’s syntax, which is part of C#. We will learn what it is, how it works, and what queries we can make using it. Finally, we will discuss the keywords in LINQ, their meaning and we will demonstrate their capabilities with a lot of examples.
Author of the chapter is Nikolay Kostov and editor is Veselin Kolev. Translation to English: by Nikolay Kostov (edited by Zhasmina Stoyanova and Mihail Stoynov).
Chapter 23: Methodology of Problem Solving
In the chapter "Methodology of Problem Solving", we will discuss an advisable approach for solving programming problems and we will illustrate it with concrete examples. We will discuss the engineering principles we should follow when solving problems (that largely apply to problems in math, physics and other disciplines) and we will show them in action. We will describe the steps we must go through while we solve a few sample problems and demonstrate the mistakes that can be made, if we do not follow these steps. We will consider some important steps of problem solving (such as testing) that are usually skipped.
Author of the chapter is Svetlin Nakov and editor is Veselin Georgiev. The content of the whole chapter is entirely based on the work of Svetlin Nakov from the book "Introduction to Programming with Java". Translation to English: by Ventsi Shterev and Martin Radev (edited by Tihomir Iliev and Nedjaty Mehmed).
Chapters 24, 25, 26: Sample Programming Exam
In the chapters "Sample Programming Exam (Topic #1, Topic #2 and Topic #3)", we will look at the problem descriptions of nine sample problems from three sample programming exams and we will propose solutions to them. In the course of solving them, we will put into practice the methodology described in the chapter "Methodology of Problem Solving".
Authors of the chapters are Stefan Staev, Yosif Yosifov and Svetlin Nakov respectively; their respective editors are Radoslav Todorov, Radoslav Ivanov and Teodor Stoev. The contents of these chapters are largely based on the work of Stefan Staev, Svetlin Nakov, Radoslav Ivanov and Teodor Stoev from the book "Introduction to Programming with Java". Translation to English: by Stanislav Vladimirov, Ivaylo Gergov, Ivan Nenchovski and Ivaylo Gergov (edited by Dyanko Petkov, Vladimir Tsenev and Veselina Raykova).
Chapters 28: Conclusion
In the conclusion we give further instruction how to proceed with your development as a skillful software engineer after this book. We explain the free courses at Telerik Software Academy – the largest training center for software development professionals in Bulgaria – how to apply, what you will learn, how to choose a career path and we mention few other resources.
Author of the chapter is Svetlin Nakov. Translation to English: by Ivan Nenchovski (edited by Svetlin Nakov).
History: How Did This Book Come to Be?
Often in our teaching practice students ask us from which book to start learning how to program. There are enthusiastic young people who want to learn programming, but don’t know what to begin with. Unfortunately, it’s hard to recommend a good book. We can come up with many books concerning C#, but none of them teaches programming. Indeed there aren’t many books that teach the concepts of computer programming, algorithmic thinking and data structures. Certainly, there are books for beginners that teach the C# programming language, but those rarely cover the fundamentals of program¬ming. There are some good books on programming, but most of them are now outdated and teach languages and technologies that have become obsolete in the process of evolution. There are several such books regarding C and Pascal, but not C# or Java. Considering all aspects, it is hard to come up with a good book which we could highly recommend to anyone who wants to pick up programming from scratch.
At one point, the lack of good books on programming for beginners drove the project leader, Svetlin Nakov, to gather a panel of authors set to finally write such a book. We decided we could help many young people to take up programming seriously by sharing our knowledge and inspiring them.
The Origins of This Book
This book is actually an adaptation to C# of the free Bulgarian book "Introduction to Programming with Java", with some additional content added, many bug fixes and small improvements, translated later into English.
Svetlin Nakov teaches computer programing, data structures, algorithms and software technologies since 2000. He is an author and co-author of several courses in fundamentals of programming taught at Sofia University (the most prestigious Bulgarian university at this time). Nakov (with colleagues) teaches programming and software development in the Faculty of Mathematics and Informatics (FMI) at Sofia University for few years and later creates his own company for training software engineers. In 2005, he gathers and leads a team of volunteers who creates a solid curriculum on fundamentals of programming and data structures (in C#) with presentation slides and many examples, demonstrations and homework assignments. These teaching materials are the first very early outline of the content in this book. Later this curriculum evolves and is translated to Java and serves as a base for the Java version of this book. Later the Java book is translated to C# and after its great success in Bulgaria (thousands paper copies sold and 50,000 downloads) it is translated from Bulgarian to English.
The Java Programming Fundamentals Book
In mid-2008, Svetlin Nakov is inspired to create a book on Java programming, covering his "Introduction to Programming" course in the National Academy for Software Development (a private training center in Bulgaria, founded by Svetlin Nakov). He and a group of authors outline the work that needs to be done and the subjects that need to be covered and work begins, with everyone working voluntarily, without any direct profit. Through delays, pitfalls and improvements, the Java book finally comes out in January of 2009. It is available both on its website www.introprogramming.info for free, and in a paper edition.
The C# Programming Fundamentals Book
The interest towards the "Introduction to Programming with Java" book is huge (for Bulgaria). In late 2009, the project to "translate" the book to C# begins, under the title "Introduction to Programming with C#". Again, a large number of authors, both new and from the Java book group, gather and begin working. The task seems easier, but turns out to be time-consuming. About half a year later, the "preview" edition of the book is completed – with some mistakes and incorrect content. Another year passes as all of the text and examples are improved, and new content is added. In the summer of 2011, the C# book is released. Its official website stays the same as the Java book (www.introprogramming.info). A paper version of the book is also released and sold, with a price covering only the expenses of its printing.
Both books are open-source and their repositories are available at Google Code: code.google.com/p/introcsharpbook, code.google.com/p/introjavabook.
The Translation of the C# Book: from Bulgarian to English
In late 2011, following the great success of "Introduction to Programming with C#", a project to translate the book to English started. Large group of volunteers began work on the translation – each of them with good programming skills. The book you are reading is the result of the successful translation, review and completion of the original C# Bulgarian book. The most effort in the translation was given by the leading author Svetlin Nakov.
Some of the authors have ideas to make yet another adaptation of the book – this time for C++. As of now, these ideas are still foggy. We hope they will become a reality one day, but we can’t promise anything yet.
Bulgaria? Bulgarian Authors? Is This True?
Bulgaria is a country in Europe, part of the European Union, just like Germany and France. Did you know this? Bulgaria has very solid traditions in computer programming and technologies.
The main inventor of the technology behind the modern digital computers is the famous computer engineer John Atanasoff and he is 50% Bulgarian (see en.wikipedia.org/wiki/John_Vincent_Atanasoff).
Bulgaria is the founder of the International Olympiad in Informatics (IOI). The first IOI was organized and held in 1980 in Pravetz, Bulgaria (see en.wikipedia.org/wiki/International_Olympiad_in_Informatics).
In 2011 Bulgaria was ranked #3 in the world by Internet speed (see http://mashable.com/2011/09/21/fastest-download-speeds-infographic).
The world’s leading component vendor for the Microsoft ecosystem is a Bulgarian company called Telerik (www.telerik.com) and almost all of its products are developed in Bulgaria. The world’s leading software product for 3D rendering (V-Ray), used in most Hollywood movies and by most automotive producers, is invented and developed in Bulgaria by another Bulgarian company – Chaos Group (www.chaosgroup.com). A Bulgarian company Datecs designed and produces the barcode scanner with credit card swipe for Apple iPhone / iPad / iPod devices used in all Apple stores. Large international software companies like SAP, VMware, HP, Cisco, Siemens and CSC have large development centers in Sofia with thousands developers.
Bulgarian software engineers can be found in every major software company in the software industry like Microsoft, Google, Oracle, SAP, Facebook, Apple, IBM, Cisco, Siemens, VMware, HP, Adobe, Nokia, Ericsson, Autodesk, etc.
We, the authors, editors and translators of this book are all proud Bulgarian software developers – some living in Bulgaria, others abroad. We are happy to be part of the global software industry and to help beginners over the world to learn computer programming and become skillful software engineers. We are supporters of the culture of free education (like Coursera, edX, Udacity and Khan Academy), free education for everyone and everywhere. We are happy to share our knowledge, skills and expertise and sharing is part of our culture.
Authors and Contributors
This book is written by volunteer developers from Bulgaria who want to share their knowledge and skills about computer programming. They have worked for months (some for years) for free to help the community to learn programming, data structures and algorithms in an easy and efficient way: through this book and the presentations and video tutorials coming with it.
Over 70 people contributed to the project: authors, editors, translators, etc.
The Panel of Authors
The panel of authors of both the old, the new and the translated to English book is indeed the main drivers behind this book’s existence. Writing content of this size and quality is a serious task demanding a lot of time.
The idea of having so many authors participating has been well tested, since a few other books have already been written in a similar manner (e.g. "Programming for the .NET Framework" – parts 1 and 2). Although all chapters from the book are written by different authors, they adhere to the same style and possess the same high quality of content (even though it might differ a little in some chapters). The text is well structured, has many titles and subtitles, contains many appropriate examples, follows a good manner of expression and is uniformly formatted.
The team that wrote this book is made up of people who are strongly interested in programming and would like to voluntarily share their knowledge by participating in writing one or more of the chapters. The best part is that all authors, co-authors and editors in the team working on the book are working programmers with hands-on experience, which means that the reader will receive knowledge, a collection of best practices and advice by people with an active career in the software industry.
The participants in the project made their contribution voluntarily, without material or any other direct compensation, because they supported the idea of writing a good book for novice programmers and because they strongly wanted to help their future colleagues get into programming quickly.
What follows is a brief presentation of the authors of the book "Introduction to Programming with C#" (in an alphabetical order). The original authors of the corresponding chapters from the book "Introduction to Programming with Java" are mentioned accordingly, since their contributions to some chapters are greater than those authors who adapted the text and examples to C# afterwards.
Dilyan Dimitrov
Dilyan Dimitrov is a certified software developer with professional experience in building mid-size and large web-based systems with the .NET Framework. His interests include development of both web and desktop applications using Microsoft’s latest technologies. He graduated from the Sofia University "St. Kliment Ohridski" where he majored in "Informatics" at the Faculty of Mathematics and Informatics. . He can be reached at dimitrov.dilqn@gmail.com or you can visit his personal blog at http://dilyandimitrov.blogspot.com.
Hristo Germanov
Hristo Germanov is a software engineer, whose interests are related mainly to .NET technologies. Architecture and design of web based systems, algorithms and modern standards for quality code are also his passion. He has participated in developing both small and large web-based and desktop-based applications. He likes challenging problems and projects that require strong logical thinking. He graduated from the Omega College in Plovdiv with a degree in "Computer Networks". He specialized for a "Core .NET Developer" at the National Academy for Software Development in Sofia.
You can contact him by e-mail at: hristo.germanov@gmail.com.
Iliyan Murdanliev
Iliyan Murdanliev is a software developer at NearSoft (www.nearsoft.eu). He currently pursues a master’s degree in "Computer Technologies and Applied Programming" at the Technical University of Sofia. He has a bachelor’s degree in "Applied Mathematics" from the same university. He has graduated from an English language high school.
Iliyan has participated in significant projects and in the development of front-end visualization, as well as back-end logic. He has prepared and conducted trainings in C# and other programming languages and technologies. Iliyan’s interests lie in the field of cutting-edge technologies in .NET, Windows Forms and Web-based technologies, design patterns, algorithms and software engineering. He likes out-of-the-box projects that require not only knowledge, but also logical thinking.
His personal blog is available at: http://imurdanliev.wordpress.com. He can be reached by e-mail: i.murdanliev@gmail.com.
Mihail Stoynov
Mihail Stoynov has a master’s degree in "Economics and Management" from the Sofia University "St. Kliment Ohridski". He has obtained his bachelor’s degree in "Informatics" also from Sofia University.
Mihail is a professional software developer, consultant and instructor with many years of experience. For the last few years he is an honorary instructor at the Faculty of Mathematics and Informatics and has delivers lectures in the "Networks Theory", "Programming for the .NET Framework", "Java Web Applications Development", "Design Patterns" and "High Quality Programming Code" courses. He has also been an instructor at New Bulgarian University.
He is an author of a number of articles and publications and a speaker at many conferences and seminars in the field of software technologies and information security. Mihail is a co-author of the books "Programming for the .NET Framework" and "Introduction to Programming with Java". He has participated in Microsoft’s MSDN Academic Alliance and is a lecturer at the Microsoft Academic Days.
Mihail has led IT courses in Bulgaria and abroad. He was a lecturer in the "Java", "Java EE", "SOA" and "Spring Framework" courses at the National Academy for Software Development.
Mihail has worked at the international offices of Siemens, HP and EDS in the Netherlands and Germany, where he has gained a lot of experience in the art of software, as well as in the quality programming, by taking part in the development of large software projects. His interests encompass software architectures and design development, B2B integration of various information systems, business processes optimization and software systems mainly for the Java and .NET platforms. Mihail has participated in dozens of software projects and has extensive experience in web applications and services, distributed systems, relational databases and ORM technologies, as well as management of projects and software development teams.
His personal blog is available at: http://mihail.stoynov.com. His twitter account is available at: https://twitter.com/mihailstoynov.
Mihail Valkov
Mihail Valkov has been a software developer since 2000. Throughout the years, he has faced numerous technologies and software development platforms, some of which are MS .NET, ASP, Delphi. Mihail has been developing software at Telerik (www.telerik.com) ever since 2004. There he co-develops a number of components targeting ASP.NET, Windows Forms, Silverlight and WPF. In the last few years, Mihail has been leading some of the best progressing teams in the company, and currently develops an online Word-like rich text editor.
He can be reached at: m.valkov@gmail.com.
His blog is at: http://blogs.telerik.com/mihailvalkov/. His twitter account is available at: https://twitter.com/mvalkov.
Mira Bivas
Mira Bivas is an enthusiastic young programmer in one of Telerik’s ASP.NET teams (www.telerik.com). She is a student at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski", where she majors in "Applied Mathematics". Mira has completed the "Intro C#" and "Core .NET" courses at the National Academy for Software Development (NASD).
She can be reached by e-mail: mira.bivas@gmail.com.
Nikolay Kostov
Nikolay Kostov works as a senior software developer and trainer at Telerik’s "Technical Training" department (http://academy.telerik.com). He is involved deeply with Telerik Academy’s trainings and the courses organized by Telerik. He currently majors in "Computer Science" at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski".
Nikolay has participated in a number of high school and college student Olympiads and contests in computer science, throughout many years. He is a two-time champion in the project categories "Desktop Applications" and "Web Applications" at the Bulgarian National Olympiad in Information Technologies (NOIT). He has rich experience in designing and developing Web applications, algorithmic programming and processing large amounts of data.
His main interests lie in developing software applications, data structures, everything related to .NET technologies, web applications security, data processing automation, web crawlers, single page applications and others.
Nikolay’s personal blog can be found at: http://nikolay.it.
Nikolay Nedyalkov
Nikolay Nedyalkov is the chairman of The Association for Information Security, technical director of the eBG.bg’s electronic payments and services portal and business consultant at other companies. Nikolay is a professional software developer, consultant and instructor with many years of experience. He has authored a number of articles and publications and has lectured at many conferences and seminars in the field of software technologies and infor¬ma¬tion security. His experience as an instructor ranges from assisting in "Data Structures in Programming", "Object-oriented Programming with C++" and "Visual C++" to lecturing at the "Network Security", "Secure Code", "Web Development with Java", "Creating High Quality Code", "Programming for the .NET platform" and "Applications Development with Java" courses. Nikolay’s interests are focused on creating and managing information and communications solutions, modeling and managing business processes in large-size organizations and state administration. Nikolay has a bachelor’s and a master’s degree from the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski". As a high school student he was a programming contestant throughout many years and received a number of accolades.
His personal website is located at: http://www.nedyalkov.com.
Nikolay Vasilev
Nikolay Vasilev is a professional software developer, an instructor and a participant in many open source projects.
He holds a master’s degree in "Software Engineering and Artificial Intelligence" from University of Malaga (Spain) and is currently pursuing a master’s degree in "Mathematical Physics Equations and Their Applications" at Sofia University (Bulgaria). He obtained his bachelor’s degree in "Mathematics and Informatics" from Sofia University.
In the period 2002-2005, he was instructor in the classes of "Introduction in Programming with Java" and "Data Structures and Programming with Java" at Sofia University.
Nikolay is a co-author of the books "Introduction in Programming with Java" and "Introduction in Programming with C#" and also one of the initiators, organizers and co-authors of a project for creating an open source book in Bulgarian, dedicated to the classical (GoF) design patterns in the software engineering. He is one of the organizers and lecturers of the "Bulgarian Java User Group".
Nikolay is a certified software developer with nearly 10 years of expertise in development of Java enterprise applications, gained in international companies. He participated in large-size systems development from various domains like e-commerce, banking, visual simulators for nuclear plant sub-systems, VOD systems, etc.; using cutting-edge technologies and applying the best up-to-date design and development methodologies and practices. His interests span across various areas such as software engineering and artificial intelligence, fluid mechanics, project management and scientific research.
Nikolay Vasilev’s personal blog is available at http://blog.nvasilev.com.
Pavel Donchev
Pavel Donchev is a programmer at Telerik (www.telerik.com), where he develops web applications mostly for the company internal purposes. He takes extramural courses in "Theoretical Physics" at the Sofia University "St. Kliment Ohridski". He was engaged in developing Desktop and Web Applications for various business sectors – mortgage credits, online stores, automation and Web UML diagrams. His interests lie mainly in the sphere of process automation using Microsoft technologies.
His personal blog is located at: http://donchevp.blogspot.com.
Pavlina Hadjieva
Pavlina Hadjieva is a senior enterprise support officer and team lead at Telerik (www.telerik.com). She currently pursues a master’s degree in "Distributed Systems and Mobile Technologies" at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski". She obtained her bachelor’s degree in "Chemistry and Computer Science" also from Sofia University.
Her professional interests are oriented towards web technologies, in particular ASP.NET, as well as the complete development cycle of .NET Framework applications.
You can contact Pavlina Hadjieva by e-mail: pavlina.hadjieva@gmail.com.
Radoslav Ivanov
Radoslav Ivanov is an experienced software engineer, consultant and trainer with several years of professional experience in wide range of technologies and programming languages. He has solid practical and theoretical background in computer science and excellent writing and lecturing skills.
Radoslav has a bachelor’s degree in "Informatics" and master’s degrees in "Software Engineering" and "E-learning" from the Sofia University "St. Kliment Ohridski". For several years he has been an honorary instructor at the Faculty of Mathematics and Informatics where he was teaching courses in "Design Patterns in C#", "Programming for the .NET Framework", "Java Web Applications Development" and "Java EE Development".
He is a co-author of the books "Programming for the .NET Framework" and "Introduction to Programming with Java".
His professional interests include data warehousing, security, cloud computing, Java technologies, the .NET platform, software architecture and design and project management.
Radoslav’s twitter account is available at: https://twitter.com/radoslavi.
Radoslav Kirilov
Radoslav Kirilov is a senior software developer and team leader at Telerik (www.telerik.com). He graduated from the Technical University of Sofia with a major in "Computer Systems and Technologies". . His professional interests are oriented towards web technologies, particularly ASP.NET, and the complete development cycle of .NET Framework-based applications. Radoslav is an experienced lecturer who has taken part in putting through, as well as creating study materials (presentations, examples, exercises) for the National Academy for Software Development (NASD). Radoslav is a member of the instructors' team of the "High Quality Programming Code" course that started in 2010 at the Technical University of Sofia and at the Sofia University "St. Kliment Ohridski".
He has been maintaining a tech blog since 2009 located at: radoslavkirilov.blogspot.com. You can contact Radoslav by e-mail at: radoslav.pkirilov@gmail.com.
Radoslav Todorov
Radoslav Todorov is a software developer who obtained his bachelor’s degree from the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski" (www.fmi.uni-sofia.bg). He received his master’s degree in the field of computer science from the Technical University of Denmark in Lyngby, Denmark (http://www.dtu.dk).
Radoslav has been conducting courses as an instructor-assistant at the IT University of Copenhagen in Denmark (http://www.itu.dk) and participating in the research activity of university projects ever since he received his masters’ education. He has rich experience in designing, developing and maintaining large software products for various companies. He gained working experience at several companies in Bulgaria. At present, he works as a software engineer for Canon Handy Terminal Solutions Europe in Denmark (www.canon-europe.com/Handy_
Terminal_Solutions).
Radoslav’s interests are oriented towards software technologies for high-level programming languages, as well as products integrating complete hardware and software solutions in the industrial and private sectors.
You can contact Radoslav by e-mail: radoslav_todorov@hotmail.com.
Stanislav Zlatinov
Stanislav Zlatinov is a software developer with professional experience in web and desktop applications development based on the .NET and Java platforms.
He has a master’s degree in "Computer Multimedia" from the "St. Cyril and St. Methodius" University of Veliko Tarnovo.
His personal blog is located at: http://encryptedshadow.blogspot.com.
Stefan Staev
Stefan Staev is a software developer who is occupied with building web based systems using the .NET platform. His professional interests are related to the latest .NET technologies, design patterns and databases. He is a member of the authors' team of the book "Introduction to Programming with Java".
Stefan currently majors in "Informatics" at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski". He is a "Core .NET Developer" graduate from the National Academy for Software Development.
You can contact him by e-mail: stefosv@gmail.com. His Twitter micro blog is located at: http://twitter.com/stefanstaev.
Svetlin Nakov
Svetlin Nakov is the head of the "Technical Training" department at Telerik Corp. where he manages the project for free training of software engineers Telerik Software Academy (http://academy.telerik.com) as well as all other connected courses and training initiatives, such as Telerik School Academy, Telerik Algo Academy, Telerik Kids Academy. He is the founder of the Software University open-education project (http://softuni.org).
He has achieved a bachelor’s degree in "Computer Science" and a master’s degree in "Distributed Systems and Mobile Technologies" at the Sofia University "St. Kliment Ohridski". Later he obtained a Ph.D. in "Computer Science" after defending a thesis in the field of "Computational Linguistics" before the Higher Attestation Commission of the Bulgarian Academy of Sciences (BAS).
His interests encompass software architectures development, the .NET platform, web applications, databases, Java technologies, training software specialists, information security, technological entrepreneurship and managing software development projects and teams.
Svetlin Nakov has nearly 20 years of experience as a software engineer, programmer, instructor and consultant, moving from Assembler, Basic and Pascal through C and C++ to PHP, JavaScript, Java and C#. He was involved as a software engineer, consultant and manager of teams in dozens of projects for developing information systems, web applications, database management systems, business applications, ERP systems, cryptographic modules and trainings of software engineers. At the age of 24, he founded his first software company for training software engineers, which was acquired 5 years later by Telerik.
Svetlin has extensive experience in creating study materials, preparing and conducting trainings in programming and modern software technologies, gathered during his practice as an instructor. For many years now, he has been an honored instructor at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski" (FMI at SU), at the New Bulgarian University (NBU) and at the Technical University of Sofia (TU-Sofia), where he held courses in "Design and Analysis of Computer Algorithms", "Internet and Web Programming with Java", "Network Security", "Programming for the .NET Framework", "Developing Java Web Applications", "Design Patterns", "High Quality Programming Code", "Developing Web Applications with the .NET Framework and ASP.NET", "Developing Java and Java EE Applications", "Web Front-End Development" and many others (see http://www.nakov.com/courses/).
Svetlin has dozens of scientific and technical articles focused on software development in both Bulgarian and foreign publications and is the lead author of the books "Programming for the .NET Framework (vol. 1 & 2)", "Introduction to Programming with Java", "Introduction to Programming with C#", "Internet Development with Java" and "Java for Digitally Signing Web Documents". He is a regular speaker at technical conferences, trainings and seminars and up to now has held hundreds of technical lectures at various technological events in Bulgaria and abroad.
As a high school and a college student, Svetlin was champion in tens of national contests in programming and was awarded with 4 medals at International Olympiads in Informatics (IOI).
In 2003, he received the "John Atanasoff" award by the EVRIKA Foundation. In 2004, he was awarded by the Bulgarian President with the "John Atanasoff" award for his contribution to the development of the information technologies and the information society.
He is one of the founders of the Bulgarian Association of Software Developers (www.devbg.org) and its present chairman.
Apart from computer programming, Svetlin Nakov is founder of NLP Club Bulgaria (http://nlpclub.devbg.org), a community of NLP (neuro-linguistic programming) practitioners and successful people who are looking for personal development and knowledge sharing. The goal for Svetlin is to add soft skills and personal development to his students at the Software academy in addition to the profession and job positions they gain.
The personal website and blog of Svetlin Nakov is: http://www.nakov.com. His story of life is published at http://www.nakov.com/blog/2011/09/24/.
Teodor Bozhikov
Teodor Bozhikov is a senior software developer and team leader at Telerik (www.telerik.com). He completed his master’s degree in "Computer Systems and Technologies" at the Technical University of Varna. Besides his background as a WPF and Silverlight programmer, he has achieved expertise in developing ASP.NET web applications. He was involved briefly in the development of private websites. Within the ICenters project, he took part in building and maintaining of a local area network for public use at the Festival and Congressional Center in Varna. He has held courses in computer literacy and computer networks basics.
Teodor’s professional interests include web and desktop application development technologies, architecture and design patterns, networks and all kinds of new technologies.
You can contact Teodor by e-mail: t_bozhikov@yahoo.com. His Twitter micro blog is located at: http://twitter.com/tbozhikov.
Teodor Stoev
Teodor Stoev has a bachelor’s and a master’s degree in "Informatics" from the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski". At Sofia University, he mastered in "Software Technologies". He currently attends a master’s program in "Computer Science" at the Saarland University (Saarbrucken, Germany).
Teodor is a software designer and developer with many years’ experience. He has participated in creating financial and insurance software systems, a number of web applications and corporate websites. He was actively involved in the development of the TENCompetence project of the European Commission. He is a co-author of the book "Introduction to Programming with Java".
His professional interests lie in the field of object-oriented analysis, modeling and building of software applications, web technologies and, in particular, building rich internet applications (RIA). He has an extensive background in algorithmic programming: he has competed at a number of national high school and collegiate computer science contests.
His personal website is available at: http://www.teodorstoev.com.
You can contact Teodor by e-mail: teodor.stoev@gmail.com.
Tsvyatko Konov
Tsvyatko Konov is a senior software developer and instructor with varied interests and experience. He is competent in fields such as systems integration, building software architectures, developing systems with a number of technologies, such as .NET Framework, ASP.NET, Silverlight, WPF, WCF, RIA, MS SQL Server, Oracle, MySQL, PostgreSQL and PHP. His experience as an instructor includes a large variety of courses – courses for beginners and experts in .NET technologies, as well as specialized courses in individual technologies, such as ASP.NET, Oracle, .NET Compact Framework, "High Quality Programming Code" and others. Tsvyatko was part of the authors’ team of the book "Introduction to Programming with Java". His professional interests include web-based and desktop-based technologies, client-oriented web technologies, databases and design patterns.
Tsvyatko Konov has a technical blog: http://www.konov.me.
Veselin Georgiev
Veselin Georgiev is a co-founder of Lead IT (www.leadittraining.com) and software developer at Abilitics (www.abilitics.com). He has a master’s degree in "E-Business and E-Governance" at the Sofia University "St. Kliment Ohridski", after obtaining a bachelor’s degree in "Informatics" from the same university.
Veselin is a Microsoft Certified Trainer and Microsoft Certified Professional Developer. He lectured at the Microsoft Tech Days conferences in 2011 and 2009, and also takes part as an instructor in various courses at Sofia University. He is an experienced lecturer who has trained software specialists for working practical jobs in the IT industry.
His professional interests are oriented towards training, SharePoint and software architectures. He can be reached at veselin.vgeorgiev@gmail.com.
Veselin Kolev
Veselin "Vesko" Kolev is a leading software engineer with many years’ professional experience. He has worked at various companies where he managed teams and the development of many different software projects. As a high school student, he participated in a number of competitions in the fields of mathematics, computer science and information technology, where he finished in prestigious places. He currently majors in "Computer Science" at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski".
Vesko is an experienced lecturer who has worked on training software specialists for practical jobs in the IT industry. He is an instructor at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski" where he conducts courses in "Modern Java Technologies" and "High Quality Programming Code". He has delivered similar lectures at the Technical University of Sofia.
Vesko’s main interests include software projects design, development of software systems, .NET and Java technologies, Win32 programming (C/C++), software architectures, design patterns, algorithms, databases, team and software projects management, specialists training. The projects he has worked on include large web based systems, mobile applications, OCR, automated translation systems, economic software and many others. Vesko is a co-author of the book "Introduction to Programming with Java".
Vesko works on the development of Silverlight and WPF based applications at Telerik (www.telerik.com). He shares parts of his day-to-day experiences online on his personal blog at http://veskokolev.blogspot.com.
Yordan Pavlov
Yordan Pavlov has a bachelor’s and a master’s degree in "Computer Systems and Technologies" from the Technical University of Sofia. He is a software developer at Telerik (www.telerik.com) with an extensive background in software components development.
His interests lie mainly in the following fields: object-oriented design, design patterns, high-quality software development, geographic information systems (GIS), parallel processing and high performance computing, artificial intelligence, teams’ management.
Yordan won the Imagine Cup 2008 finals in Bulgaria in the Software Design category, as well as the world finals in Paris, where he won Microsoft’s prestigious "The Engineering Excellence Achievement Award". He has worked with Microsoft engineers at the company headquarters in Redmond, USA, where he has gathered useful knowledge and experience in the development of complex software systems.
Yordan has also received a golden mark for "Contributions to the Innovation and Information Youth Society". He has taken part in many contests and Olympiads in programming and informatics.
Yordan’s personal blog can be found at http://yordanpavlov.blogspot.com. He can be reached by e-mail: iordanpavlov@gmail.com.
Yosif Yosifov
Yosif Yosifov is a senior software developer at Telerik (www.telerik.com). His interests consist mainly of .NET technologies, design patterns and computer algorithms. He has participated in numerous contests and Olympiads in programming and informatics. He currently pursues a bachelor’s degree in "Computer Science" at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski".
Yosif’s personal blog can be found at http://yyosifov.blogspot.com. He can be reached by e-mail: cypressx@gmail.com.
The Java Book Authors
This C# fundamentals programming book is based on its original Java version, the book "Introduction to Programming with Java". Thanks to the original Java book authors for their work. They have significant contribution to almost all chapters of the book. Some chapters are entirely based on their work, some partially, but in all cases their original work is the primary origin of this book:
 
	Boris Valkov
	Danail Aleksiev
	Hristo Todorov
	Lachezar Bozhkov
	Luchesar Cekov
	Marin Georgiev
	Mario Peshev
	Mariyan Nenchev
	Mihail Stoynov
	Nikolay Nedyalkov
	Nikolay Vasilev
	Petar Velev
	Radoslav Ivanov
	Rumyana Topalska
	Stefan Staev
	Svetlin Nakov
	Teodor Stoev
	Vesselin Kolev
	Vladimir Tsanev
	Yosif Yosifov
 
The Editors
Apart from the authors, a significant contribution to the making of this book was made by the editors who voluntarily took part in reviewing the text and the examples and fixing errors and other problems:
 
	Dilyan Dimitrov
	Doncho Minkov
	Hristo Radkov
	Iliyan Murdanliev
	Marin Georgiev
	Mihail Stoynov
	Mihail Valkov
	Mira Bivas
	Nikolay Kostov
	Nikolay Vasilev
	Pavel Donchev
	Radoslav Ivanov
	Radoslav Kirilov
	Radoslav Todorov
	Stanislav Zlatinov
	Stefan Staev
	Svetlin Nakov
	Teodor Bozhikov
	Tsvyatko Konov
	Veselin Georgiev
	Veselin Kolev
	Yosif Yosifov
 
The Translators
This book would have remained only in Bulgarian for many years if these guys hadn’t volunteered to translate it in English:
 
	Angel Angelov
	Atanas Valchev
	Blagovest Buyukliev
	Boyan Dimitrov
	Dimitar Bonev
	Doroteya Agayna
	Dyanko Petkov
	Franz Fischbach
	George Halachev
	George K. Georgiev
	George S. Georgiev
	Georgi Mitev
	Georgi Todorov
	Georgi Vaklinov
	Hristo Radkov
	Ivan Nenchovski
	Ivaylo Dyankov
	Ivaylo Gergov
	Zhasmina Stoyanova
	Kristian Dimitrov
	Lora Borisova
	Martin Gebov
	Martin Radev
	Martin Yankov
	Momchil Rogelov
	Nedjaty Mehmed
	Nencho Nenchev
	Nikolay Angelov
	Nikolay Kostov
	Pavel Benov
	Radoslav Todorov
	Stanislav Vladimirov
	Svetlin Nakov
	Teodor Rusev
	Tihomir Iliev
	Todor Mitev
	Vasya Stankova
	Ventsi Shterev
	Vesselin Georgiev
	Vesselina Raikova
	Vladimir Amiorkov
	Vladimir Tsenev
	Yoan Krumov
	Zhelyazko Dimitrov 
Many thanks to George S. Georgiev who was seriously involved in the translation process and edited the translated text for most of the chapters.
Other Contributors
The authors would also like to thank Kristina Nikolova for her efforts in working out the book’s cover design. Big thanks to Viktor Ivanov and Peter Nikov for their work on the project’s web site. Big thanks to Ivaylo Kenov for fixing few hundreds bugs reported in the Bulgarian edition of the book. Thanks to Ina Dobrilova and Aneliya Stoyanova for the proofreading of the first few chapters and their contribution to the marketing of the book. Many thanks to Hristo Radkov who is proficient in English (lives and works in London for many years) and who edited and corrected the translation of the first few chapters.
The Book Is Free of Charge!
The present book is distributed absolutely free of charge in an electronic format under a license that grants its usage for all kinds of purposes, including commercial projects. The book is also distributed in paper format for a charge, covering its printing and distribution costs without any profit.
Reviews
If you don’t fully trust the authors who wrote this book, you can take inspiration from its reviews written by leading worldwide specialists, including software engineers at Microsoft, Google, Oracle, SAP and VMware.
Review by Nikola Mihaylov, Microsoft
Programming is an awesome thing! People have been trying for hundreds of years to make their lives easier, in order to work less. Programming allows humanity’s tendency towards laziness to continue. If you are a computer freak or if you’d just like to impress others with a good website or something of yours "never-seen -before", then you are welcome. No matter if you are part of the relatively small group of "freaks" who get off on encountering a nice program or if you’d just like to fulfill yourself professionally and lead your life outside the workplace, this book is for you.
The fundamental concepts of a car’s engine haven’t changed in years – something inside it burns (gas, oil or whatever you have filled it with) and the car rolls along. Likewise, the concepts of programming haven’t changed for years. Whether you write the next video game, money management software in a bank or you program the "mind" of a new bio robot, you will use – with absolute certainty – the concepts and the data structures described in this book.
In this book, you will find a large part of the programming fundamentals. An analogical fundamental book in the automobile industry would be titled "Internal Combustion Engines".
Whatever you do, it’s most important to enjoy it! Before you start reading this book, think of something you’d like to do as a programmer – a website, a game or some other program! While reading the book, think of how and what from the stuff you have read you would use in your program! If you find something interesting, you would learn it easily!
My first program (of which I’m proud enough to speak of in public) was simply drawing on the screen using the arrow keys of the keyboard. It took me quite some time to write it back then, but when it was done, I liked it. I wish you this: may you like everything related to programming! Have a nice reading and a successful professional fulfillment!
Nikola Mihaylov is a software engineer at Microsoft in the team developing Visual Studio. He is the author of the website http://nokola.com and is easily "turned on" by the topic of programming; he is always ready when it’s necessary to write something positive! He loves helping people with questions and a desire for programming, no matter if they are beginners or experts. When in need, contact him by e-mail: nokola@nokola.com.
Review by Vassil Bakalov, Microsoft
"Introduction to Programming with C#" is a brave effort to not only help the reader make their first steps in programming, but also to introduce them with the programming environment and to train for the practical tasks that occur in a programmer’s day-to-day life. The authors have found a good combination of theory – to pass over the necessary knowledge for writing and reading programming code – and practice – all kinds of problems, carefully selected to assimilate the knowledge and to form a habit in the reader to always think of the efficient solution to the problem in addition to the syntax when writing programs.
The C# programming language is a good choice, because it is an elegant language through which the program’s representation in the computer memory is of no concern to us and we can concentrate on improving the efficiency and elegance of our program.
Up until now I haven’t come across a programming book that introduces its reader with the programming language and develops their problem solving skills at the same time. I’m happy now that there is such a book and I’m sure it will be of great use to future programmers.
Vassil Bakalov is a software engineer at Microsoft Corporation (Redmond) and a participant in the project for the first Bulgarian book for .NET: "Programming for the .NET Framework". His blog is located at: http://bakalov.com.
Review by Vassil Terziev, Telerik
Skimming through the book, I remembered the time, when I was making my first steps in PHP programming. I still remember the book I learned from – four authors, very disorganized and incoherent content and elementary examples in the chapters for experts and complicated examples in the chapters for beginners, different coding conventions and emphasis only on the platform and the language and not on how to use them efficiently for writing high quality applications.
I’m very glad that "Introduction to Programming with C#" takes an entirely different approach. Everything is explained in an easy to understand manner, but with the necessary profundity, and every chapter goes on to slowly extend the previous ones. As an outside bystander I was a witness of the efforts put into writing the book and I’m happy that this immense energy and desire to create a more different book truly has materialized in a subject matter of very high quality.
I strongly hope that this book will be useful to its readers and that it will provide them with a strong basis for finding their feet, a basis that will hook them on to a professional development in the field of computer programming and that will help them make a more painless and qualitative start.
Vassil Terziev is one of the founders and CEO of Telerik Corporation, leading provider of developer tools and components for .NET, HTML5 and mobile development. His blog is located at http://blogs.telerik.com/vassilterziev/. You can contact him at any time you want by e-mail: terziev@telerik.com.
Review by Veselin Raychev, Google
Perhaps even without reading this, you’ll be able to work as a software developer, but I think you’ll find it much more difficult.
I have seen cases of reinventing the wheel, often times in a worse shape than the best in theory and the entire team suffers mostly from this. Everybody committed to programming must sooner or later read what algorithm complexity is, what a hash table is, what binary search is and what the best practices for using design patterns are. Why don’t you start at this very moment by reading this book?
There are many books on C# and much more on programming. People would say about many of them that they are the best guides, the fastest way to get into the swing of the language. This book differs from others mainly because it will show you what you must know to achieve success and not what the twists and turns of a given programming language are. If you find the topics covered in this book uninteresting, then software engineering might possibly not be for you.
Veselin Raychev is a software engineer at Google where he works on Google Maps and Google Translate. He has previously worked at Motorola Biometrics and Metalife AG.
Veselin has won accolades at a number of national and international contests and received a bronze medal at the International Olympiad in Informatics (IOI) in South Korea, 2002, and a silver medal at the Balkan Olympiad in Informatics (BOI). He represented the Sofia University "St. Kliment Ohridski" twice at the world finals in computer science (ACM ICPC) and taught at several optional courses at the Faculty of Mathematics and Informatics at the University of Sofia.
Review by Vassil Popovski, VMware
As an employee at a managing position at VMware and at Sciant before that, I often have to carry out technical interviews for job candidates at our company. It’s surprising how many of the candidates for software engineering positions that come to us for an interview don’t know how a hash table works, haven’t heard of algorithm complexity, cannot sort an array or sort it with a complexity of O(n3). It’s hard to believe the amount of self-taught programmers that haven’t mastered the fundamentals of programming you’ll find in this book. Many people practicing the software developer profession are not even familiar with the most basic data structures in programming and don’t know how to iterate through a tree using recursion. Read this book, so that you won’t be like these people! It is the first textbook you should start with during your training as a programmer. The fundamental knowledge of data structures, algorithms and problem solving will be necessary for you to build your carrier in software engineering successfully and, of course, to be successful at job interviews and the workplace afterwards.
If you start with creating dynamic websites using databases and AJAX without knowing what a linked list, tree or hash table is, one day you’ll find out what fundamental gaps there are in your skill set. Do you have to make a fool of yourself at a job interview, in front of your colleagues or in front of your superior when it becomes clear that you don’t know the purpose of a hash code, or how the List<T> structure works or how hard drive folders are traversed recursively?
Most programming books will teach you to write simple programs, but they won’t take into consideration the quality of the programming code. It is a topic most authors find unimportant, but writing high quality code is a basic skill that separates the capable programmers from the mediocre ones. Throughout the years you might discover the best practices yourself, but do you have to learn by trial and error? This book will show you the right course of action the easy way – master the basic data structures and algorithms; learn to think correctly; and write your code with high-quality. I wish you beneficial studying.
Vassil Popovski is a software architect at VMware Bulgaria with more than 10 years of experience as a Java developer. At VMware Bulgaria he works on developing scalable Enterprise Java systems. He has previously worked as senior manager at VMware Bulgaria, as technical director at Sciant and as team leader at SAP Labs Bulgaria.
As a high school student Vassil won awards at a number of national and international contests including a bronze medal at the International Olympiad in Informatics (IOI) in Setubal, 1998, and a bronze medal at the Balkan Olympiad in Informatics (BOI) in Drama, Greece, 1997. As a college student, Vassil participated in a number of college contests and in the worldwide interuniversity contest in programming (ACM ICPC). During the 2001/2002 period, he held the course "Transaction Processing" at the Sofia University "St. Kliment Ohridski". Vassil is one of the founders of the Bulgarian Association of Software Developers (BASD).
Review by Pavlin Dobrev, ProSyst Labs
The book "Introduction to Programming with C#" is an excellent study material for beginners that gives you the opportunity to master the fundamentals of programming in an easy to understand manner. It’s the seventh book written under the guidance of Svetlin Nakov and just like the others, it’s oriented exclusively to gaining practical programming skills. The subject matter includes fundamental topics such as data structures, algorithms and problem solving and that makes it intransient in technologies’ development. It’s filled with countless examples and practical advice for solving basic problems from a programmer’s everyday work.
The book "Introduction to Programming with C#" represents an adaptation of the incredibly successful book "Introduction to Programming with Java" to the C# programming language and Microsoft’s .NET Framework platform and is based on its leading author’s, Svetlin Nakov, experience gained while teaching programming fundamentals – not only at the National Academy for Software Development (NASD) and later at Telerik Software Academy, but at the Faculty of Mathematics and Informatics at the Sofia University "St. Kliment Ohridski", at the New Bulgarian University and at the Technical University of Sofia as well.
Despite the large number of authors, all of which with differing professional and training experience, there is a clear logical connection between the separate chapters from the book. It’s clearly written, with detailed explanations and many, many examples far from the dull academic style of most university textbooks.
Oriented towards those making their first steps in programming, the book delivers carefully, step by step, the most important stuff a programmer must be proficient in, in order to practice his profession – starting from variables, loops and arrays, to fundamental data structures and algorithms. The book also covers important topics like recursive algorithms, trees, graphs and hash tables. It’s one of the few books that teach a good programming style and high-quality programming code at the same time. There is enough thought put into the object-oriented programming principles and exceptions handling, without which modern software development is unimaginable.
The book "Introduction to Programming with C#" teaches the most important principles and concepts in programming in the way programmers think when solving problems in their everyday work.
This book doesn’t contain everything about programming and won’t make you .NET software engineers. If you want to become really good programmer, you need lots and lots of practice. Start from the exercises at the end of each chapter, but don’t confine yourselves to solving only them. You’ll write thousands of lines of code until you become really good – that’s the life of a programmer. This book is indeed a great start! Seize the opportunity to come across everything of utmost importance in one place without all the wandering through the thousands of self-instruction books and articles on the Internet. Good luck!
Dr. Pavlin Dobrev is technical director at ProSyst Labs (www.prosyst.com), a software engineer with more than 15 years’ experience, consultant and scientist, Ph.D. in "Computer Systems, Complexes and Networks". Pavlin has made worldwide contributions in developing modern computer technologies and technological standards. He is an active member of international standardization organizations such as the OSGi Alliance (www.osgi.org) and the Java Community Process (www.jcp.org), as well as open source software initiatives such as the Eclipse Foundation (www.eclipse.org). Pavlin manages software projects and consults companies of the likes of Miele, Philips, Siemens, BMW, Bosch, Cisco Systems, France Telecom, Renault, Telefonica, Telekom Austria, Toshiba, HP, Motorola, Ford, SAP, etc. in the field of embedded applications, OSGi based automobile systems, mobile devices and home networks, integrated development environments and Java Enterprise servers for applications. He has many scientific and technical publications and has participated in prestigious international conferences.
Review by Nikolay Manchev, Oracle
To become a skillful software developer, you must be ready to invest in gaining knowledge in many fields and a particular programming language is only one of them. A good developer mustn’t only know the syntax and the application programming interface of the language he’s chosen. He also has to possess deep knowledge in object-oriented programming, data structures and quality code writing. He must also back up his knowledge with serious practical experience.
When I was starting my career as a software developer more than 15 years ago, finding a comprehensive source for learning these things was impossible. Yes, there were books on the individual programming languages, but they only described their syntax. For the API description one had to rely on the documentation of the libraries. There were individual books devoted solely on object-oriented programming. The various algorithms and data structures were taught at the university. There was not even a word on high-quality programming code.
Learning all these things, one piece at a time, and making the efforts to put them into a common context, was up to the one walking "the way of the programmer". Sometimes a self-taught programmer cannot manage to fill the huge gaps in their knowledge simply because they have no idea of the gaps’ existence. Let me give you an example to illustrate the problem.
In the year 2000 I picked up the management of a large Java project. The team developing it consisted of 25 people and at that moment there were about 4000 classes written for the project. As a team leader, part of my job was to regularly review the code written by the other programmers. One day I saw how one of my colleagues had solved a standard array sorting assignment. He had written a separate, 25 lines long method implementing the trivial bubble sort algorithm. When I went to see him and asked him why he would do that instead of solving the problem with a single line of code using Array.Sort(), he started explaining how the built-in method had been "sluggish" and that it’s better to write these things yourself. I told him to open the documentation and showed him that the "sluggish" method works with a complexity of O(n*log(n)) and his bubble sort is a prime example of bad performance with its complexity of O(n2). In the next few minutes of our conversation I made the actual discovery – my colleague had no idea what algorithm complexity is and his knowledge of standard algorithms was tragic. Consequently I found out he majored in an entirely different engineering discipline, not computer science. Of course, there’s nothing wrong with that. His knowledge of Java was no worse than his co-workers’, who had longer professional exposures than him. But that very day we noticed a gap in his professional qualification as a developer that he hadn’t even suspected.
I don’t want to leave you with wrong impressions from this story. Although a college student who has successfully passed his main exams in "Informatics" would definitely know the common sorting algorithms and would be able to calculate their complexity, they would also have gaps in their education. The sad truth is that the college education in Bulgaria in this discipline is still theoretically oriented. It has changed very little over the course of the past 15 years. Yes, programs are nowadays written in Java and C#, but these are the same programs that were written in Pascal and Ada back then.
Somewhere about a year ago I consulted a freshman student who was majoring in "Informatics" at one of Bulgaria’s top state universities. When we sat down to go over his notes taken during the "Introduction to Programming" class, I was amazed at the code his instructor had given. The names of the methods were a mix of English and transliterated Bulgarian. There was a method calculate and a method rezultat (the Bulgarian for "result"). The variables carried the descriptive names a1, a2 and suma (the Bulgarian for "sum"). Yes, there is nothing tragic in this approach, as long as it’s a ten-lines-long example, but when this student takes up the job he’s earned at some large project, he will be harshly rebuked by the project leader, who will have to explain to him the coding conventions, naming principle, cohesion and coupling and variable life span. Then they’ll find out together about the gap in his knowledge of quality code the same way my colleague and I found out about his uncertain knowledge in the field of algorithms.
Dear reader, I can boldly state that you are holding a truly unique book in your hands. Its contents are very carefully selected. It’s well-arranged and presented with attention to details, of which only people with tremendous practical experience and solid scientific knowledge, like the book’s chief authors Svetlin Nakov and Veselin Kolev, are capable of. Over the course of many years they have also been learning "on the fly", supplementing and expanding their knowledge. They’ve worked for years on huge projects, they’ve attended many scientific conferences and they’ve taught hundreds of students. They know what’s necessary for anybody striving for a career in software development to learn and they’ve presented it in a manner that no other book on introduction to programming has done before. Your journey through the book’s pages will lead you through the C# programming language’s syntax. You’ll see how to use a large part of its API. You’ll learn the fundamentals of object-oriented programming and you’ll be able to work freely with terms such as objects, events and exceptions. You’ll see the most widely used data structures such as arrays, trees, hash tables and graphs. You’ll get to know the most widely used algorithms for working with these structures and you’ll come to know their pros and cons. You’ll understand the concepts for creating high-quality programming code and you’ll know what to require from your programmers when one day you become a team leader. In addition, the book will challenge you with many practical problems that will help you master, by the way of practice, the subject matter it covers. And if one of the problems proves too hard for you, you can always take a look at the solutions and guidelines the authors have provided.
Computer programmers make mistakes – no one is safe from that. The more capable ones make mistakes out of oversight or overwork, but the more incompetent ones – out of lack of knowledge. Whether you become a good or a bad software developer depends entirely on you and especially on how much you’re willing to constantly invest in your knowledge – be it by attending courses, reading or practicing. But I can tell you one thing for sure – no matter how much time you invest in this book, you won’t make a mistake. If some years ago someone wanting to become a software developer had asked me "Where do I start from", I wouldn’t have been able to give them a definitive answer. Today I can say without worry – "Start from this very book (in its C# or Java version)!"
I wish you with all my heart success in mastering the secrets of C#, the .NET Framework and software development!
Nikolay Manchev is a consultant and software developer with many years of experience in Java Enterprise and Service Oriented Architecture (SOA). He has worked for BEA Systems and Oracle Corporation. He’s a certified developer in the programs run by Sun, BEA and Oracle. He teaches software technologies and holds courses in "Network Programming", "J2EE", "Data Compression" and "High Quality Programming Code" at the Plovdiv University "Paisii Hilendarski" and at the Sofia University "St. Kliment Ohridski". He has held a number of courses for developers on Oracle technologies in Central and Eastern Europe (Hungary, Greece, Slovakia, Slovenia, Croatia and others) and has participated in international projects on incorporating J2EE based systems for security management. Works of his in the field of data compression algorithms have been accepted and presented in the USA by IEEE. Nikolay is an honorary member of the Bulgarian Association of Software Developers (BASD). He is author of the book "Oracle Database Security: Version 10g & 11g". You can find out more about him on his personal website: http://www.manchev.org. To contact him, use the e-mail address: nick@manchev.org.
Review by Panayot Dobrikov, SAP AG
The book at hand is an incredibly good introduction to programming for beginners and is a primary example of the notion (promoted by Wikipedia and others) to create and distribute easy to understand knowledge that is not only *free of charge*, but is of incredibly high quality as well.
Panayot Dobrikov is program director at SAP AG and co-author of the book "Programming = ++Algorithms;". You can find out more about him on his personal website: http://indyana.hit.bg.
Review by Lyubomir Ivanov, Mobiltel
If someone had told me 5 or 10 years ago that there would be a book from which to learn the basics of managing people and projects – budgeting, finances, psychology, planning, etc., I wouldn’t have believed them. I wouldn’t even believe them at this very moment. For each of these topics there are tens of books that must be read.
If someone had told me that there would be a book from which we can learn the fundamentals of programming essential to every software developer – I still wouldn’t have believed them.
I remember my time as a novice programmer and a college student – I was reading several books on programming languages, several others on algorithms and data structures, and a third set of books on writing high-quality code. Very few of them helped me to think algorithmically and to work out an approach for solving the everyday problems I came across in my practice. None of them gave me an overview of everything I had to know as a computer programmer and a software engineer. The only things that helped me were being stubborn and reinventing the wheel.
Today I read this book and I’m happy that finally, although a bit too late for me, someone got down to writing The Book that will help any beginner programmer solve the puzzle of programming – a modern programming language, data structures, quality code, algorithmic thinking and problem solving. This is the book that you should take up programming from, if you want to master the art of quality programming. Whether you choose the Java or C# version of this book, it doesn’t really matter. What matters is that you must learn to think as a programmer and solve the problems you encounter when writing software; the programming language is just a tool you can change for another at any given time.
This book isn’t only for beginners. Even programmers with many years of experience can learn something from it. I recommend it to every software developer who would like to realize what they didn’t know up until now.
Have a nice time reading!
Lyubomir Ivanov is the manager of the "Data and Mobile Applications" department at Mobiltel EAD (part of Mobilkom Austria) where he engages in developing and integrating IT solutions for the telecommunications industry.
Review by Hristo Deshev, Entrepreneur
It’s surprising what a large percentage of programmers don’t pay attention to the little things like variable names and good code structure. These things pile up and, in the end, make the difference between a well-written piece of software and a bowl of spaghetti. This book teaches discipline and "hygiene" in code writing along with the very basic concepts in programming and that will undoubtedly make you a professional.
Hristo Deshev, software craftsman
Review by Hristo Radkov, Clever IT (London, UK)
Fantastic book! It gives the start to any developer geek who wants to develop into a software prodigy. While you can learn from the quick learning books for dummies to do coding that "just works" and this is the level expected in many of the small software development houses around, you can never leave a trace in the software world without understanding the fundamental concepts of programming. Yes, you can still develop software applications and use the goodies of the .NET framework, but just use and not create or innovate.
If you’d like to ever achieve architectural excellence and be able to confidently and proudly say you have developed a good piece of software that will stay there and serve its purpose for years, you need to understand just how the technologies you use in everyday live (e.g. ASP.NET, MVC, WPF, WCF, LINQ, Sockets, Task Parallel Library) work, but how they have been developed and optimized to become what they are. Only then would you save precious time in finding how to do things efficiently with these technologies, because that knowledge will naturally come from what you have learned from this book. And the same applies to understanding the widely recommended in the world of programming nowadays design patterns, architectures and techniques.
The book will allow you to prepare yourself to think, design and program optimally as a concept and mindset with any object oriented language you might ever use not just C# or .NET Framework.
Many banking systems here in London have a main requirement to be "real-time" data servers to thousands of users with minimum delays and interruptions, and this book provides the basics which if you lack you cannot work on such systems successfully, ever.
This fundamental knowledge distinguishes the excellent and accomplished developer, whose code would rarely require optimizations and would therefore save direct and indirect costs to their employer from the general developers who unfortunately are the prevailing part of the programmers you would meet in your career. The accomplished specialists evolve and progress into senior positions much easier when having the technical arguments and the mentality to be creative and visionary, avoiding the difficulties of technology gap limitations the mass around you have.
So, read the book carefully and diligently to become one!
Hristo Radkov is a Chief software architect and Co-founder at Clever IT, a software services, best coding practices and architecture consulting company based in London, United Kingdom. With over 15 years of experience as a Developer, Team leader, Development manager, Head of IT and Software Architect he has done projects professionally with C++, Java and C#, eventually remaining completely on the side of the Microsoft Technologies after the very first release of .NET Framework, becoming recognized by the industry Microsoft Technology Software Development Best Practices and Cloud Programming Expert, with MCPD, MCSD.NET, MCDBA and MCTS awards. Hristo is co-author of the books "Programming for the .NET Framework (vol. 1 & 2)" and has been instructor for .NET and Design Patterns for many years. His company Clever IT is consulting top financial institutions and FTSE 100 corporations with multibillion valuations on the World Stock Exchanges. You can find more about him on www.radkov.com or linked-in at Hristo Radkov. To contact him, use the e-mail address: hradkov@clevit.com.

License
The book and all its study materials are distributed freely under the following license:
Common Definitions
	The present license defines the terms and conditions for using and distributing the "study materials" and the book "Fundamentals of Computer Programming with C#", developed by a team of volunteers under the guidance of Svetlin Nakov (www.nakov.com).
	The study materials consist of:
	the book (textbook) on "Fundamentals of Computer Programming with C#"
	sample source code
	demo programs
	exercise problems
	presentation slides
	video materials
	The study materials are available for free download according to the terms and conditions specified in this license at the official website of the project: www.introprogramming.info.
	Authors of the study materials are the persons who participated in their creation.
	User of the study materials is anybody who uses or accesses these materials or portions of them.
Rights and Limitations of the Users
	Users may:
	distribute free of charge unaltered copies of the study materials in electronic or paper format;
	use the study materials or portions of them, including the examples, demos, exercises and presentation slides or their modifications, for all intents and purposes, including educational and commercial projects, provided they clearly specify the original source, the original author(s) of the corresponding text or source code, this license and the website www.introprogramming.info;
	distribute free of charge portions of the study materials or modified copies of them (including translating them into other languages or adapting them to other programming languages and platforms), but only by explicitly mentioning the original source and the authors of the corresponding text, source code or other material, this license and the official website of the project: www.introprogramming.info.
	Users may not:
	distribute for profit the study materials or portions of them, with the exception of the source code;
	remove this license from the study materials when modifying them for own needs.
Rights and Limitations of the Authors
	Every author has non-exclusive rights on the products of his / her own work contributing to build the study materials.
	The authors have the right to use the products of their contribution for any purpose, including modifying them and distributing them for profit.
	The rights on all study materials written in joint authorship belong to all co-authors together.
	The authors may not distribute for profit study materials they’ve written in joint authorship without the explicit permission of all other co-authors.
Resources Coming with the Book
This book "Fundamentals of Computer Programming with C#" comes with a rich set of resources: official web site, official discussion forum, presentation slides for each chapter of the book, video lessons for each chapter of the book and Facebook fan page.
The Book’s Website
The official website of the book "Introduction to programming with C#" is available at: www.introprogramming.info. At book’s web site you can freely download the book and many related resources:
	The whole book in several electronic formats (PDF / DOC / DOCX / HTML / Kindle / etc.)
	The source code of the examples (demos) for each chapter
	Video lessons covering the entire book content with live demos and detailed explanations (in English and in Bulgarian)
	PowerPoint presentations slides for each chapter, ready for instructors who want to teach programming (in English)
	The exercises and solutions guidelines for each chapter
	Solutions to all problems from the book + explanation of the algorithm and the source code for each solution + tests (in Bulgarian)
	Interactive Mind maps for each book chapter
	The book in Bulgarian language (the original)
	A Java version of the book (with all content and examples adapter to Java programming language).
Discussion Forum
The discussion forum where you can find solutions to almost all problems from the book is available at: forums.academy.telerik.com.
This forum is created for discussions among the participants in Telerik Software Academy’s courses who go through this book during the first few months of their training and mandatorily solve all problems in the exercise sections. Most people "living" in the forum are Bulgarian but everyone speaks English so you are invited to ask your questions about the book exercises in English.
In the forum you’ll find comments and solutions submitted by students and readers of the book, as well as by the trainers at the Software Academy. Just search thoroughly enough and you’ll find several solutions to all problems in the book (with no exceptions). Every year thousands of participants in Telerik Software Academy solve problems from this book and share their solutions and the difficulties they’ve encountered, so simply search thoroughly in the forum or ask, if you can’t get to a solution for a particular problem.
Presentation Slides Coming with the Book
This book is used in many universities, colleges, schools and organizations as a textbook on computer programming, C#, data structures and algorithms. To help instructors teach the lessons following this book we have prepared PowerPoint presentation slides for each chapter of the book. Instructors are welcome to use the slides free of charge under the license agreement stated above. The authors' team will be happy to find out that this book and its study materials and presentation slides are helping people all over the world to learn programming. This is the primary goal of the project: to teach computer programming fundamentals, in complete, simple, structured, understandable way, free of charge. You may find the PowerPoint slides in English at the book’s official web site: www.introprogramming.info.
Video Materials for Self-Education with the Book
As part of the Telerik Software Academy program (academy.telerik.com) and, in particular, the free course "Fundamentals of C# Programming", videos of all lectures on the subject matter in this book have been recorded. The video materials in English and Bulgarian can be found at C# book’s official web site: introprogramming.info.
If you speak Bulgarian you might be interested in Telerik Software Academy’s video channel in YouTube: youtube.com/TelerikAcademy. It provides for free thousands video lessons on programming and software development.
Interactive Mind Maps
As part of the book we created a set of interactive mind maps to visualize its content and to improve the level of memorization. We have a few mind maps for each chapter that visually illustrates its content and a global mind map of the entire book. The mind maps are available at the book’s web site: http://www.introprogramming.info/english-intro-csharp-book/mind-maps/.
C# Book Fan Club
For the fans of the book "Introduction to Programming with C#" we have a Facebook page: www.facebook.com/IntroCSharpBook.
Svetlin Nakov, PhD,
Manager of the "Technical Training" Department,
Telerik Software Academy, Telerik Corporation,
August 24th, 2013
 



 



www.devbg.org


Bulgarian Association of Software Developers (BASD) is a non-profit organization that supports the Bulgarian software developers through educational and other initiatives.
BASD works to promote exchange of experience between the developers and improvement of their knowledge and skills in the area of software development and software technologies.
The Association organizes conferences, seminars and training courses for software engineers and other professionals involved in the software industry.
 
 

 


	



  
Chapter 8. Numeral Systems

In This Chapter
In this chapter we will take a look at working with different numeral systems and how numbers are represented in them. We will pay more attention to how numbers are represented in decimal, binary and hexadecimal numeral systems, since they are most widely used in computers and programming. We will also explain the different ways for encoding numeral data in computers – signed or unsigned integers and the different types of real numbers.
History in a Nutshell
Different numeral systems have been used since the ancient times. This claim is supported by the fact that in ancient Egypt people used sun dials, which measure time with the help of numeral systems. Most historians believe that ancient Egyptians are the first civilization, which divided the day into smaller parts. They accomplished this by using the first sun dials, which were nothing more than a simple pole stuck in the ground, oriented by the length and direction of the shadow.
Later a better sundial was invented, which looked like the letter T and divided the time between sunrise and sunset into 12 parts. This proves the use of the duodecimal system in ancient Egypt, the importance of the number 12 is usually related to the fact that moon cycles in a single year are 12 or the number of phalanxes found in the fingers of one hand (four in each finger, excluding the thumb).
In modern times, the decimal system is the most widely spread numeral system. Maybe this is due to the fact that it enables people to count by using the fingers on their hands.
Ancient civilizations divided the day into smaller parts by using different numeral systems – duodecimal and sexagesimal with bases 12 and 60 respectively. Greek astronomers such as Hipparchus used astronomical approaches, which were earlier used by the Babylonians in Mesopotamia. The Babylonians did astronomical calculations using the sexagesimal system, which they had inherited from the Sumerians, who had developed it on their own around 2000 B.C. It is not known exactly why the number 60 was chosen for a base of the numeral system but it is important to note that this system is very appropriate for the representation of fractions, because the number 60 is the smallest number that can be divided by 1, 2, 3, 4, 5, 6, 10, 12, 15, 20 and 30 without a remainder.
Applications of the Sexagesimal Numeral System
The sexagesimal system is still used today for measuring angles, geographical coordinates and time. It still finds application on the watch dial and the sphere of the geographical globe. The sexagesimal system was used by Eratosthenes for dividing a circumference into 60 parts in order to create an early system of geographical latitudes, made up from horizontal lines passing through places well known in the past.
One century after Eratosthenes, Hipparchus standardized these lines by making them parallel and conformable to the geometry of the Earth. He introduced a system of geographical longitude lines, which included 360 degrees and respectively passed from north to south and pole to pole. In the book "Almagest" (150 A.D.), Claudius Ptolemy further developed Hipparchus’ studies by dividing the 360 degrees of geographical latitude and longitude into other smaller parts. He divided each of the degrees into 60 equal parts, each of which was later divided again into 60 smaller and equal parts. The parts created by the division were called partes minutiae primae, or "first minute" and respectively partes minutiae secundae, or "second minute". These parts are still used today and are called "minutes" and "seconds" respectively.
Short Summary
We took a short historical trip through the millennia, which helped us learn that numeral systems were created, used and developed as far back as the Sumerians. The presented facts explain why a day contains (only) 24 hours, the hour has 60 minutes and the minute has 60 seconds. This is a result of the fact that the ancient Egyptians divided the day after they had started using the duodecimal numeral system. The division of hours and minutes into 60 equal parts is a result of the work of ancient Greek astronomers, who did their calculations using the sexagesimal numeral system, which was created by the Sumerians and used by the Babylonians.
Numeral Systems
So far we have taken a look at the history of numeral systems. Let’s now take a detailed look at what they really are and what is their role in computing.
What Are Numeral Systems?
Numeral systems are a way of representing numbers by a finite type-set of graphical signs called digits. We must add to them the rules for depicting numbers. The characters, which are used to depict numbers in a given numeral system, can be perceived as that system’s alphabet.
During the different stages of the development of human civilization, various numeral systems had gained popularity. We must note that today the most widely spread one is the Arabic numeral system. It uses the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9, as its alphabet. (An interesting fact is that the depiction of Arabic numerals in modern times is different from the ten digits mentioned above but in spite of all they are still referred to the same numeral system – the decimal one).
Beside an alphabet, every numeral system has a base. The base is a number equal to the different digits used by the system for depicting the numbers in it. For example, the Arabic numeral system is decimal because it has 10 digits. A random number can be chosen as a base, which has an absolute value different than 1 and 0. It can also be a real or a complex number with a sign.
A practical question we can ask is: which is the best numeral system that we should use? To answer it, we must decide what the optimal way to depict a number (the digit count in the number) is and the number of digits the given numeral system uses – its base. Mathematically it can be proven that the best ratio between the length of depiction and the number of used digits is accomplished by using Euler's number (e = 2,718281828), which is the base of natural logarithms.
Working in a system with such base e is extremely inconvenient and impractical because that number cannot be represented as a ratio of two natural numbers. This gives us grounds to conclude that the optimal base of a numeral system is either 2 or 3.
Although the number 3 is closer to the Neper number, it is unsuitable for technical implementation. Because of that the binary numeral system is the only one suitable for practical use and it is used in the modern computers and electronic devices.
Positional Numeral Systems
A positional numeral system is a system, in which the position of the digits is significant for the value of the number. This means that the value of the digits in the number is not strictly defined and depends on which position the given digit is. For example, in the number 351 the digit 1 has a value of 1, while in the number 1024 it has a value of 1000. We must note that the bases of the numeral systems are applicable only with positional numeral systems. In a positional numeral system the number A(p) = (a(n)a(n-1)…a(0),a(-1)a(-2)…a(-k)) can be represented in the following way:
 
In this sum Tm has the meaning of a weight factor for the mth digit of the number. In most cases Tm = Pm, which means that:
 
Formed using the sum above, the number A(p) is respectively made up from its whole part (a(n)a(n-1)…a(0)) and its fraction (a(-1)a(-2)…a(-k)), where every a belongs to the multitude of the natural numbers M={0, 1, 2, …, p-1}. We can easily see that in positional numeral systems the value of each digit is the-base-of-the-system times bigger than the one before it (the digit to the right, which is the lower-order digit). As a direct result from this we must add one to the left (higher-order) digit, if we need to note a digit in the current digit that is bigger than the base. The systems with bases of 2, 8, 10 and 16 have become wide spread in computing devices. In the table below we can see their notation of the numbers from 0 to 15:
Binary	Octal	Decimal	Hexadecimal
0000	0	0	0
0001	1	1	1
0010	2	2	2
0011	3	3	3
0100	4	4	4
0101	5	5	5
0110	6	6	6
0111	7	7	7
1000	10	8	8
1001	11	9	9
1010	12	10	A
1011	13	11	B
1100	14	12	C
1101	15	13	D
1110	16	14	E
1111	17	15	F
Non-Positional Numeral Systems
Besides the positional numeral systems, there are also non-positional numeral systems, in which the value of each digit is a constant and does not strictly depend on its position in the number. Such numeral systems are the Roman and Greek numeral systems. All non-positional numeral systems have a common drawback – the notation of big numbers in them is very inefficient. As a result of this drawback, they have gained only limited use. This could often lead to inaccuracy when determining the value of numbers. We will take a very brief look at the Roman and Greek numeral systems.
Roman Numeral System
The Roman numeral system uses sequences of the following symbols to represent the numbers:
Roman Digit	Decimal Value
I	1
V	5
X	10
L	50
C	100
D	500
M	1000
As we have already mentioned, in this numeral system the position of the digit has no significance for the value of the number and for determining the value, the following rules are applied:
	If two consecutively represented Roman digits are in such order that the value of the first one is bigger or equal to the value of the second one, their values are added. Example:
The number III=3, but the number MMD=2500.
	If two consecutively represented roman digits are in increasing order of their values, they are subtracted. Example:
The number IX=9, the number MXL=1040, but the number MXXIV=1024.
Greek Numeral System
The Greek numeral system is a decimal system, in which a grouping of fives is done. It uses the following digits:
Greek Digit	Decimal Value
?	1
Ă	5
?	10
?	100
?	1,000
?	10,000
As we can see in the table, one is represented with a vertical line, five with the letter Ă, and the powers of 10 with the first letter of the corresponding Greek word.
Here are some examples of numbers in this system:
	?? = 50 = 5 x 10
	?H = 500 = 5 x 100
	?X = 5000 = 5 x 1,000
	?M = 50,000 = 5 x 10,000
The Binary Numeral System – Foundation of Computing Technology
The binary numeral system is the system, which is used to represent and process numbers in modern computing machines. The main reason it is so widely spread is explained with the fact that devices with two stable states are very simple to implement and the production costs of binary arithmetic devices are very low.
The binary digits 0 and 1 can be easily represented in the computing machines as "current" and "no current", or as "+5V" and "-5V".
Along with its advantages, the binary system for number notation in computers has its drawbacks, too. One of its biggest practical flaws is that numbers represented in binary numeral system are very long, meaning they have a large number of bits. This makes it inconvenient for direct use by humans. To avoid this disadvantage, systems with larger bases are used in practice.
Decimal Numbers
Numbers represented in the decimal numeral system, are given in a primal appearance, meaning that they are easy to be understood by humans. This numeral system has the number 10 for a base. The numbers represented in it are ordered by the powers of the number 10. The lowest-order digit (first from right to left) of the decimal numbers is used to represent the ones (100=1), the next one to represent the tens (101=10), the next one to represent the hundreds (102=100), and so on. In other words – every following digit is ten times bigger than the one preceding it. The sum of the separate digits determines the value of the number. We will take the number 95031 as an example, which can be represented in the decimal numeral system as:
95031 = (9?104) + (5?103) + (0?102) + (3?101) + (1?100)
Represented that way, the number 95031 is presented in a natural way for humans because the principles of the decimal numeral system have been accepted as fundamental for people.
 	The discussed approaches are valid for the other numeral systems, too. They have the same logical setting but are applied to a system with a different base. The last statement is true for the binary and hexadecimal numeral systems, which we will discuss in details in a little bit.
Binary Numbers
The numbers represented in the binary numeral system are represented in a secondary aspect – which means that they are easy to be understood by the computing machine. They are a bit harder to be understood by people. To represent a binary number, the binary numeral system is used, which has the number 2 for a base. The numbers represented in it are ordered by the powers of two. Only the digits 0 and 1 are used for their notation.
Usually, when a number is represented in a numeral system other than decimal, the numeral system’s base is added as an index in brackets next to the number. For example, with this notation 1110(2) we indicate a number in the binary numeral system. If no numeral system is explicitly specified, it is accepted that the number is in the decimal system. The number is pronounced by reading its digits in sequence from left to right (we read from the highest-order to the lowest-order bit).
Like with decimal numbers, each binary number being looked at from right to left is represented by a power of the number 2 in the respected sequence. The lowest-order position in a binary number corresponds to the zero power (20=1), the second position corresponds to 2 to the first power (21=2), the third position corresponds to 2 to the second power (22=4), and so on. If the number is 8 bits long, the last bit is 2 to the seventh power (27=128). If the number has 16 bits, the last bit is 2 to the fifteenth power. By using 8 binary digits (0 or 1) we can represent a total of 256 numbers, because 28=256. By using 16 binary digits we can represent a total of 65536 numbers, because 216=65536.
Let’s look at some examples of numbers in the binary numeral system. Take, for example, the decimal number 148. It is composed of three digits: 1, 4 and 8, and it corresponds to the following binary number:
10010100(2)
148 = (1?27) + (1?24) + (1?22)
The full notation of the number is depicted in the following table:
Number	1	0	0	1	0	1	0	0
Power	27	26	25	24	23	22	21	20
Value	1?27= 128	0?26= 0	0?25= 0	1?24= 16	0?23= 0	1?22= 4	0?21= 0	0?20= 0
The sequence of eight zeros or ones represents one byte, an ordinary eight bit binary number. All numbers from 0 to 255 including can be represented in a single byte. In most cases this is not enough; as a result several consecutive bytes can be used to represent a big number. Two bytes form the so called "machine word" (word), which corresponds to 16 bits (in 16-bit computing machines). Besides it, computing machines use the so called double word or dword, corresponding to 32 bits.
 	If a binary number ends in 0 it is even, if it ends in 1 it is odd.
Converting From Binary to Decimal Numeral System
When turning from binary to decimal numeral system, we do a conversion of a binary number to a decimal number. Every number can be converted from one numeral system to another by doing a sequence of operations that are possible in both numeral systems. As we have already mentioned, numbers in the binary system consist of binary digits, which are ordered by the powers of 2. Let’s take the number 11001(2). Converting into decimal is done by calculating the following sum:
11001(2) = 1?24 + 1?23 + 0?22 + 0?21 + 1?20 =
= 16(10) + 8(10) + 1(10) = 25(10)
From this follows that 11001(2) = 25(10)
In other words – every single binary digit is multiplied by 2 raised to the power of the position it is in. In the end all of the numbers resulting from the binary digits are added up to get the decimal value of the binary number.
Horner Scheme
Another method of conversion exists, known as the Horner Scheme. When using it, we multiply the left most digit by 2 and add it to the one to its right. We multiply this result by two and the neighboring digit (one to the right) is added. This is repeated until all the digits in the number have been exhausted and we add the last digit without multiplying it. Here is an example:
1001(2) = ((1 ? 2 + 0) ? 2 + 0) ? 2 + 1 = 2 ? 2 ? 2 + 1 = 9
Converting from Decimal to Binary Numeral System
When transitioning from decimal to binary numeral system, we convert a decimal number into a binary one. To accomplish this, we divide it by 2 with a remainder. This is how we get the quotient and the remainder, which is separated.
Let’s use the number 148 again as an example. We do an integer division by the base we want to convert to (in this case it is 2). After that using the remainders of the division (they will always be either zero or one), we represent the converted number. We continue dividing until we get a zero quotient. Here is an example:
148:2=74	with remainder 0;
74:2=37	with remainder 0;
37:2=18	with remainder 1;
18:2=9		with remainder 0;
9:2=4		with remainder 1;
4:2=2		with remainder 0;
2:2=1		with remainder 0;
1:2=0		with remainder 1;
After we are done with the division, we represent the remainders in reverse order as follows:
10010100
i.e. 148(10) = 10010100 (2)
Operations with Binary Numbers
The arithmetical rules of addition, subtraction and multiplication are valid for a single digit of binary numbers:
0 + 0 = 0			0 - 0 = 0			0 ? 0 = 0
1 + 0 = 1			1 - 0 = 1			1 ? 0 = 0
0 + 1 = 1			1 - 1 = 0			0 ? 1 = 0
1 + 1 = 10			10 - 1 = 1			1 ? 1 = 1
In addition, with binary numbers we can also do logical operations such as logical multiplication (conjunction), logical addition (disjunction) and the sum of modulo two (exclusive or).
We must also note that when we are doing arithmetic operations with multi-order numbers we must take into account the connection between the separate orders by transfer or loan, when doing addition or subtraction respectively. Let’s take a look at some details regarding bitwise operators.
Bitwise "and"
The bitwise AND operator can be used for checking the value of a given bit in a number. For example, if we want to check if a given number is even (we check if the lowest-order bit is 1):
10111011 AND 00000001 = 00000001
The result is 1, which means that the number is odd (if the result was 0 the number would be even).
In C# the bitwise "and" is represented with & and is used like this:
int result = integer1 & integer2;
Bitwise "or"
The bitwise OR operator can be used if we want, for example, to "raise" a given bit to 1:
10111011 OR 00000100 = 10111111
Bitwise "or" in C# is represented with | and is used like this:
int result = integer1 | integer2;
Bitwise "exclusive or"
The bitwise operator XOR – every binary digit is processed separately, and when we have a 0 in the second operand, the corresponding value of the bit in the first operand is copied in the result. At every position that has a value of 1 in the second operand, we reverse the value of the corresponding position in the first operand and represent it in the result:
10111011 XOR 01010101 = 11101110
In C# the notation of the "exclusive or" operator is ^:
int result = integer1 ^ integer2;
Bitwise Negation
The bitwise operator NOT – this is a unary operator, which means that it is applied to a single operand. What it does is to reverse every bit of the given binary number to its opposite value:
NOT 10111011 = 01000100
In C# the bitwise negation is represented with ~:
int result = ~integer1;
Hexadecimal Numbers
With hexadecimal numbers we have the number 16 for a system base, which implies the use of 16 digits to represent all possible values from 0 to 15 inclusive. As we have already shown in one of the tables in the previous sections, for notating numbers in the hexadecimal system, we use the digits from 0 to 9 and the Latin numbers from A to F. Each of them has the corresponding value:
A=10, B=11, C=12, D=13, E=14, F=15
We can give the following example for hexadecimal numbers: D2, 1F2F1, D1E and so on.
Transition to decimal system is done by multiplying the value of the right most digit by 160, the next one to the left by 161, the next one to the left by 162 and so on, and adding them all up in the end. Example:
D1E(16) = E*160 + 1*161 + D*162 = 14*1 + 1*16 + 13*256 = 3358(10).
Transition from decimal to hexadecimal numeral system is done by dividing the decimal number by 16 and taking the remainders in reverse order. Example:
3358 / 16 = 209 + remainder 14 (E)
209 / 16 = 13 + remainder 1 (1)
13 / 16 = 0 + remainder 13 (D)
We take the remainders in reverse order and get the number D1E(16).
Fast Transition from Binary to Hexadecimal Numbers
The fast conversion from binary to hexadecimal numbers can be quickly and easily done by dividing the binary number into groups of four bits (splitting it into half-bytes). If the number of digits is not divisible by four, leading zeros in the highest-orders are added. After the division and the eventual addition of zeros, all the groups are replaced with their corresponding digits. Here is an example:
Let’s look at the following: 1110011110(2).
	We divide it into half-bytes and add the leading zeros
Example: 0011 1001 1110.
	We replace every half-byte with the corresponding hexadecimal digit and we get 39E(16).
Therefore 1110011110 (2) = 39E(16).
Numeral Systems – Summary
As a summary, we will formulate again in a short but clear manner the algorithms used for transitioning from one positional numeral system to another:
	Transitioning from a decimal to a k-based numeral system is done by consecutively dividing the decimal to the base of the k system and the remainders (their corresponding digit in the k based system) are accumulated in reverse order.
	Transitioning from a k-based numeral system to decimal is done by multiplying the last digit of the k-based number by k0, the one before it by k1, the next one by k2 and so on, and the products are the added up.
	Transitioning from a k-based numeral system to a p-based numeral system is done by intermediately converting to the decimal system (excluding hexadecimal and binary numeral systems).
	Transitioning from a binary to hexadecimal numeral system and back is done by converting each sequence of 4 binary bits into its corresponding hexadecimal number and vice versa.
Representation of Numbers
Binary code is used to store data in the operating memory of computing machines. Depending on the type of data we want to store (strings, integers or real numbers with an integral and fractal part) information is represented in a particular manner. It is determined by the data type.
Even a programmer using a high level language must know how the data is allocated in the operating memory of the machine. This is also relevant to the cases when the data is stored on an external carrier, because when it is processed, it will be situated in the operating memory.
In the current section we will take a look at the different ways to present and process different types of data. In general they are based on the concepts of bit, byte and machine word.
Bit is a binary unit of information with a value of either 0 or 1.
Information in the memory is grouped in sequences of 8 bits, which form a single byte.
For an arithmetic device to process the data, it must be presented in the memory by a set number of bytes (2, 4 or 8), which form a machine word. These are concepts, which every programmer must know and understand.
Representing Integer Numbers in the Memory
One of the things we have not discussed so far is the sign of numbers. Integers can be represented in the memory in two ways: with a sign or without a sign. When numbers are represented with a sign, a signed order is introduced. It is the highest-order and has the value of 1 for negative numbers and the value of 0 for positive numbers. The rest of the orders are informational and only represent (contain) the value of the number. In the case of a number without a sign, all bits are used to represent its value.
Unsigned Integers
For unsigned integers 1, 2, 4 or 8 bytes are allocated in the memory. Depending on the number of bytes used in the notation of a given number, different scopes of representation with variable size are formed. Through n bytes all integers in the range [0, 2n-1] can be represented. The following table shows the range of the values of unsigned integers:
Number of bytes for representing the number in the memory	Range
	Notation with order	Regular notation
1	0 ? 28-1	0 ? 255
2	0 ? 216-1	0 ? 65,535
4	0 ? 232-1	0 ? 4,294,967,295
8	0 ? 264-1	0 ? 18,446,744,073,709,551,615
We will give as an example a single-byte and a double-byte representation of the number 158, whose binary notation is the following 10011110(2):
1. Representation with 1 byte:
1	0	0	1	1	1	1	0	
2. Representation with 2 bytes:
0	0	0	0	0	0	0	0	1	0	0	1	1	1	1	0	
Representing Negative Numbers
For negative numbers 1, 2, 4 or 8 bytes are allocated in the memory of the computer, while the highest-order (the left most bit) has a signature meaning and carries the information about the sign of the number. As we have already mentioned, when the signature bit has a value of 1, the number is negative, otherwise it is positive.
The next table shows the range of the values of the signed integer numbers in the computer according to the number of bytes used for their notation:
Number of bytes for representing the number in the memory	Rank
	Notation with order	Regular notation
1	-27 ? 27-1	-128 ? 127
2	-215 ? 215-1	-32,768 ? 32,767
4	-231 ? 231-1	-2,147,483,648 ? 2,147,483,647
8	-263 ? 263-1	-9,223,372,036,854,775,808 ?
9,223,372,036,854,775,807
To encode negative numbers, straight, reversed and additional code is used. In all these three notations signed integers are within the range: [-2n-1, 2n-1-1]. Positive numbers are always represented in the same way and the straight, reversed and additional code all coincide for them.
Straight code (signed magnitude) is the simplest representation of the number. The highest-order bit carries the sign and the rest of the bits hold the absolute value of the number. Here are some examples:
The number 3 in signed magnitude is represented as an eight-bit-long number 00000011.
The number -3 in signed magnitude is represented in an eight-bit-long number as 10000011.
Reversed code (one’s complement) is formed from the signed magnitude of the number by inversion (replacing all ones with zeros and vice-versa). This code is not convenient for the arithmetical operations addition and subtraction because it is executed in a different way if subtraction is necessary. Moreover the sign carrying bits need to be processed separately from the information carrying ones. This drawback is avoided by using additional code, which instead of subtraction implements addition with a negative number. The latter is depicted by its addition, i.e. the difference between 2n and the number itself. Example:
The number -127 in signed magnitude is represented as 1 1111111 and in one’s complement as 1 0000000.
The number 3 in signed magnitude is represented as 0 0000011, and in one’s complement looks like 0 1111100.
Additional code (two’s complement) is a number in reversed code to which one is added (through addition). Example:
The number -127 is represented with additional code as 1 0000001.
In the Binary Coded Decimal, also known as BCD code, in one byte two decimal digits are recorded. This is achieved by encoding a single decimal digit in each half-byte. Numbers presented in this way can be packed, which means that they can be represented in a packed format. If we represent a single decimal digit in one byte we get a non-packed format.
Modern microprocessors use one or several of the discussed codes to present negative numbers, the most widespread method is using two’s complement.
Integer Types in C#
In C# there are eight integer data types either signed or unsigned. Depending on the amount of bytes allocated for each type, different value ranges are determined. Here are descriptions of the types:
Type	Size	Range	Type in .NET Framework
sbyte	8 bits	-128 ? 127	System.SByte
byte	8 bits	0 ? 255	System.Byte
short	16 bits	-32,768 ? 32,767	System.Int16
ushort	16 bits	0 ? 65,535	System.UInt16
int	32 bits	-2,147,483,648 ? 2,147,483,647	System.Int32
uint	32 bits	0 ? 4,294,967,295	System.UInt32
long	64 bits	–9,223,372,036,854,775,808 ? 9,223,372,036,854,775,807	System.Int64
ulong	64 bits	0 ? 18,446,744,073,709,551,615	System.UInt64
We will take a brief look at the most used ones. The most commonly used integer type is int. It is represented as a 32-bit number with two’s complement and takes a value in the range [-231, 231-1]. Variables of this type are most frequently used to operate loops, index arrays and other integer calculations. In the following table an example of a variable of the type int is being declared:
int integerValue = 25;
int integerHexValue = 0x002A;
int y = Convert.ToInt32("1001", 2); // Converts binary to int
The type long is the largest signed integer type in C#. It has a size of 64 bits (8 bytes). When giving value to the variables of type long the Latin letters "l" or "L" are placed at the end of the integer literal. Placed at that position, this modifier signifies that the literal has a value of the type long. This is done because by default all integer literals are of the type int. In the next example, we declare and give 64-bit value to variables of type long:
long longValue = 9223372036854775807L;
long newLongValue = 932145699054323689l;
An important condition is not to exceed the range of numbers that can be represented in the used type. However, C# offers the ability to control what happens when an overflow occurs. This is done via the checked and unchecked blocks. The first are used when the application needs to throw an exception (of the type System.OverflowException) in case that the range of the variable is exceeded. The following programming code does exactly that:
checked
{
	int a = int.MaxValue;
	a = a + 1;
	Console.WriteLine(a);
}
In case the fragment is in an unchecked block, an exception will not be thrown and the output result will be wrong:
-2147483648
In case these blocks are not used, the C# compiler works in unchecked mode by default.
C# includes unsigned types, which can be useful when a larger range is needed for the variables in the scope of the positive numbers. Below are some examples for declaring variables without a sign. We should pay attention to the suffixes of ulong (all combinations of U, L, u, l).
byte count = 50;
ushort pixels = 62872;
uint points = 4139276850; // or 4139276850u, 4139276850U
ulong y = 18446744073709551615; // or UL, ul, Ul, uL, Lu, lU
Big-Endian and Little-Endian Representation
There are two ways for ordering bytes in the memory when representing integers longer than one byte:
	Little-Endian (LE) – bytes are ordered from left to right from the lowest-order to the highest. This representation is used in the Intel x86 and Intel x64 microprocessor architecture.
	Big-Endian (BE) – bytes are ordered from left to right starting with the highest-order and ending with the lowest. This representation is used in the PowerPC, SPARC and ARM microprocessor architecture.
Here is an example: the number A8B6EA72(16) is presented in both byte orders in the following way:
 
There are some classes in C# that offer the opportunity to define which order standard to be used. This is important for operations like sending / receiving streams of information over the internet or other types of communication between devices made by different standards. The field IsLittleEndian of the BitConverter class for example shows what mode the class is working in and how it stores data on the current computer architecture.
Representing Real Floating-Point Numbers
Real numbers consist of a whole and fraction parts. In computers, they are represented as floating-point numbers. Actually this representation comes from the Standard for Floating-Point Arithmetic (IEEE 754), adopted by the leading microprocessor manufacturers. Most hardware platforms and programming languages allow or require the calculations to be done according to the requirements of this standard. The standard defines:
	Arithmetical formats: a set of binary and decimal data with a floating-point, which consists of a finite number of digits.
	Exchange formats: encoding (bit sequences), which can be used for data exchange in an effective and compact form.
	Rounding algorithms: methods, which are used for rounding up numbers during calculations.
	Operations: arithmetic and other operations of the arithmetic formats.
	Exceptions: they are signals for extraordinary events such as division by zero, overflowing and others.
According to the IEEE-754 standard a random real number R can be presented in the following way:
R = M * qp
where M is the mantissa of the number, p is the order (exponent), and q accordingly is the base of the numeral system the number is in. The mantissa must be a positive or negative common fraction |M|<1, and the exponent – a positive or negative integer.
In the mentioned method of representation of numbers, every floating-point number will have the following summarized format ±0,M*q±p.
When notating numbers in the floating-point format using the binary numeral system in particular, we will have R = M * 2p. In this representation of real numbers in the computer memory, when we change the exponent, the decimal point in the mantissa moves ("floats"). The floating-point representation format has a semi-logarithmic form. It is depicted in the following figure:
 
Representing Floating-Point Numbers – Example
Let’s give an example of how a floating-point number is represented in the memory. We want to write the number -21.15625 in 32-bit (single precision) floating-point format according to the IEEE-754 standard. In this format, 23 bits are used for the mantissa, 8 bits for the exponent and 1 bit for the sign. The notation of the number is as follows:
 
The sign of the number is negative, which means that the mantissa has a negative sign:
S = -1
The exponent has a value of 4 (represented with a shifted order):
p = (20 + 21 + 27) - 127 = (1+2+128) – 127 = 4
For transitioning to the real value we subtract 127 from the additional code because we are working with 8 bits (127 = 27-1) starting from the zero position.
The mantissa has the following value (without taking the sign into account):
M 	= 1 + 2-2 + 2-4 + 2-7 + 2-9 =
= 1 + 0.25 + 0.0625 + 0.0078125 + 0.001953125 =
= 1.322265625
We should note that we added a one, which was missing from the binary notation of the mantissa. We did it because the mantissa is always normalized and starts with a one by default.
The value of the number is calculated using the formula R = M * 2p, which in our example looks like the following:
R = -1,3222656 * 24 = -1,322265625 * 16 = -21,1562496 ? -21,15625
Mantissa Normalization
To use the order grid more fully, the mantissa must contain a one in its highest-power order. Every mantissa fulfilling this condition is called normalized. In the IEEE-754 standard, the one in the whole part of the mantissa is by default, meaning the mantissa is always a number between 1 and 2.
If during the calculations a result that does not fulfill this condition is reached, it means that the normalization is violated. This requires the normalization of the number prior to its further processing, and for this purpose the decimal point in the mantissa is moved and the corresponding order change is made.
The Float and Double Types in C#
In C# we have at our disposal two types, which can represent floating-point numbers. The float type is a 32-bit real number with a floating-point and it is accepted to be called single precision floating-point number. The double is a 64-bit real number with a floating-point and it is accepted that it has a double precision floating-point. These real data types and the arithmetic operations with them correspond to the specification outlined by the IEEE 754-1985 standard. In the following table are presented the most important characteristics of the two types:
Type	Size	Range	Significant Digits	Type in .NET Framework
float	32 bits	±1.5 ? 10?45 ? ±3.4 ? 1038	7	System.Single
double	64 bits	±5.0 ? 10?324 ? ±1.7 ? 10308	15-16	System.Double
In the float type we have a mantissa, which contains 7 significant digits, while in the double type it stores 15-16 significant digits. The remaining bits are used for specifying the sign of the mantissa and the value of the exponent. The double type, aside from the larger number of significant digits, also has a larger exponent, which means that it has a larger scope of the values it can assume. Here is an example how to declare variables of the float and double types:
float total = 5.0f;
float result = 5.0f;
double sum = 10.0;
double div = 35.4 / 3.0;
double x = 5d;
The suffixes placed after the numbers on the right side of the equation, serve the purpose of specifying what type the number should be treated as (f for float, d for double). In this case they are in place because by default 5.0 will be interpreted as a double and 5 – as an int.
 	In C#, floating-point numbers literals by default are of the double type.
Integers and floating-point numbers can both be present in a given expression. In that case, the integer variables are converted to floating-point variables and the result is defined according to the following rules:
	If any of the floating-point types is a double, the result will be double (or bool).
	If there is no double type in the expression, the result is float (or bool).
Many of the mathematical operations can yield results, which have no specific numerical value, like the value "+/- infinity" or NaN (which means "Not a Number"), these values are not numbers. Here is an example:
double d = 0;
Console.WriteLine(d);
Console.WriteLine(1/d);
Console.WriteLine(-1/d);
Console.WriteLine(d/d);
If we execute it we get the following result:
0.0
Infinity
-Infinity
NaN
If we execute the code above using int instead of double, we will receive a System.DivideByZeroException, because integer division by 0 is not an allowed operation.
Errors When Using Floating-Point Numbers
Floating-point numbers (presented according to the IEEE 754 standard) are very convenient for calculations in physics, where very big numbers are used (with several hundred digits) and also numbers that are very close to zero (with hundreds of digits after the decimal point before the first significant digit). When working with these numbers, the IEEE 754 format is exceptionally convenient because it keeps the number’s order in the exponent and the mantissa is only used to store the significant digits. In 64-bit floating-point numbers accuracy of 15-16 digits, as well as exponents displacing the decimal point with 300 positions left or right can be achieved.
Unfortunately not every real number has an exact representation in the IEEE 754 format, because not each number can be presented as a polynomial of a finite number of addends, which are negative powers of two. This is fully valid even for numbers, which are used daily for the simplest financial calculations. For example the number 0.1 represented as a 32-bit floating-point value is presented as 0.099999994. If the appropriate rounding is used, the number can be accepted as 0.1, but the error can be accumulated and cause serious deviations, especially in financial calculations. For example when adding up 1000 items with a unit price of 0.1 EUR each, we should get a sum of 100 EUR but if we use a 32-bit floating-point numbers for the calculations the result will be 99.99905. Here is C# example in action, which proves the errors caused by the inaccurate presentation of decimal real numbers in the binary numeral system:
float sum = 0f;
for (int i = 0; i < 1000; i++)
{
	sum += 0.1f;
}
Console.WriteLine("Sum = {0}", sum);
// Sum = 99.99905
We can easily see the errors in such calculations if we execute the example or modify it to get even more striking errors.
Precision of Floating-Point Numbers
The accuracy of the results from floating-point calculations depends on the following parameters:
	Precision of the number representation.
	Precision of the used number methods.
	Value of the errors resulting from rounding up, etc.
Calculations with them can be inaccurate because they are represented in the memory with some kind of precision. Let’s look at the following code fragment as an example:
double sum = 0.0;
for (int i = 1; i <= 10; i++)
{
	sum += 0.1;
}
Console.WriteLine("{0:r}", sum);
Console.WriteLine(sum);
During the execution, in the loop we add the value 1/10 to the variable sum. When calling the WriteLine() method, we use the round-trip format specifier "{0:r}" to print the exact (not rounded) value contained in the variable, and after that we print the same value without specifying a format. We expect that when we execute the program we will get 1.0 as a result but in reality, when rounding is turned off, the program returns a value very close to the correct one but still different:
0.99999999999999989
1
As we can see in the example, by default, when printing floating-point numbers in .NET Framework, they are rounded, which seemingly reduces the errors of their inaccurate notation in the IEEE 754 format. The result of the calculation above is obviously wrong but after the rounding it looks correct. However, if we add 0.1 a several thousand times, the error will accumulate and the rounding will not be able to compensate it.
The reason for the wrong answer in the example is that the number 0.1 does not have an exact representation in the double type and it has to be rounded. Let’s replace double with float:
float sum = 0.0f;
for (int i = 1; i <= 10; i++)
{
	sum += 0.1f;
}
Console.WriteLine("{0:r}", sum);
If we execute the code above, we will get an entirely different sum:
1.00000012
Again the reason for this is rounding.
If we investigate why the program yields these results, we will see that the number 0.1 of the float type is represented in the following manner:
 
All this looks correct except for the mantissa, which has a value slightly bigger than 1.6, not exactly 1.6 because this number cannot be presented as sum of the negative powers of 2. If we have to be very precise, the value of the mantissa is 1 + 1 / 2 + 1 / 16 + 1 / 32 + 1 / 256 + 1 / 512 + 1 / 4096 + 1 / 8192 + 1 / 65536 + 1 / 131072 + 1 / 1048576 + 1 / 2097152 + 1 / 8388608 ? 1.60000002384185791015625 ? 1.6. Thus the number 0.1 presented in the IEE 754 is slightly more than 1.6 ? 2-4 and the error occurs not during the addition but before that, when 0.1 is recorded in the float type.
Double and Float types have a field called Epsilon, which is a constant, and it contains the smallest value larger than zero, which can be represented by an instance of System.Single or System.Double respectively. Each value smaller than Epsilon is considered to be equal to 0. For example, if we compare two numbers, which are different after all, but their difference is smaller than Epsilon, they will be considered equal.
The Decimal Type
The System.Decimal type in .NET Framework uses decimal floating-point arithmetic and 128-bit precision, which is very suitable for big numbers and precise financial calculations. Here are some characteristics of the decimal type:
Type	Size	Range	Significant numbers	Type in .NET framework
decimal	128 bits	±1.0 ? 10?28 ? ±7.9 ? 1028	28-29	System.Decimal
Unlike the floating-point numbers, the decimal type retains its precision for all decimal number in its range. The secret to this excellent precision when working with decimal numbers lies in the fact that the internal representation of the mantissa is not in the binary system but in the decimal one. The exponent is also a power of 10, not 2. This enables numbers to be represented precisely, without them being converted to the binary numeral system.
Because the float and double types and the operations on them are implementer by the arithmetic coprocessor, which is part of all modern computer microprocessors, and decimal is implemented by the software in .NET CLR, it is tens of times slower than double, but is irreplaceable for the execution of financial calculations.
In case our target is to assign a given literal to variable of type decimal, we need to use the suffixes m or M. For example:
decimal calc = 20.4m;
decimal result = 5.0M;
Let’s use decimal instead of float / double in the example from before:
decimal sum = 0.0m;
for (int i = 1; i <= 10000000; i++)
{
	sum += 0.0000001m;
}
Console.WriteLine(sum);
This time the result is exactly what we expected:
1.0000000
Even though the decimal type has a higher precision than the floating-point types, it has a smaller value range and, for example, it cannot be used to represent the following value 1e-50. As a result, an overflow may occur when converting from floating-point numbers to decimal.
Character Data (Strings)
Character (text) data in computing is text, encoded using a sequence of bytes. There are different encoding schemes used to encode text data. Most of them encode one character in one byte or in a sequence of several bytes. Such encoding schemes are ASCII, Windows-1251, UTF-8 and UTF-16.
Encoding Schemes (Encodings)
The ASCII encoding scheme compares the unique number of the letters from the Latin alphabet and some other symbols and special characters and writes them in a single byte. The ASCII standard contains a total of 127 characters, each of which is written in one byte. A text, written as a sequence of bytes according to the ASCII standard, cannot contain Cyrillic or characters from other alphabets such as the Arabian, Korean and Chinese ones.
Like the ASCII standard, the Windows-1251 encoding scheme compares the unique number of the letters in the Latin alphabet, Cyrillic and some other symbols and specialized characters and writes them in one byte. The Windows-1251 encoding defines the numbers of 256 characters – exactly as many as the different values that can be written in one byte. A text written according to the Windows-1251 standard can contain only Cyrillic and Latin letters, Arabian, Indian or Chinese are not supported.
The UTF-8 encoding is completely different. All characters in the Unicode standard – the letters and symbols used in all widely spread languages in the world (Cyrillic, Latin, Arabian, Chinese, Japanese, Korean and many other languages and writing systems) – can be encoded in it. The UTF-8 encoding contains over half a million symbols. In the UTF-8 encoding, the more commonly used symbols are encoded in 1 byte (Latin letters and digits for example), the second most commonly used symbols are coded in 2 bytes (Cyrillic letters for example), and the ones that are used even more rarely are coded in 3 or 4 bytes (like the Chinese, Japanese and Korean alphabet).
The UTF-16 encoding, like UTF-8 can depict text of all commonly used languages and writing systems, described in the Unicode standard. In UTF-16, every symbol is written in 16 bits (2 bytes) and some of the more rarely used symbols are presented as a sequence of two 16-bit values.
Presenting a Sequence of Characters
Character sequences can be presented in several ways. The most common method for writing text in the memory is to write in 2 or 4 bytes its length, followed by a sequence of bytes, which presents the text itself in some sort of encoding (for example Windows-1251 or UTF-8).
Another, less common method of writing texts in the memory, typical for the C language, represents texts as a sequence of characters, usually coded in 1 byte, followed by a special ending character, most frequently a 0. When using this method, the length of the text saved at a given position in the memory is not known in advance. This is considered a disadvantage in many situations.
Char Type
The char type in the C# language is a 16-bit value, in which a single Unicode character or part of it is coded. In most alphabets (for example the ones used by all European languages) one letter is written in a single 16-bit value, and thus it is assumed that a variable of the char type represents a single character. Here is an example:
char ch = 'A';
Console.WriteLine(ch);
String Type
The string type in C# holds text, encoded in UTF-16. A single string in C# consists of 4 bytes length and a sequence of characters written as 16-bit values of the char type. The string type can store texts written in all widespread alphabets and human writing systems – Latin, Cyrillic, Chinese, Japanese, Arabian and many, many others. Here is an example of the usage of the string:
string str = "Example";
Console.WriteLine(str);
Exercises
	Convert the numbers 151, 35, 43, 251, 1023 and 1024 to the binary numeral system.
	Convert the number 1111010110011110(2) to hexadecimal and decimal numeral systems.
	Convert the hexadecimal numbers FA, 2A3E, FFFF, 5A0E9 to binary and decimal numeral systems.
	Write a program that converts a decimal number to binary one.
	Write a program that converts a binary number to decimal one.
	Write a program that converts a decimal number to hexadecimal one.
	Write a program that converts a hexadecimal number to decimal one.
	Write a program that converts a hexadecimal number to binary one.
	Write a program that converts a binary number to hexadecimal one.
	Write a program that converts a binary number to decimal using the Horner scheme.
	Write a program that converts Roman digits to Arabic ones.
	Write a program that converts Arabic digits to Roman ones.
	Write a program that by given N, S, D (2 ? S, D ? 16) converts the number N from an S-based numeral system to a D based numeral system.
	Try adding up 50,000,000 times the number 0.000001. Use a loop and addition (not direct multiplication). Try it with float and double and after that with decimal. Do you notice the huge difference in the results and speed of calculation? Explain what happens.
	* Write a program that prints the value of the mantissa, the sign of the mantissa and exponent in float numbers (32-bit numbers with a floating-point according to the IEEE 754 standard). Example: for the number -27.25 should be printed: sign = 1, exponent = 10000011, mantissa = 10110100000000000000000.
Solutions and Guidelines
	Use the methods for conversion from one numeral system to another. You can check your results with the help of the Windows built-in calculator, which supports numeral systems in "Programmer" mode. The results are: 10010111, 100011, 101011, 11111011, 1111111111 and 10000000000.
	Like the previous exercise. Result: F59E(16) and 62878(10).
	Like the previous exercise. The results are: FA(16) = 250(10) = 11111010(2), 2A3E(16) = 10814(10) = 10101000111110(2), FFFF(16) = 65535(10) = 1111111111111111(2) and 5A0E9(16) = 368873(10) = 1011010000011101001(2).
	The rule is "divide by 2 and concatenate the remainders in reversed order". For division with a remainder we use the % operator. You can cheat by invoking Convert.ToString(numDecimal, 2).
	Start with a sum of 0. Multiply the right-most bit with 1 and add it to the sum. Multiply the next bit on the left by 2 and add it to the sum. Multiply the next bit on the left by 4, the next by 8 and so on. You can cheat by invoking Convert.ToInt32(binaryNumAsString, 2).
	The rule is "divide by the base of the system (16) and concatenate the remainders in reversed order". A logic that gets a hexadecimal digit (0…F) by decimal number (0…15) should also be implemented. You can cheat by invoking num.ToString("X").
	Start with a sum of 0. Multiply the right-most digit with 1 and add it to the sum. Multiply the next digit to the left by 16 and add it to the sum. Multiply the next digit by 16*16, the next by 16*16*16 and so on. You can cheat by invoking Convert.ToInt32(hexNumAsString, 16).
	Use the fast method for transitioning between hexadecimal and binary numeral system (each hexadecimal digit turns to 4 binary bits).
	Use the fast method for transitioning from binary to hexadecimal numeral system (each 4 binary bits correspond to a hexadecimal digit).
	Directly apply the Horner scheme.
	Scan the digits of the Roman number from left to right and add them up to a sum, which is initialized with a 0. When processing each Roman digit, take it with a positive or negative sign, depending on the digit after it (whether it has a bigger or smaller decimal value).
	Take a look at the numbers from 1 to 9 and their corresponding Roman representation with the digits "I", "V" and "X":
1 -> I
2 -> II
3 -> III
4 -> IV
5 -> V
6 -> VI
7 -> VII
8 -> VIII
9 -> IX
We have exactly the same correspondence for the numbers 10, 20, …, 90 with their Roman representation "X", "L" and "C". The same is valid for the numbers 100, 200, …, 900 and their Roman representation with "C", "D" and "M" and so on.
We are now ready to convert the number N into the Roman numeral system. It must be in the range [1…3999], otherwise we should report an error. First we separate the thousands (N / 1000) and replace them with their Roman counterpart. After that we separate the hundreds (N / 100) % 10) and separate them with their Roman counterpart and so on.
	You can convert first from S-based system to decimal number and then from decimal number to D-based system.
	If you execute the calculations correctly, you will get 32.00 (for float), 49.9999999657788 (for double) and 50.00 (for decimal) respectively. The differences come from the fact that 0.000001 has no exact representation as float and double. You may notice also that adding decimal values is at least 10 times slower than adding double values.
	Use the special method for conversion of single precision floating-point numbers to a sequence of 4 bytes: System.BitConverter.GetBytes(
<float>). Then use bitwise operations (shifting and bit masks) to extract the sign, mantissa and exponent following the IEEE 754 standard.
 
 
 


  


Chapter 13. Strings and Text Processing

In This Chapter
In this chapter we will explore strings. We are going to explain how they are implemented in C# and in what way we can process text content. Additionally, we will go through different methods for manipulating a text: we will learn how to compare strings, how to search for substrings, how to extract substrings upon previously settled parameters and last but not least how to split a string by separator chars. We will demonstrate how to correctly build strings with the StringBuilder class. We will provide a short but very useful information for the most commonly used regular expressions. We will discuss some classes for efficient construction of strings. Finally, we will take a look at the methods and classes for achieving more elegant and stricter formatting of the text content.
Strings
In practice we often come to the text processing: reading text files, searching for keywords and replacing them in a paragraph, validating user input data, etc… In such cases we can save the text content, which we will need in strings, and process them using the C# language.
What Is a String?
A string is a sequence of characters stored in a certain address in memory. Remember the type char? In the variable of type char we can record only one character. Where it is necessary to process more than one character then strings come to our aid.
In. NET Framework each character has a serial number from the Unicode table. The Unicode standard is established in the late 80s and early 90s in order to store different types of text data. Its predecessor ASCII is able to record only 128 or 256 characters (respective ASCII standard with 7-bit or 8-bit table). Unfortunately, this often does not meet user needs – as we can fit in 128 characters only digits, uppercase and lowercase Latin letters and some specific individual characters. When you have to work with text in Cyrillic or other specific language (e.g. Chinese or Arabian), 128 or 256 characters are extremely insufficient. Here is why .NET uses 16-bit code table for the characters. With our knowledge of number systems and representation of information in computers, we can calculate that the code table store 2^16 = 65,536 characters. Some characters are encoded in a specific way, so it is possible to use two characters of the Unicode table to create a new character – the resulting signs exceed 100,000.
The System.String Class
The class System.String enables us to handle strings in C#. For declaring the strings we will continue using the keyword string, which is an alias in C# of the System.String class from .NET Framework. The work with string facilitates us in manipulating the text content: construction of texts, text search and many other operations.
Example of declaring a string:
string greeting = "Hello, C#";
We have just declared the variable greeting of type string whose content is the text phrase "Hello, C#". The representation of the content in the string looks closely to this:
H	e	l	l	o	,		C	#
The internal representation of the class is quite simple – an array of characters. We can avoid the usage of the class by declaring a variable of type char[] and fill in the array’s elements character by character. However, there are some disadvantages too:
	Filling in the array happens character by character, not at once.
	We should know the length of the text in order to be aware whether it will fit into the already allocated space for the array.
	The text processing is manual.
The String Class: Universal Solution?
The usage of System.String is not the ideal and universal solution – sometimes it is appropriate to use different character structures.
In C# we there are other classes for text processing – we will become familiar with some of them later in this chapter.
The type string is more special from other data types. It is a class and as such it complies with the principles of object-oriented programming. Its values are stored in the dynamic memory (managed heap), and the variables of type string keeps a reference to an object in the heap.
Strings are Immutable
The string class has an important feature – the character sequences stored in a variable of the class are never changing (immutable). After being assigned once, the content of the variable does not change directly – if we try to change the value, it will be saved to a new location in the dynamic memory and the variable will point to it. Since this is an important feature, it will be illustrated later.
Strings and Char Arrays
Strings are very similar to the char arrays (char[]), but unlike them, they cannot be modified. Like the arrays, they have properties such as Length, which returns the length of the string and allows access by index. Indexing, as it is used in arrays, takes indices from 0 to Length-1. Access to the character of a certain position in a string is done with the operator [] (indexer), but it is allowed only to read characters (and not to write to them):
string str = "abcde";
char ch = str[1]; // ch == 'b'
str[1] = 'a'; // Compilation error!
ch = str[50]; // IndexOutOfRangeException
Strings – Simple Example
Let’s give an example for using variables from the type string:
string message = "This is a sample string message.";

Console.WriteLine("message = {0}", message);
Console.WriteLine("message.Length = {0}", message.Length);

for (int i = 0; i < message.Length; i++)
{
	Console.WriteLine("message[{0}] = {1}", i, message[i]);
}
// Console output:
// message = This is a sample string message.
// message.Length = 31
// message[0] = T
// message[1] = h
// message[2] = i
// message[3] = s
// …
Please note the string value – the quotes are not part of the text, they are enclosing its value. The example demonstrates how to print a string, how to extract its length and how to extract the character from which it is composed.
Strings Escaping
As we already know, if we want to use quotes into the string content, we must put a slash before them to identify that we consider the quotes character itself and not using the quotation marks for ending the string:
string quote = "Book's title is \"Intro to C#\"";
// Book's title is "Intro to C#"
The quotes in the example are part of the text. They are added in the variable by placing them after the escaping character backslash (\). In this way the compiler recognizes that the quotes are not used to start or end a string, but are a part of the data. Displaying special characters in the source code is called escaping.
Declaring a String
We can declare variables from the type string by the following rule:
string str;
Declaring a string represents a variable declaration of type string. This is not equivalent to setting a variable and allocating memory for it! With the declaration we inform the compiler that the variable str will be used and the expected type for it is string. We do not create a variable in the memory and it is not available for processing yet (value is null, which means no value).
Creating and Initializing a String
In order to process the declared string variable, we must create it and initialize it. Creating a variable of certain class (also known as instantiating) is a process associated with the allocation of the dynamic memory area (the heap). Before setting a specific value to the string, its value is null. This can be confusing to the beginner programmers: uninitialized variables of type string do not contain empty values, it contains the special value null – and each attempt for manipulating such a string will generate an error (exception for access to a missing value NullReferenceException)!
We can initialize variables in the following three ways:
	By assigning a string literal.
	By assigning the value of another string.
	By passing the value of an operation which returns a string.
Setting a String Literal
Setting a string literal means to assign a predefined textual content to a variable of type string. We use this type of initialization, when we know the value that must be stored in the variable. Example for setting a string literal:
string website = "http://www.wikipedia.org";
In this example we created the variable website with value the above stated string literal.
Assigning Value of Another String
Assigning a value is equivalent to directing a string value or a variable to a variable of type string. An example is the following code snippet:
string source = "Some source";
string assigned = source;
First, we declare and initialize the variable source. Then the variable assigned takes the value of source. Since the string class is a reference type, the text "Some source" is stored in the dynamic memory (heap) on an address defined by the first variable.
 
In the second line we redirect the variable assigned to the same place, which the other variable points to. In this way the two objects receive the same address in dynamic memory and hence the same value.
The change of either variable will affect only itself because of the immutability of the type string, as when a change occurs, a copy of the changed string will be created. This is not true for the rest of the reference types (the normal, mutable types) because with them the changes are made directly in the address in memory and all references point to this changed address.
Passing a String Expression
The third option to initialize a string is to pass the value of a string expression or operation, which returns a string result. This can be a result from a method, which validates data; adding together the values of a number of constants and variables; transforming an existing variable, etc.
Example of an expression, which returns a string:
string email = "some@gmail.com";
string info = "My mail is: " + email;
// My mail is: some@gmail.com
The info variable has been created from the concatenation of literals and a variable.
Reading and Printing to the Console
Let’s now take a look at the ways of reading strings, entered by the user and how we print strings to the console.
Reading Strings
Reading strings can be accomplished through the methods of the well-known System.Console class:
string name = Console.ReadLine();
In this example we read from the console the input data through the method ReadLine(). It waits for the user to input a value and to press [Enter]. After pressing the [Enter] key the variable name will contain the input name typed at the console (read from the keyboard).
What can we do after the variable has been created and it has a value itself? We can use it, for example, in expressions with other strings, to pass it as a method’s parameter, to write it in text documents, etc. First, we can write it to the console in order to be sure that the data has been correctly read.
Printing Strings
Taking the data to the standard output is made also by the well-known class System.Console:
Console.WriteLine("Your name is: " + name);
By using the method WriteLine(…) we are getting the message "Your name is: " followed by the value of the name variable. After the end of the message a new line character is added. If we want to run away from the new line, which means the messages will appear at one and the same line then we use the method, Write(…).
We can refresh our knowledge on the System.Console class from the chapter "Console Input and Output".
Strings Operations
After getting familiar with the strings semantics and how we can create and print them, next comes to learn how to deal with them and how to process them. The C# language gives us a number of operations ready for use, which we will use for manipulating the strings.
Comparing Strings in Alphabetical Order
There are many ways to compare strings and depending on what exactly we need in the particular case, we can take advantage of the various features of the string class.
Comparison for Equality
If the requirements are to compare the two strings in order to determine whether their values are equal or not, ¬¬the most convenient method is the Equals(…), which works equivalently to the operator ==. It returns a Boolean result with either true value, if the strings have the same values, or false value, if they are different. The method Equals(…) checks letter by letter for equality of string values, as it makes distinction between small and capital letters, i.e. comparing the "c#" and "C#" with the Equals(…) method will return the value false. Consider the following example:
string word1 = "C#";
string word2 = "c#";
Console.WriteLine(word1.Equals("C#"));
Console.WriteLine(word1.Equals(word2));
Console.WriteLine(word1 == "C#");
Console.WriteLine(word1 == word2);

// Console output:
// True
// False
// True
// False
In practice, we often are interested of only the actual text content when comparing two strings, regardless of the character casing (uppercase / lowercase). To ignore the difference between small and capital letters in string comparison we can use the method Equals(…) with the parameter StringComparison.CurrentCultureIgnoreCase. So now in the same example of comparing "C#" with "c#" the method will return the value true:
Console.WriteLine(word1.Equals(word2,
	StringComparison.CurrentCultureIgnoreCase));
// True
StringComparison.CurrentCultureIgnoreCase is a constant of the enumerated type StringComparison. What is enumerated type and how we can use it, we will learn in the chapter "Defining Classes".
Comparing Strings in Alphabetical Order
It has become clear how we compare strings for equality, but how we are going to establish the lexicographical order of several strings? If we try to use the operators < and > which work great for comparing numbers, we find out that they cannot be used for strings.
If you want to compare two words and get information which one of them is before the other according to their alphabetical order of letters, here comes the method CompareTo(…). It allows us to compare the values of two strings in order to determine their lexicographical order. In order two strings to have the same values, they must have the same length (number of characters) and the all their characters should match accordingly. For example, the strings "give" and "given" are different because they differ in their lengths, and "near" and "fear" differ in their first character.
The method CompareTo(…) from the String class returns a negative value, 0 or positive value depending on the lexical order of the two compared strings. A negative value means that the first string is lexicographically before the second, zero means that the two strings are equal and positive value means that the second string is lexicographically before the first. To clarify better how to compare strings lexicographically, let’s go through a few examples:
string score = "sCore";
string scary = "scary";

Console.WriteLine(score.CompareTo(scary));
Console.WriteLine(scary.CompareTo(score));
Console.WriteLine(scary.CompareTo(scary));

// Console output:
// 1
// -1
// 0
The first experiment is called the method CompareTo(…) of the string score, as passed parameter is the variable scary. The first digit returns equal sign. Because the method does not ignore the casing of small and capital letters, it finds mismatch in the second character (in the first string it is "C", while in the second it is "c"). This is enough to determine the arrangement of strings and CompareTo(…) returns +1. Calling the same method with swapped places of the strings returns -1, because then the starting point is the string scary. His final call returns a logical 0, because we compare scary with itself.
If we have to compare the strings lexicographically, namely to ignore the letters casing, then we could use string.Compare(string strA, string strB, bool ignoreCase). This is a static method, which works in the same way as CompareTo(…), but it has an ignoreCase option for ignoring the casing of capital and small letters. Let’s look at the method in action:
string alpha = "alpha";
string score1 = "sCorE";
string score2 = "score";

Console.WriteLine(string.Compare(alpha, score1, false));
Console.WriteLine(string.Compare(score1, score2, false));
Console.WriteLine(string.Compare(score1, score2, true));
Console.WriteLine(string.Compare(score1, score2,
	StringComparison.CurrentCultureIgnoreCase));
// Console output:
// -1
// 1
// 0
// 0
In the last example the method Compare(…) takes as a third parameter StringComparison.CurrentCultureIgnoreCase – already well-known from the method Equals(…) through which we can also compare strings, without having to register the difference between the small and capital letters.
Please note that according to the methods Compare(…) and CompareTo(…) the small letters are lexicographically before the capital ones. The correctness of this rule is quite controversial as in the Unicode table the capital letters are before the small ones. For example due to the standard Unicode, the letter "A" has a code 65, which is smaller than the code of the letter "a" (97).
 	When you want just to consider whether the values of two strings are equal or not, please use the method Equals(…) or the operator ==. The methods CompareTo(…) and string.
Compare(…) are designed to be used when the lexicographical order is needed.
Therefore, you should consider that the lexicographical comparison does not follow the letter arrangement in the Unicode table. Other abnormalities can also be caused by special features of the current culture. For some languages like German the characters "ss" and "?" are considered equal. For example the words "Stra?e" and "Strasse" are considered the same by CompareTo(…) and equal when compared through the == operator:
string first = "Stra?e";
string second = "Strasse";

Console.WriteLine(first == second); // False
Console.WriteLine(first.CompareTo(second)); // 0 – equal strings
The == and != Operators
In the C# language the operators == and =! work for strings through an internal calling of Equals(…). We will go through some examples for using those two operators with variables from the string type:
string str1 = "Hello";
string str2 = str1;

Console.WriteLine(str1 == str2);
// Console output:
// True
The comparison of matching strings str1 and str2 returns true. This is a fully expected result, since the target variable str2 is pointed to the dynamic memory that is reserved for the variable str1. Thus, both variables have the same address and the check for equality returns true. Presented is how the memory looks like with the two variables:
 
Let’s look at another example:
string hel = "Hel";
string hello = "Hello";
string copy = hel + "lo";

Console.WriteLine(copy == hello);
// True
Pay attention to the comparison between the strings hello and copy. The first variable takes directly the value "Hello". The second takes its value as a result of joining a variable with literal, and the final result is equivalent to the value of the first variable. At this stage the two variables point to different areas of memory, but the contents of the memory blocks are identical. The comparison made with the operator == returns a result true, although both variables point to different areas of memory.
Here is how the memory looks like at this point:
 
Memory Optimization for Strings (Interning)
Let’s consider the following example:
string hello = "Hello";
string same = "Hello";
Let’s create a variable with value "Hello". We also create a second variable assigning it a value the same literal. It is logical when creating the variable hello, to allocate space in the heap, to write its value and the variable to point to that location. When creating the same a new place to record should be allocated too, the value should be written and the reference to the memory should be directed.
But the truth is that there is an optimization in the C# compiler and in CLR, which saves the memory from creating duplicated strings. This optimization is called strings interning and thanks to it the two variables in the memory will be pointed to the same common block of memory. This reduces the memory space usage and optimizes certain operations such as comparing two completely matching strings. They are written in the memory in the following way:
 
When we initialize a variable of type string with a string literal, the memory checks invisibly for us whether this value already exists. If the value already exists, the new variable is simply pointed to it. If not, a new block of memory is allocated, the value is stored in it and the reference is changed to point to the new block. The string interning in .NET is possible because strings are immutable by design and it is not likely that the memory block referenced by several string variables will simultaneously be changed by someone.
When not initializing the strings with literals, no interning is used. However, if we want to use interning specifically, we can make it through the use of the method Intern(…):
string declared = "Intern pool";
string built = new StringBuilder("Intern pool").ToString();
string interned = string.Intern(built);

Console.WriteLine(object.ReferenceEquals(declared, built));
Console.WriteLine(object.ReferenceEquals(declared, interned)); // Console output:
// False
// True
Here is the memory situation at this moment:
 
In the example we used the static method Object.ReferenceEquals(…), which compares two objects in memory and returns whether they point to the same memory block. We used the class StringBuilder, which serves to efficiently build strings. When and how to use StringBuilder we will explain in details shortly, but now let’s get familiar with the basic operations on strings.
Operations for Manipulating Strings
Once we got familiar with the fundamentals of strings and their structure, the next thing to explore are the tools for their processing. We will review string concatenation, searching in a string, extracting substrings, change the character casing, splitting a string by separator and other string operations that will help us solve various problems from the everyday practice.
 	Strings are immutable! Any change of a variable of type string creates a new string in which the result is stored. Therefore, operations that apply to strings return as a result a reference to the result.
It is possible to process strings without creating new objects in the memory every time a modification is made but for this purpose the class StringBuilder should be used. We will introduce it a bit later.
Strings Concatenation
Gluing two strings and obtaining a new one as a result is called concatenation. It could be done in several ways: through the method Concat(…) or with the operators + and +=.
Example of using the method Concat(…):
string greet = "Hello, ";
string name = "reader!";
string result = string.Concat(greet, name);
By calling the method, we will concatenate the string variable name, which is passed as an argument, to the string variable greet. The result string will be the text "Hello, reader!".
The second way for concatenation is via the operators + and +=. Then the above example can be implemented in the following way:
string greet = "Hello, ";
string name = "reader!";
string result = greet + name;
In both cases those variables will be presented in the memory as follows:
 
Please note that string concatenation does not change the existing strings but returns a new string as a result. If we try to concatenate two strings without storing them in a variable, the changes would not be saved. Here is a typical mistake:
string greet = "Hello, ";
string name = "reader!";
string.Concat(greet, name);
In the given example the two variables are concatenated but the result of it has not been saved anywhere, so it is lost:
If we want to add a value to an existing variable, for example the variable result, we can do it with the well-known code:
result = result + " How are you?";
In order to avoid the double writing of the above declared variable, we can use the operator +=:
result += " How are you?";
The result will be the same in both cases: "Hello, reader! How are you?".
We can concatenate other data with strings. Any data, which can be presented in a text form, can be appended to a string. Concatenation is possible with numbers, characters, dates, etc. Here is an example:
string message = "The number of the beast is: ";
int beastNum = 666;
string result = message + beastNum;
// The number of the beast is: 666
As we understood from the above example, there is no problem in concatenating strings with other data, which is not from a string type. Let’s have another full example for string concatenation:
public class DisplayUserInfo
{
	static void Main()
	{
		string firstName = "John";
		string lastName = "Smith";
		string fullName = firstName + " " + lastName;

		int age = 28;
		string nameAndAge = "Name: " + fullName + "\nAge: " + age;

		Console.WriteLine(nameAndAge);
	}
}
// Console output:
// Name: John Smith
// Age: 28
Switching to Uppercase and Lowercase Letters
Sometimes we need to change the casing of a string so that all the characters in it to be entirely uppercase or lowercase. The two methods that would work best in this case are ToLower(…) and ToUpper(…). The first converts all capital letters to small ones:
string text = "All Kind OF LeTTeRs";

Console.WriteLine(text.ToLower());
// all kind of letters
The example shows that all capital letters of the text change their casing and the entire text goes in lowercase. Such a shift to lowercase is convenient for storing usernames in various online systems. Upon registration the users may use a mixture of uppercase and lowercase letters, but the system can then make them all small to unify them and to avoid matches on points with differences in the casing.
Here is another example. We want to compare entered by the user input but we are not sure exactly how it was written – in small or capital letters or mixed. One possible approach is to standardize capitalization and compare it with the constant defined by us. Thus, we make no distinction of small and capital letters. For example, if we have a user input panel where we enter name and password and it does not matter if the password is written with capital letters or small, we can make a similar check on the password:
string pass1 = "PasswoRd";
string pass2 = "PaSSwoRD";
string pass3 = "password";

Console.WriteLine(pass1.ToUpper() == "PASSWORD");
Console.WriteLine(pass2.ToUpper() == "PASSWORD");
Console.WriteLine(pass3.ToUpper() == "PASSWORD");

// Console output:
// True
// True
// True
In the example we are comparing three passwords with the same content but with a different casing. When checking their contents, always verify if it equals to the string "PASSWORD" (letter by letter). Of course, we could do the above verification and by the method Equals(…) in the version with ignoring the character casing, which we already discussed.
Searching for a String within Another String
When we have a string with a specified content, it is often necessary to process only a part of its value. The .NET platform provides us with two methods to search a string within another string: IndexOf(…) and LastIndexOf(…). They search into the string and check whether the passed as a parameter substring occurs in its content. The result of those methods is an integer. If the result is not a negative value, then this is the position where the first character of the substring is found. If the method returns value of -1, it means that the substring was not found. Remember that in C# indexing into strings start from 0.
The methods IndexOf(…) and LastIndexOf(…) search the contents of the text sequence, but in a different direction. The search with the first method starts from the beginning of the string towards the end, while the second method – the search is done backwards. If we are interested in the first encountered match, then we use IndexOf(…). If we want to search the string from its end (for example to detect the last dot in a file name or the last slash in an URL address), then we use LastIndexOf(…).
When calling IndexOf(…) and LastIndexOf(…) a second parameter could be passed, which will specify the position, which the searching should start from. This is useful if we want to search part of a string, not the entire string.
Searching into a String – Example
Let’s consider an example with the IndexOf(…) method:
string book = "Introduction to C# book";
int index = book.IndexOf("C#");

Console.WriteLine(index);
// index = 16
In the example, the variable book has a value "Introduction to C# book". The search for the substring "C" in this variable will return the value 16, because the substring will be found and the first character "C" of the searched word is in 16th position.
Searching with IndexOf(…) – Example
Let’s look into great details one more example for searching for a separate characters or strings in a text:
string str = "C# Programming Course";

int index = str.IndexOf("C#"); // index = 0
index = str.IndexOf("Course"); // index = 15
index = str.IndexOf("COURSE"); // index = -1
index = str.IndexOf("ram");    // index = 7
index = str.IndexOf("r");      // index = 4
index = str.IndexOf("r", 5);   // index = 7
index = str.IndexOf("r", 10);  // index = 18
Look how the string we are searching looks like in the memory:
 
If we look at the results of the third search, we will note that the search for the word "COURSE" in the text returned a result of -1, i.e. no match has been found. Although the word is in the text, it has been written in a different case of letters. The methods IndexOf(…) and LastIndexOf(…) distinguish between uppercase and lowercase letters. If we want to ignore this difference, we can write text in a new variable and turn it to a text with entirely lower or entirely uppercase, and then we can perform the search in it, independently from the letters casing.
Finding All Occurrences of a Substring – Example
Sometimes we want to find all occurrences of a particular substring within another string. Using both methods with only one searched string passed as an argument would not work for us, because it will always return only the first occurrence of the substring. We can pass a second parameter for an index that indicates the starting position from which the searching should begin. Of course, we need to loop through it in order to move from the first occurrence of the searched string to the next, to the next, and the next, etc., until the last one.
Here is an example how we can use the method IndexOf(…) by a given word and start index: finding all occurrences of the word "C#" in a given text:
string quote = "The main intent of the \"Intro C#\"" +
	" book is to introduce the C# programming to newbies.";
string keyword = "C#";
int index = quote.IndexOf(keyword);

while (index != -1)
{
	Console.WriteLine("{0} found at index: {1}", keyword, index);
	index = quote.IndexOf(keyword, index + 1);
}
The first step is to make a search for the keyword "C#". If the word is found in the text (i.e. the returned value is different than -1), it prints it on the console and we continue our search rightwards, starting from the position on which we have found the word plus one. We repeat this operation until IndexOf(…) returns value -1.
Note: If we miss setting an initial index, then the search will always start from the beginning and will return one and the same value. This will lead to hanging of the program. If we search directly from the index without adding plus one each time, we will come across again and again to the last result, whose index we have already found. Therefore, proper search of the next result should start from a starting position index + 1.
Extracting a Portion of a String
For now we know how to check whether a substring occurs in a text and which are the occurrence positions. But how can we extract a portion of a string in a separate variable?
The solution of this problem is the method Substring(…). By using it, we can extract a part of the string (substring) by a given starting position in the text and its length. If the length is omitted, a portion from the text will be extracted, starting from the initial position to the string’s end.
Presented is an example of extracting a substring from a string:
string path = "C:\\Pics\\CoolPic.jpg";
string fileName = path.Substring(8, 7);
// fileName = "CoolPic"
We manipulate the variable path. It contains the path to a file from our file system. To assign the file name to a new variable, we use Substring(8, 7) and take a sequence of 7 characters starting from the 8th position, i.e. character positions from 8 to 14 inclusively.
 	Calling the method Substring(startIndex, length), extracts a substring from a string, which is located between startIndex and (startIndex + length – 1) inclusively. The character at the position startIndex + length is not taken into considera¬tion! For example, if we point Substring(8, 3), the characters between index 8 and 10 inclusively will be extracted.
Here are presented the characters, which form the text from which we extract a substring:
0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18
C	:	\	P	i	c	s	\	C	o	o	l	P	i	c	.	j	p	g
Sticking to the scheme, the method that has been called must write the characters from the positions 8 to 14 (as the last index is not included), namely "CoolPic".
Extracting a File Name and File Extension – Example
Let’s consider a more interesting task. How can we print the filename and its extension from given full path to a file in Windows-based file system? As we know how the path is recorded in the file system, we can proceed with the following plan:
	Looking for the last backslash in the text;
	Keeping the position of the last backslash;
	Extracting the substring starting from the obtained position +1;
Let’s consider again the example of the well-known file path. If we have no information about the exact contents of the variable, but we know that it contains a file path, we can stick to the above scheme:
string path = "C:\\Pics\\CoolPic.jpg";
int index = path.LastIndexOf("\\");
// index = 7
string fullName = path.Substring(index + 1);
// fullName = "CoolPic.jpg"
Splitting the String by a Separator
One of the most flexible methods for working with strings is Split(…). It allows us to split a string by a separator or an array of possible separators. For example, we can process a variable, which has the following content:
string listOfBeers = "Amstel, Heineken, Tuborg, Becks";
How can we split each beer in a separate variable or extract all beers in an array? At first glance it may seem difficult – we must seek with IndexOf(…) for a special character, then to extract a substring with Substring(…), to iterate all this in a loop and to write the result in a variable. Since the splitting of a string by a separator is a main task of text processing, ready to use methods for it can be found in .NET Framework.
Splitting Strings by Multiple Separators – Example
The easiest and more flexible method for resolving this issue is the following:
char[] separators = new char[] {' ', ',', '.'};
string[] beersArr = listOfBeers.Split(separators);
Using the built-in functionality of the method Split(…) from the class String, we will split the contents of a given string by array of characters – separators, which are passed as an argument of the method. All substrings among which are space, comma or dot will be removed and stored in the beersArr array.
If we iterate the array and print its elements one by one, the result will be: "Amstel", "", "Heineken", "", "Tuborg", "" and "Becks". We get 7 results, instead of the expected 4. The reason is that during the text splitting, three substrings are found which contain two separator characters one next to the other (for example a comma, followed by a space). In this case the empty string between the two separators is also part of the returned result.
How to Remove the Empty Elements after Splitting?
If we want to ignore the empty strings from the splitting results, one possible solution is to make checks on their printing:
foreach (string beer in beersArr)
{
	if (beer != "")
	{
		Console.WriteLine(beer);
	}
}
But this approach does not remove the empty strings from the array. It just does not print them. So we can change the arguments we are passing to the method Split(…), by passing a special option:
string[] beersArr = listOfBeers.Split(
	separators, StringSplitOptions.RemoveEmptyEntries);
After this change, the beersArr array will contain 4 elements – the 4 words from the listOfBeers variable.
 	When splitting strings and adding as a second parameter the constant StringSplitOptions.RemoveEmptyEntries we instruct the method Split(…) to work in the following way: "Return all substrings from the variable that are split by given list of separators. If you meet two or more neighboring separators, consider them as one."
Replacing a Substring
The text processing in .NET Framework provides ready methods for replacing a substring with another. For example, if we have made one and the same technical mistake when typing the email address of a user in an official document, we can replace it by using the method Replace(…):
string doc = "Hello, some@gmail.com, " +
	"you have been using some@gmail.com in your registration.";
string fixedDoc =
	doc.Replace("some@gmail.com", "john@smith.com");
Console.WriteLine(fixedDoc);

// Console output:
// Hello, john@smith.com, you have been using
// john@smith.com in your registration.
As it can be seen from the example, the method Replace(…) replaces all occurrences of a given substring with another substring, not just the first.
Regular Expressions
The regular expressions are a powerful tool for text processing and allow searching matches by a pattern. An example for a pattern is [A-Z0-9]+, which means not an empty series of capital Latin letters and numbers.
Regular expressions make text processing easier and more accurate: extracting some resources from texts, searching for phone numbers, finding email addresses in a text, splitting all the words in a sentence, data validation, etc.
Regular Expressions – Example
If we have an official document that is used only in the office and it contains a lot of personal data, then we should censor it before sending it to the client. For example, we can censor all mobile numbers and replace them with asterisks. By using regular expressions, this could be done as follows:
string doc = "Smith's number: 0898880022\nFranky can be " +
	"found at 0888445566.\nSteven's mobile number: 0887654321";
string replacedDoc = Regex.Replace(
	doc, "(08)[0-9]{8}", "$1********");
Console.WriteLine(replacedDoc);
// Console output:
// Smith's number: 08********
// Franky can be found at 08********.
// Steven' mobile number: 08********
Explaining the Arguments of Regex.Replace(…)
In the above code fragment by using a regular expression, we find all the phone numbers specified in the text and replace them by a pattern. We use the class System.Text.RegularExpressions.Regex, which is intended for use with regular expressions in .NET Framework. The variable, which imitates the document text, is doc. Several names of customers are recorded there. If we want to protect the contacts from an improper use and wish to censor the phone numbers, then we can replace all mobile phones with asterisks. Assuming that the phones are saved in the following format: "08 + 8 digits", the method Regex.Replace(…) finds all matches by a given format and replaces them with: "08********".
The regular expression that finds all of the numbers is the following: "(08)[0-9]{8}". It finds all substrings in the text, constructed by the constant "08" and followed exactly by 8 characters ranging from 0 to 9. The example can be further improved by selecting the numbers only from a given mobile operator, for phones on foreign networks, etc., but in this case we used the simplified version.
The literal "08" is surrounded by parentheses. They serve for forming a separate group in the regular expression. The groups can be used for handling only a certain part of the expression instead of the entire expression. In our example, the group is used in the substitution. Through it, the founded matches are replaced by the pattern "$1********", i.e. the text which was found in the first group of the regular expression ($1) + 8 consecutive asterisks for censorship. As the defined group is always a constant (08), so the text replaced will always be: 08 ********.
This chapter is not intended to explain in details how to use regular expressions in .NET Framework, as it is a huge and complex field, but only to turn the reader’s attention that the regular expressions exist and they are a powerful tool for text processing. Anyone who wants to learn more, can search for articles, books and tutorials in order to learn how to construct regular expressions, how to look for matches, how validation is made, how to make substitutions by patterns, etc. In particular, we recommend you to visit the websites http://www.regular-expressions.info and http://regexlib.com. More information about the classes in .NET Framework for working with regular expressions can be found at: http://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex%28VS.100%29.aspx.
Removing Unnecessary Characters at the Beginning and at the End of a String
When entering text in a file or to the console, you can find sometimes some "parasitic" spaces (white-space) at the beginning or at the end of the text – some other space or a tab that cannot be observed at first glance. This may not be essential but if we do not validate the user data, there would be a problem in terms of checking the contents of the input information. In order to solve this problem we can use the method Trim(). It is responsible for eliminating (trimming) the white spaces at the beginning or at the end of a string. The white spaces can be spaces, tabs, line breaks etc.
Let’s assume in the variable fileData we have read the contents of a file where is written a name of a student. There may have emerged parasitic spaces when writing the text or reversing it from one format to another. In that case the variable will look the following way:
string fileData = "   \n\n     David Allen      ";
If we print the contents to the console, we get two blank lines followed by some spaces, the requested name and some additional spaces at the end. We can reduce the information just to the required name, in the following way:
string reduced = fileData.Trim();
When we print the information to the console for the second time, the content will be "David Allen", without any unwanted white spaces.
Removing Unnecessary Characters by a Given List
The method Trim(…) can accept an array of characters, which we want to remove from the string. We can make it in the following way:
string fileData = "   111 $  %    David Allen  ### s   ";
char[] trimChars = new char[] {' ', '1', '$', '%', '#', 's'};
string reduced = fileData.Trim(trimChars);
// reduced = "David Allen"
Again, we get the desired result "David Allen".
 	Please note that we must list all the characters we want to eliminate, including the empty spaces (spaces, tabs, new line, etc.). Without a ' ' in the array trimChars, we would not get the desired result!
If we want to remove the white spaces only at the beginning or in end of the string, we can use the methods TrimStart(…) and TrimEnd(…):
string reduced = fileData.TrimEnd(trimChars);
// reduced = "   111 $  %    David Allen"
Constructing Strings: the StringBuilder Class
As explained above, strings in C# are immutable. This means that any adjustments applied to an existing string do not change it but return a new string. For example, using methods like Replace(…), ToUpper(…), Trim(…) do not change the string, which they are called for. They allocate a new area in the memory where the new content is saved. This behavior has many advantages but in some cases can cause performance problems.
Strings Concatenation in a Loop: Never Do This!
Serious performance problems may be encountered when trying to concatenate strings in a loop. The problem is directly related to the strings handling and dynamic memory, which is used to store them. To understand why we have poor performance when concatenating strings in a loop, we must first consider what happens when using operator "+" for strings.
How Does the String Concatenation Works?
We already got familiar with the ways to do string concatenation in C#. Let’s now examine what happens in memory when concatenating strings. Consider two variables str1 and str2 of type string, which have values of "Super" and "Star". There are two areas in the heap (dynamic memory) in which the values are stored. The task of str1 and str2 is to keep a reference to the memory addresses where our data is stored. Let’s create a variable result and give it a value of the other two strings by concatenation. A code fragment for creating and defining the three variables would look like this:
string str1 = "Super";
string str2 = "Star";
string result = str1 + str2;
What will happen with the memory? Creating the variable result will allocate a new area in dynamic memory, which will record the outcome of the str1 + str2, which is "SuperStar". Then the variable itself will keep the address of the allocated area. As a result we will have three areas in memory and three references to them. This is convenient, but allocating a new area, recording a value, creating a new variable and referencing it in the memory is time-consuming process that would be a problem when repeated many times, typically inside a loop.
Unlike other programming languages, in C# is not necessary to manually dispose the objects stored in memory. There is a special mechanism called a garbage collector (memory cleaning system), which takes care of clearing the unused memory and resources. The garbage collector is responsible for disposing of objects in dynamic memory when they are no longer used. Creation of many objects containing multiple references in dynamic memory is bad, because it fills memory and then the garbage collector is automatically enforced to start execution. It takes quite some time and slows the overall performance of the process. Furthermore, transferring characters from one place to another in memory (when string concatenation is executed) is slow, especially if the strings are long.
Why Concatenating Strings in a Loop is a Bad Practice?
Assume that we have a task to store the numbers from 1 to 20,000 consecutively to each other in a variable of type string. How can we solve the problem with our already existing knowledge? One of the easiest ways for implementation is to create a variable that stores the numbers and execute a loop from 1 to 20,000 in which each number is concatenated to the variable. Implemented in C#, the solution would look like this:
string collector = "Numbers: ";
for (int index = 1; index <= 20000; index++)
{
	collector += index;
}
Execution of the above code will loop 20,000 times and after each iteration will add the current index to the collector variable. collector’s value after implementation would be: "Numbers: 12345678910111213141516…" (the numbers from 17 to 20,000 are replaced with dots because we don’t have the space to write something that long here).
Probably you have not noticed the delay in the fragment’s execution. Indeed, using concatenation in the loop has delayed significantly the normal calculation process. On an average PC (as of January 2012) the loop iteration takes 1-2 seconds. The user of our program would be very skeptical if he has to wait a few seconds for something so simple such as concatenating the numbers from 1 to 20,000. Moreover, in this case 20,000 is just an example endpoint. What will be the delay if instead of 20,000 the user needs to concatenate numbers to 200,000? Try it!
Concatenating in Loop of 200,000 Iterations – Example
Let’s develop further the example above. First, we will change the endpoint of the loop from 20,000 to 200,000. Second, in order to account properly the execution time, we will display on the console the current date and time before and after execution of the loop. Third, to see whether the variable contains the desired value, we will also display part of it on the console. If you want to make sure that the whole value is stored, you can remove the method Substring(…), but the print itself in this case will take a long time.
The final version of the example would look like this:
class SlowNumbersConcatenator
{
	static void Main()
	{
		Console.WriteLine(DateTime.Now);

		string collector = "Numbers: ";
		for (int index = 1; index <= 200000; index++)
		{
			collector += index;
		}

		Console.WriteLine(collector.Substring(0, 1024));
		Console.WriteLine(DateTime.Now);
	}
}
When executing the example implementation on the console, the program starting date and time, the first 1024 characters of the variable and program completion date and time are displayed on the console. The reason to show only the first 1024 characters is that we want to measure only the calculation time without the time for printing the results. Printing the whole result will be time consuming. Let’s see sample output from the execution:
 
Program start is marked with a green line and its end – with red. Note the execution time – about 5-6 minutes (on our computer from January 2012)! Such a delay is unacceptable for such a task and will not only make the user nervous but will make him stop the program without waiting for it to end.
Processing Strings in the Memory
The problem with time-consuming Loop processing is related to the way strings work in memory. Each iteration creates a new object in the heap and point the reference to it. This process requires a certain physical time.
Several things happen at each step:
	An area of memory is allocated for recording the next number concatenation result. This memory is used only temporarily while concatenating, and is called a buffer.
	The old string is moved into the new buffer. If the string is long (say 500 KB, 5 MB or 50 MB), it can be quite slow!
	Next number is concatenated to the buffer.
	The buffer is converted to a string.
	The old string and the temporary buffer become unused. Later they are destroyed by the garbage collector. This may also be a slow operation.
Much more elegant and appropriate way to concatenate strings in a Loop is using the StringBuilder class. Let’s see how it works.
Building and Changing Strings with StringBuilder
StringBuilder is a class that serves to build and change strings. It overcomes the performance problems that arise when concatenating strings of type string. The class is built in the form of an array of characters and what we need to know about it is that the information in it can be freely changed. Changes that are required in the variables of type StringBuilder, are carried out in the same area of memory (buffer), which saves time and resources. Changing the content does not create a new object but simply changes the current.
Let’s rewrite the code above in which we concatenated strings in a loop. If you remember, the operation previously took 5 minutes. Let’s measure how long will take the same operation if we use StringBuilder:
class ElegantNumbersConcatenator
{
	static void Main()
	{
		Console.WriteLine(DateTime.Now);

		StringBuilder sb = new StringBuilder();
		sb.Append("Numbers: ");

		for (int index = 1; index <= 200000; index++)
		{
			sb.Append(index);
		}

		Console.WriteLine(sb.ToString().Substring(0, 1024));
		Console.WriteLine(DateTime.Now);
	}
}
This example is based on the previous one, with only minor adjustments. Return value is the same, but what about the execution time?
 
The time required to concatenate 200,000 characters with StringBuilder is now less than a second (perhaps few milliseconds)!
Reversing a String – Example
Consider another example: we want to reverse an existing string (backwards). For example, if we have the string "abcd", the returned result should be "dcba". We get the original string, iterate it backwards character by character and add each character to a variable of type StringBuilder:
public class WordReverser
{
	static void Main()
	{
		string text = "EM edit";
		string reversed = ReverseText(text);
		Console.WriteLine(reversed);

		// Console output:
		// tide ME
	}

	static string ReverseText(string text)
	{
		StringBuilder sb = new StringBuilder();
		for (int i = text.Length - 1; i >= 0; i--)
		{
			sb.Append(text[i]);
		}
		return sb.ToString();
	}
}
In this example we have a variable text, which contains the value "EM edit". We pass the variable to the ReverseText(…) method and set the new value in a variable named reversed. The method, in turn, iterates the charac¬ters of the variable in reverse order and stores them in a new variable of type StringBuilder, but now back ordered. Ultimately, the result is "tide ME".
How Does the StringBuilder Class Work?
The StringBuilder class is an implementation of a string in C#, but different than the class String. Unlike the already familiar for us strings, the objects of the StringBuilder class are not immutable, namely edit operations do not require creating a new object in the memory. This reduces the unnecessary transfer of data in memory when performing basic operations such as string concatenation.
StringBuilder keeps a buffer with a certain capacity (16 characters by default). The buffer is implemented as an array of characters that is provided to the developer by a user-friendly interface – methods that quickly and easily add and edit elements of the string. At any moment part of the characters in the buffer are used and the rest stay in reserve. This allows the addition to work very quickly. Other operations also operate faster than the class string, because the changes do not create a new object.
Once the internal buffer of the StringBuilder is full, it automatically is doubled (the internal buffer is resized to increase its capacity while its content is kept unchanged). Resizing is a slow operation but is happens rarely so the total performance is good. We will discuss this in more details in the chapter about "Algorithms Complexity".
Let’s create an object of the StringBuilder class with 15 characters long buffer. We add the string: "Hello, C#!" to it and we get the following code:
StringBuilder sb = new StringBuilder(15);
sb.Append("Hello, C#!");
After creating the object and storing the value in it, the StringBuilder will look as follows:
 
Colored elements are the filled with our content part of the buffer. Normally, adding a new character to the variable does not create a new object in the memory but use the already allocated and unused space. If the entire capacity of the buffer is filled, then the buffer is doubled as we already explained.
StringBuilder – More Important Methods
The StringBuilder class provides us with a set of methods that help us to easily and efficiently edit text data and construct text. We met some of them in the examples. The most important are:
	StringBuilder(int capacity) – constructor with an initial capacity parameter. It may be used to set the buffer size in advance if we have estimates of the number of iterations and concatenations, which will be performed. This way we can save unnecessary dynamic memory allocations.
	Capacity – returns the buffer size (total number of used and unused positions in the buffer).
	Length – returns length of string saved in the variable (number of used positions in the buffer)
	Indexer [int index] – return the character stored in given position.
	Append(…) – appends string, number or other value after the last character in the buffer.
	Clear(…) – removes all characters from the buffer (deletes it).
	Remove(int startIndex, int length) – removes (deletes) string from the buffer with a given start position and length.
	Insert(int offset, string str) – inserts a string in a given start position (offset).
	Replace(string oldValue, string newValue) – replaces all occurren¬ces of a given substring with another substring.
	ToString() – returns the StringBuilder object content as a string object.
Extracting All Capital Letters from a Text – Example
The next task is to extract all capital letters from a text. We can implement it in different ways – using an array, counter and filling the array with all capital letters found; creating an object of type string and concatenate capitals one by one to it; using the class StringBuilder.
Turning to the option of using an array, we have a problem: we do not know what will be array size, as we have no idea in advance how many are the capital letters in the text. We can create an array as large as the text, but thus wasting unnecessary space in memory and we must also maintain a counter that keeps where the array is full to.
Another option is to use a variable of type string. As we will iterate the whole text and concatenate all capital letters to the variable, probably we will lose efficiency again due to the strings concatenation.
StringBuilder: the Right Solution
The most viable solution to the task again is to use StringBuilder. We can start with an empty StringBuilder, iterate the letters of the given text character by character, verify that the current character is uppercase and concatenate the character at the end of our StringBuilder. Finally, we can return the final result by calling the ToString() method. Below is a sample implementation:
public static string ExtractCapitals(string str)
{
	StringBuilder result = new StringBuilder();
	for (int i = 0; i < str.Length; i++)
	{
		char ch = str[i];
		if (char.IsUpper(ch))
		{
			result.Append(ch);
		}
	}
	return result.ToString();
}
Calling ExtractCapitals(…) method and passing a specified text as a parameter to it, the return value is a string of all capital letters in the text, namely the initial string without all characters that are not capitalized. To check whether a character is uppercase we are using char.IsUpper(…) – a method from the standard .NET classes. You can view the char class documentation, because it offers other useful methods for handling characters.
String Formatting
.NET Framework provides the developer with mechanisms for formatting strings, numbers and dates. We have already met some of them in the chapter "Console Input and Output". Now we will extend our knowledge with methods for formatting and converting strings of the string class.
The ToString(…) Method
One of the interesting concepts in .NET is that practically every object of a class and primitive variables can be presented as text. This is done by the method ToString(…), which is present in all .NET objects. It is implicit in the definition of the object class – the base class that all .NET data types inherit directly or indirectly. Thus the definition of the method appears in each class and we can use it to bring the content of each object in some text form.
The method ToString(…) is called automatically when we print objects from different classes to the console. For example, when printing dates the submitted date is converted to text by calling the ToString(…):
DateTime currentDate = DateTime.Now;
Console.WriteLine(currentDate);
// Output: 01.02.2012 13:34:27 (depends on the culture settings)
When we pass currentDate as a parameter of the WriteLine(…) method, we don’t have an accurate statement that handles dates. The method has a particular implementation for all primitive types and strings. For all other objects WriteLine(…) calls their ToString(…) method, which first converts them to text and then displays the resulting text content. In fact, the sample code above is equivalent to the following:
DateTime currentDate = DateTime.Now;
Console.WriteLine(currentDate.ToString());
The default implementation of the ToString(…) method in the object class returns the full name of the class. All classes that do not explicitly redefine the behavior of the ToString(…) are using this implementation. Most classes in C# have their own implementation of the method, which represents readable and understandable content in text form. For example, converting a number to text is using the standard format for numbers in the current culture. Converting a date to text is also using the standard format for dates in the current culture.
Using of String.Format(…)
String.Format(…) is a static method by which we can format text and other data through a template (formatting string). The templates contain text and declared parameters (placeholders) and are used to obtain formatted text after replacing the parameters with specific values. You can make a direct association with the Console.WriteLine(…) method, which also formats a string through a template:
Console.WriteLine("This is a template from {0}", "David");
How to use the String.Format(…) method? Consider an example in order to clarify this:
DateTime date = DateTime.Now;
string name = "David Scott";
string task = "Introduction to C# book";
string location = "his office";

string formattedText = String.Format(
	"Today is {0:MM/dd/yyyy} and {1} is working on {2} in {3}.",
	date, name, task, location);
Console.WriteLine(formattedText);

// Output: Today is 01.02.2012 and David Scott is working on
// Introduction to C# book in his office.
As it is seen from the example, formatting with String.Format() uses placeholders (parameters like {0}, {1}, etc.) and accepts formatting strings (such as :dd.MM.yyyy). It accepts as first parameter a formatting string containing text with parameters, followed by values for each parameter and returns the formatted text as a result. More information about formatting strings can be found on the Internet and in the Composite Formatting article in MSDN (http://msdn.microsoft.com/en-us/library/txafckwd.aspx). Note that the exact formatting of the output could slightly vary depending on your default culture and internationalization.
Parsing Data
The reverse operation of data formatting is data parsing. Parsing of data (data parsing) means to obtain a value of a given type from the text representation of this value in a specific format, i.e. converting from text to some other data type, the opposite of ToString(). For example, from the text "10/22/2010" we can get an instance of DateTime type, containing the relevant date.
Often working with applications with graphical user interface requires the user input to be passed in variables of type string. This way we can work well with numbers and characters as well as text and dates, formatted in a user’s preferred way. It is up to the developer’s experience to represent the expected input data into the right way for the user. The data are then converted to a specific data type and processed. For example, numbers can be converted to int or double variables and then participate in mathematical expressions for calculations.
 	When converting types, we should not rely only on trusting the user. Always check the correctness of the input user data! Otherwise there could be an exception that could change the normal program logic.
Parsing Numeric Types
To parse a string to a number we can use the Parse(…) method of the primitive types. Let’s see an example of parsing a string to an integer value:
string text = "53";
int intValue = int.Parse(text);
// intValue = 53
We can also parse variables of Boolean type:
string text = "True";
bool boolValue = bool.Parse(text);
// boolValue = true
Return value is true, when the passed parameter is initialized (not an object with null value), and its content is "true" regardless of the casing of letters in it. For example, any text such as "true", "True" or "tRUe" will set the variable boolValue to true. If the parameter’s content is "false", no matter the casing of letters, the return value will be false. In all other cases it throws FormatException.
In case the passed to the Parse(…) method value is invalid for the type (e.g. we pass "John!" when parsing a number), an exception is thrown.
Parsing Dates
Parsing to a date is similar to parsing to a numeric type, but it is recommended to set a specific date format. Here is an example of how this can happen:
string text = "11/11/2001";
DateTime parsedDate = DateTime.Parse(text);
Console.WriteLine(parsedDate);
// 11-Nov-01 0:00:00 AM
Whether the date will be parsed successfully and in what format exactly it will be printed on the console depends strongly on the current culture of Windows. In the example, a modified version of the U.S. culture (en-US) is used. If we want to set a format explicitly, which does not depend on the culture, we can use the method DateTime.ParseExact(…) and specify particular formatting pattern of our choice:
string text = "11/12/2001";
string format = "MM/dd/yyyy";
DateTime parsedDate = DateTime.ParseExact(
	text, format, CultureInfo.InvariantCulture);
Console.WriteLine("Day: {0}\nMonth: {1}\nYear: {2}",
	parsedDate.Day, parsedDate.Month, parsedDate.Year);
// Day: 12
// Month: 11
// Year: 2001
When parsing with an explicitly set format, it is required to pass a specific culture from which to take information about date format and separators between days and years. Since we want the parsing not to depend on a particular culture, we explicitly specify the neutral culture to be used: CultureInfo.InvariantCulture. To use the class CultureInfo, we must include the namespace System.Globalization in the beginning of our C# source code.
Exercises
	Describe the strings in C#. What is typical for the string type? Explain which the most important methods of the string class are.
	Write a program that reads a string, reverse it and prints it to the console. For example: "introduction" ? "noitcudortni".
	Write a program that checks whether the parentheses are placed correctly in an arithmetic expression. Example of expression with correctly placed brackets: ((a+b)/5-d). Example of an incorrect expression: )(a+b)).
	How many backslashes you must specify as an argument to the method Split(…) in order to split the text by a backslash?
Example: one\two\three.
Note: In C# backslash is an escaping character.
	Write a program that detects how many times a substring is contained in the text. For example, let’s look for the substring "in" in the text:
We are living in a yellow submarine. We don't have anything else. Inside the submarine is very tight. So we are drinking all the day. We will move out of it in 5 days.
The result is 9 occurrences.
	A text is given. Write a program that modifies the casing of letters to uppercase at all places in the text surrounded by <upcase> and </upcase> tags. Tags cannot be nested.
Example:
We are living in a <upcase>yellow submarine</upcase>. We don't have <upcase>anything</upcase> else.
Result:
We are living in a YELLOW SUBMARINE. We don't have ANYTHING else.
	Write a program that reads a string from the console (20 characters maximum) and if shorter complements it right with "*" to 20 characters.
	Write a program that converts a given string into the form of array of Unicode escape sequences in the format used in the C# language. Sample input: "Test". Result: "\u0054\u0065\u0073\u0074".
	Write a program that encrypts a text by applying XOR (excluding or) operation between the given source characters and given cipher code. The encryption should be done by applying XOR between the first letter of the text and the first letter of the code, the second letter of the text and the second letter of the code, etc. until the last letter of the code, then goes back to the first letter of the code and the next letter of the text. Print the result as a series of Unicode escape characters \xxxx.
Sample source text: "Test". Sample cipher code: "ab". The result should be the following: "\u0035\u0007\u0012\u0016".
	Write a program that extracts from a text all sentences that contain a particular word. We accept that the sentences are separated from each other by the character "." and the words are separated from one another by a character which is not a letter. Sample text:
We are living in a yellow submarine. We don't have anything else. Inside the submarine is very tight. So we are drinking all the day. We will move out of it in 5 days.
Sample result:
We are living in a yellow submarine.
We will move out of it in 5 days.
	A string is given, composed of several "forbidden" words separated by commas. Also a text is given, containing those words. Write a program that replaces the forbidden words with asterisks. Sample text:
Microsoft announced its next generation C# compiler today. It uses advanced parser and special optimizer for the Microsoft CLR.
Sample string containing the forbidden words: "C#,CLR,Microsoft".
Sample result:
********* announced its next generation ** compiler today. It uses advanced parser and special optimizer for the ********* ***.
	Write a program that reads a number from console and prints it in 15-character field, aligned right in several ways: as a decimal number, hexadecimal number, percentage, currency and exponential (scientific) notation.
	Write a program that parses an URL in following format:
[protocol]://[server]/[resource]
It should extract from the URL the protocol, server and resource parts. For example, when http://www.cnn.com/video is passed, the result is:
[protocol]="http"
[server]="www.cnn.com"
[resource]="/video"
	Write a program that reverses the words in a given sentence without changing punctuation and spaces. For example: "C# is not C++ and PHP is not Delphi" ? "Delphi not is PHP and C++ not is C#".
	A dictionary is given, which consists of several lines of text. Each line consists of a word and its explanation, separated by a hyphen:
.NET – platform for applications from Microsoft
CLR – managed execution environment for .NET
namespace – hierarchical organization of classes
Write a program that parses the dictionary and then reads words from the console in a loop, gives an explanation for it or writes a message on the console that the word is not into the dictionary.
	Write a program that replaces all hyperlinks in a HTML document consisting of <a href="…">…</a> and hyperlinks in "forum" style, which look like [URL=…]…[/URL].
Sample text:
<p>Please visit <a href="http://softuni.org">our site</a> to choose a training course. Also visit <a href= "http://forum.softuni.org">our forum</a> to discuss the courses.</p>
Sample result:
<p>Please visit [URL=http://softuni.org]our site[/URL] to choose a training course. Also visit [URL= http://forum.softuni.org]our forum[/URL] to discuss the courses.</p>
	Write a program that reads two dates entered in the format "day.month.year" and calculates the number of days between them.
Enter the first date: 27.02.2006
Enter the second date: 3.03.2006
Distance: 4 days
	Write a program that reads the date and time entered in the format "day.month.year hour:minutes:seconds" and prints the date and time after 6 hours and 30 minutes in the same format.
	Write a program that extracts all e-mail addresses from a text. These are all substrings that are limited on both sides by text end or separator between words and match the shape <sender>@<host>…<domain>. Sample text:
Please contact us by phone (+001 222 222 222) or by email at example@gmail.com or at test.user@yahoo.co.uk. This is not email: test@test. This also: @gmail.com. Neither this: a@a.b.
Extracted e-mail addresses from the sample text:
example@gmail.com
test.user@yahoo.co.uk
	Write a program that extracts from a text all dates written in format DD.MM.YYYY and prints them on the console in the standard format for Canada. Sample text:
I was born at 14.06.1980. My sister was born at 3.7.1984. In 5/1999 I graduated my high school. The law says (see section 7.3.12) that we are allowed to do this (section 7.4.2.9).
Extracted dates from the sample text:
14.06.1980
3.7.1984
	Write a program that extracts from a text all words which are palindromes, such as ABBA", "lamal", "exe".
	Write a program that reads a string from the console and prints in alphabetical order all letters from the input string and how many times each one of them occurs in the string.
	Write a program that reads a string from the console and prints in alphabetical order all words from the input string and how many times each one of them occurs in the string.
	Write a program that reads a string from the console and replaces every sequence of identical letters in it with a single letter (the repeating letter). Example: "aaaaabbbbbcdddeeeedssaa" ? "abcdedsa".
	Write a program that reads a list of words separated by commas from the console and prints them in alphabetical order (after sorting).
	Write a program that extracts all the text without any tags and attribute values from an HTML document.
Sample text:
<html>
	<head><title>News</title></head>
	<body><p><a href="http://softuni.org">Software
		University</a>aims to provide free real-world practical
		training for young people who want to turn into
		skillful software engineers.</p></body>
</html>
Sample result:
News
Software University aims to provide free real-world practical training for young people who want to turn into skillful software engineers.
Solutions and Guidelines
	Read in MSDN or refer to the start of this chapter.
	Use StringBuilder and for (or foreach) loop.
	Use counting of the brackets: For an opening bracket increase the counter by 1 and for closing bracket decrease it by 1. Watch the counter not to become a negative number and always ends with 0.
	If you do not know how many slashes you must use, try Split(…) with an increasing number of slashes until you reach the desired result.
	Reverse the casing of letters in text to small and search the given substring in a loop. Remember to use IndexOf(…) with a start index in order to avoid infinite loop.
	Use regular expressions or IndexOf(…) method for opening and closing tag. Calculate the start and end index of the text. Change the text in all capital letters and replace the entire substring opening tag + text + closing tag with the text in uppercase.
	Use the PadRight(…) method from the String class.
	Use format string "\u{0:x4}" for the Unicode character code for each character of the input string (you can get it by converting char to ushort).
	Let the cipher cipher consists of cipher.Length letters. Iterate through all letters in the text and encrypt the letter at position index in the text with cipher[index % cipher.Length]. If you have a letter from the text and letter from the cipher, we can perform XOR operation between them by transforming in advance the two letters into numbers of type ushort. We can print the result with "\u{0:x4}" format string.
	First split the sentences from each other by using the Split(…) method. Then make sure that each sentence contains the searched word by searching for it as a substring with IndexOf(…) and if you find it check whether there is a separator (character, which is not a letter or start / end of the string) on the left and on the right of the found substring.
	First, split the forbidden words with the method Split(…) in order to get them as an array. For each forbidden word, iterate through the text and search for an occurrence. If a forbidden word is found, replace it with as many asterisks as letters contained in the forbidden word.
Another, easier approach is to use RegEx.Replace(…) with a suitable regular expression and a suitable MatchEvaluator method.
	Use appropriate formatting strings.
	Use a regular expression or search for the respective splitters – two slashes for a protocol and one slash as a separator between the server and the resource. Test the special cases like missing parts of the URL.
	You can solve the problem in two steps: reverse the input string; reverse each word in the result string.
Another interesting approach is to split the input text by punctuation marks between words, in order to get just the words of the text and then split by the letters to get the punctuation marks of the text. Thus, given a list of words and a list of punctuation marks between them, you can easily reverse the words, preserving the punctuation marks.
	You can parse the text by splitting it by the new line character, then a second time by the "-" character. The most appropriate way to record the dictionary is in a hash table (Dictionary<string, string>), which will provide a quick search for a given word. Read on the Internet for hash-tables and the Dictionary<K,T> class. You might also check the chapter "Dictionaries, hash-Tables and Sets".
	Using a regular expression is the easiest way to solve the task.
If you still choose not to use regular expressions, you can find all substrings that start with "<a href=" and end with "</a>" and within them to replace "<a href="" with "[URL=", then the first found "">" with "]" and then "</a>" with "[/URL]".
	Use the methods in the DateTime structure. For parsing the dates you can use splitting by "." or parsing with the DateTime.ParseExact(…) method.
	Use the DateTime.ToString() and DateTime.ParseExact() methods with suitable formatting strings.
	Use RegEx.Match(…) with an appropriate regular expression.
If you want to solve the task without regular expressions, you will need to process the text letter by letter from start to finish and process the next character, depending on the current mode, which can be one of OutsideOfEmail, ProcessingSender or ProcessingHostOrDomain. If a separator or the end of the text is reached and host or domain is processed (mode ProcessingHostOrDomain), then you have found an e-mail, otherwise potentially a new e-mail is starting and mode must be changed to ProcessingSender. If @ character is reached in ProcessingSender mode, ProcessingSender is switched on. When meeting letters or dot in ProcessingSender or ProcessingHostOrDomain mode, they ate accumulated in a buffer. You can look at all possible groups of characters encountered respectively in each of the three modes and process them appropriately. We come to something like a final automaton (state machine), which detects e-mail addresses. All found e-mail addresses must be checked whether they have nonempty recipient, host, and domain with a length between 2 and 4 letters, as well as not beginning or ending with a dot.
Another easier approach to this problem is to split the text by all characters that are not letters and dots and to verify that the extracted "words" are valid e-mail addresses. Check can be done through an attempt to split them to nonempty parts: <sender>, <host>, <domain>, meeting the listed conditions.
	Use RegEx.Match(…) with an appropriate regular expression. Alternative option is to implement a state-machine that has several states OutOfDate, ProcessingDay, ProcessingMonth, ProcessingYear and while processing the text letter by letter to move between states according to the current letter which you are processing. As in the previous task, you can extract all "words" from the text in advance and then check which ones correspond to the date template.
	Split the text into words and check whether each word is a palindrome.
	Use an array of integers int[65536], which will keep how many times each letter occurs. Initially, all array elements are zeros. After processing the input string letter by letter you can write in the array how many times each letter occurs. For example, if you meet the letter 'A', the number of occurrences in the array index of 65 (Unicode code 'A') will increase by one. Finally, all non-zero elements (convert array index to char, to get the letter) and their number of occurrences can be printed with one scan of the array.
	Use a hash table (Dictionary<string, int>) which keeps how many times each word occurs in the input string. Read on the Internet for class System.Collections.Generic.Dictionary<K,T>. With iteration through words you can accumulate information for each word occurrences in the hash table and with hash table iteration you can print the result.
	You can scan text from left to right and when the current letter is identical with the previous one, miss it, but otherwise concatenate it in StringBuilder.
	Use the static method Array.Sort(…) after parsing the input text into array of strings.
	Scan the text letter by letter and at all times keep in a variable whether currently there is an opening tag which has not been closed or not. If you have "<", enter in "opening tag" mode. If you have ">", exit the "opening tag" mode. If you have a letter, add it to the result only if the program is not in "opening tag". After closing a tag you can add a space in order not to "stick" the text before and after the tag.

	

Chapter 15. Text Files

In This Chapter
In this chapter we will review how to work with text files in C#. We will explain what a stream is, what its purpose is, and how to use it. We will explain what a text file is and how can you read and write data to a text file and how to deal with different character encodings. We will demonstrate and explain the good practices for exception handling when working with files. All of this will be demonstrated with many examples in this chapter.
Streams
Streams are an essential part of any input-output library. You can use streams when your program needs to "read" or "write" data to an external data source such as files, other PCs, servers etc. It is important to say that the term input is associated with reading data, whereas the term output is associated with writing data.
What Is a Stream?
A stream is an ordered sequence of bytes, which is send from one application or input device to another application or output device. These bytes are written and read one after the other and always arrive in the same order as they were sent. Streams are an abstraction of a data communication channel that connects two devices or applications.
Streams are the primary means of exchanging information in the computer world. Because of streams, different applications are able to access files on the computer and are able to establish network communication between remote computers. In the world of computers, many operations can be interpreted as reading and writing to a stream. For example, printing is a process of sending a sequence of bytes to a stream, associated with the corresponding port, to which is the printer connected. Recreating sounds from the computer’s sound card can be done by sending some commands, followed by the sample sound, which is actually a sequence of bytes. The scanning of documents from a scanner can be done by sending commands to the scanner (an output stream) and then reading the scanned image (an input stream). This way, you can work with any peripheral device (camera, mouse, keyboard, USB stick, soundcard, printer, scanner etc.).
Every time when you read or write from or to a file, you have to open a stream to the corresponding file, do the reading or writing, and then close the stream. There are two types of streams – text streams and binary streams but this separation has to do with the interpretation of the sent and received bytes. Sometimes, for convenience, a sequence of bytes can be treated as text (in a predefined encoding) and is referred to as a text stream.
Today’s modern web sites cannot do without the so-called streaming, which represents stream access to bulky multimedia files coming from the Internet. Streaming audio and video allows files to be played before they are downloaded locally, making the site more interactive. Streams and media streaming are different concepts but both use sequences of data.
Basic Things You Need to Know about Streams
Many devices use streams for reading and writing data. Because of streams, communication between program and file, program and remote computer, is made easy.
Streams are ordered sequences of bytes. The word "order" is intentionally left stressed, because it is of great importance to remember that streams are highly ordered and organized. In no way must you influence the order of the information flow, because it will render it unusable. If a byte is sent to a stream earlier than another byte, it will arrive earlier at the other end of the stream, which is guaranteed by the abstraction "stream".
Streams allow sequential data access. Again, it is important to understand the meaning of the word sequential. You can manipulate the data only in the order in which it arrives from the stream. This is closely related to the previous feature. You cannot take the first, than the eight, third, thirteenth byte and so on. Streams do not allow random access to their data, only sequential. You can think of streams as of a linked list that contains bytes, in which they have a strict order.
Different situations require different types of streams. Some streams are used with text files, others-with binary files and then there are those that work with strings. For network communication, you have to use a specific type of stream. The vast variety of streams can help us in different situations, but can also trouble us, because we need to be familiar with every type of stream, before we can use it in our application.
Streams are opened before we can begin working with them and are closed after they have served their purpose. Closing the stream is very important and must not be left out, because you risk losing data, damaging the file, to which the stream is opened, and so on – all of these are very troublesome scenarios, which must not happen in our programs.
We can say that streams are like pipes that connect two points:
 
From one side we pour data in and from the other data leaks out. The one who pours data is not concerned of how it is transferred, but can be sure that what he has poured will come out the same on the other side. Those who use streams do not care how the data reaches them. They know that if someone poured something on the other side, it will reach them. Therefore, we can consider streams as a data transport channel, such as pipes.
Basic Operations with Streams
You can do the following operations with streams: creation / opening, reading data, writing data, seeking / positioning, closing / disconnecting.
Creation
To create or open a stream means to connect the stream to a data source, a mechanism for data transfer or another stream. For example, when we have a file stream, then we pass the file name and the file mode in which it is to be opened (reading, writing or reading and writing simultaneously).
Reading
Reading means extracting data from the stream. Reading is always performed sequentially from the current position of the stream. Reading is a blocking operation, and if the other party has not sent data while we are trying to read or the sent data has not yet arrived, there may occur a delay – a few milliseconds to hours, days or greater. For example, when reading from a network stream data can be slowed down because of the network or the other party might not have send any data.
Writing
Writing means sending data to the stream in a specific way. The writing is performed from the current position of the stream. Writing may be a potentially blocking operation, before the data is sent on its way. For example, if you send bulk data via a network stream, the operation may be delayed while the data is traveling over the network.
Positioning
Positioning or seeking in the stream means to move the current position of the stream. Moving is done according to the current position, where we can position according to the current position, beginning of the stream, or the end of the stream. Moving can be done only in streams that support positioning. For example, file streams typically maintain positioning while network streams do not.
Closing
To close or disconnect a stream means to complete the work with the stream and releases the occupied resources. Closing must take place as soon as possible after the stream has served its purpose, because a resource opened by a user, usually cannot be used by other users (including other programs on the same computer that run parallel to our program).
Streams in .NET – Basic Classes
In .NET Framework classes for working with streams are located in the namespace System.IO. Let’s focus on their hierarchy, organization and functionality.
We can distinguish two main types of streams – those who work with binary data and those who work with text data. Later we will discuss the main characteristics of these two types.
At the top of the stream hierarchy stands an abstract input-output stream class. It cannot be instantiated, but defines the basic functionality that all the other streams have.
There are buffered streams that do not add any extra functionality, but use a buffer for reading and writing data, which significantly enhances performance. Buffered streams will not be analyzed in this chapter, as we will focus on working with text files. You can check with the rich documentation available on the Internet or a textbook for advanced programming.
Some streams add additional functionality to reading and writing data. For example, there are streams that compress / decompress data sent to them and streams that encrypt / decrypt data. These streams are connected to another stream (such as file or network stream) and add additional processing to its functionality.
The main classes in the System.IO namespace are Stream (abstract base class for all streams in .NET Framework), BufferedStream, FileStream, MemoryStream, GZipStream and NetworkStream. We will discuss in more details some of them, separating them in their basic feature – the type of data with which they work.
All streams in C# are similar in one basic thing – it is mandatory to close them after we have finished working with them. Otherwise we risk damaging the data in the stream or file that we have opened. This brings us to the first and basic rule that we should always remember when working with streams:
 	Always close the streams and files you work with! Leaving an open stream or file leads to loss of resources and can block the work of other users or processes in your system.
Binary and Text Streams
As we mentioned earlier, we can divide the streams into two large groups according to the type of data that we deal with – binary streams and text streams.
Binary Streams
Binary streams, as their name suggests, work with binary (raw) data. You probably guess that that makes them universal and they can be used to read information from all sorts of files (images, music and multimedia files, text files etc.). We will take a brief look over them, because we will currently focus on working with text files.
The main classes that we use to read and write from and to binary streams are: FileStream, BinaryReader and BinaryWriter.
The class FileStream provides us with various methods for reading and writing from a binary file (read / write one byte and a sequence of bytes), skipping a number of bytes, checking the number of bytes available and, of course, a method for closing the stream. We can get an object of that class by calling him his constructor with parameter-a file name.
The class BinaryWriter enables you to write primitive types and binary values in a specific encoding to a stream. It has one main method – Write(…), which allows recording of any primitive data types – integers, characters, Booleans, arrays, strings and more.
BinaryReader allows you to read primitive data types and binary values recorded using a BinaryWriter. Its main methods allow us to read a character, an array of characters, integers, floating point, etc. Like the previous two classes, we can get on object of that class by calling its constructor.
Text Streams
Text streams are very similar to binary, but only work with text data or rather a sequence of characters (char) and strings (string). Text streams are ideal for working with text files. On the other hand, this makes them unusable when working with any binaries.
The main classes for working with text streams in .NET are TextReader and TextWriter. They are abstract classes, and they cannot be instantiated. These classes define the basic functionality for reading and writing for the classes that inherit them. Their more important methods are:
	ReadLine() – reads one line of text and returns a string.
	ReadToEnd() – reads the entire stream to its end and returns a string.
	Write() – writes a string to the stream.
	WriteLine() – writes one line of text into the stream.
As you know, the characters in .NET are Unicode characters, but streams can also work with Unicode and other encodings like the standard encoding for Cyrillic languages Windows-1251.
The classes, to which we will turn our attention to in this chapter, are StreamReader and StreamWriter. They directly inherit the TextReader and TextWriter classes and implement functionality for reading and writing textual information to and from a file.
To create an object of type StreamReader or StreamWriter, we need a file or a string, containing the file path. Working with these classes, we can use all of the methods that we are already familiar with, to work with the console. Reading and writing to the console is much like reading and writing respectively with StreamReader and StreamWriter.
Relationship between Text and Binary Streams
When writing text, hidden from us, the class StreamWriter transforms the text into bytes before recording it at the current position in the file. For this purpose, it uses the character encoding, which is set during its creation. The StreamReader class works similarly. It uses StringBuilder internally and when reading binary data from a file, it converts the received bytes to text before sending the text back as a result from reading.
Remember that the operating systems have no concept of "text file". The file is always a sequence of bytes, but whether it is text or binary depends on the interpretation of these bytes. If we want to look at a file or a stream as text, we must read and write to it with text streams (StreamReader or StreamWriter), but if we wish to treat it as binary, we must read and write with a binary stream (FileStream).
Bear in mind that text streams work with text lines, that is, they interpret binary data as a sequence of text lines, separated from each other with a new line separators.
The character for the new line is not the same for different platforms and operating systems. For UNIX and Linux it is LF (0x0A), for Windows and DOS it is CR + LF (0x0D + 0x0A), and for Mac OS (up to version 9) it is CR (0x0A). Reading one line of text from a given file or a stream means reading a sequence of bytes until reading one of the characters CR or LF and converting these bytes to text according to the encoding, used by the stream. Similarly, writing one line of text to a text file or stream means writing the binary representation of the text (according to the current encoding), followed by the character (or characters) for a new line for the current operating system (such as CR + LF).
Reading from a Text File
Text files provide the ideal solution for reading and writing data. If we want to enter some data automatically (instead by hand), we could read it from a text files. So now, we will take a look at how to read and write text files with the classes from .NET Framework and the C# language.
StreamReader Class for Reading a Text File
C# provides several ways to read files but not all are easy and intuitive to use. This is why we will use the StreamReader class. The System.IO.
StreamReader class provides the easiest way to read a text file, as it resembles reading from the console, which by now you have probably mastered to perfection.
Having read everything until now, you are probably a bit confused. We already explained that reading and writing to and from text files is only and exclusively possible with streams, but StreamReader did not appear anywhere in the above-mentioned streams and you are not sure whether it is actually a stream. Indeed, StreamReader is not a stream, but it can work with streams. It provides the easiest and comprehensive way to read from a text file.
Opening a Text File for Reading
You can simply create a StreamReader from a filename (or full file path), which greatly eases us and reduces the probability of an error. On its creation, we can specify the character encoding. Here is an example of how an object of the class StreamReader can be created:
// Create a StreamReader connected to a file
StreamReader reader = new StreamReader("test.txt");

// Read the file here …

// Close the reader resource after you've finished using it
reader.Close();
The first thing to do, when reading from a text file, is to create a variable of type StreamReader, which we can associate with a specific file from the file system on our computer. To do this we need only pass the file path as a parameter to the constructor. Note that if the file is located in the folder where the compiled project (subdirectory bin\Debug) is, we can only provide its filename. Otherwise, we have to provide the full file path or relative path.
The code in the above example that creates an object of type StreamReader can cause an error. For now, simply pass a path to an existing file, and later on we will turn to the handling of errors when working with files.
Full and Relative Paths
When working with files we can use full paths (e.g. C:\Temp\example.txt) or relative paths, to the directory from which the application was started (e.g. ..\..\example.txt).
If you use full paths, where you pass the full path to a file, do not forget to apply escaping of slashes, which is used to separate the folders. In C# you can do this in two ways – with a double slash or with a quoted string beginning with @ before the string literal. For example, to enroll the path to the file "C:\Temp\work\test.txt" in a string we have two options:
string fileName = "C:\\Temp\\work\\test.txt";
string theSamefileName = @"C:\Temp\work\test.txt";
Although the use of relative paths is more difficult because you have to take into account the directory structure of your project which may change during the life of the project, it is highly recommended avoiding full paths.
 	Avoid full file paths and work with relative paths! This makes your application portable and easy for installation and maintenance.
Using the full path to a file (e.g. C:\Temp\test.txt) is bad practice because it makes your application dependent on the environment and also non-transferable. If you transfer it to another computer, you will need to correct paths to the files, which it seeks, to work correctly. If you use a relative path to the current directory (e.g. ..\..\example.txt), your program will be easily portable.
 	Remember that when you start the C# program, the current directory is the one, in which the executable (.exe) file is located. Most often this is the subdirectory bin\Debug or bin\Release directory to the root of the project. Therefore, to open the file example.txt from the root directory of your Visual Studio project, you should use a relative path ..\..\example.txt.
Universal Relative to Physical Path Resolver
If you want to write a portable application, you might benefit of Nakov’s universal path resolver: http://www.nakov.com/blog/2009/07/14/universal-relative-to-physical-path-resolver-for-console-wpf-and-aspnet-apps/. It can automatically resolve a relative path to full (physical) file path in Web, desktop, console or other .NET application. For example, if your application consists of an assembly App.exe and a file logo.gif and these files are located in the same directory, at runtime you will be able to get the physical location of logo.gif through the following code:
string logoPath =
	UniversalFilePathResolver.ResolvePath(@"~\logo.gif");
Reading a Text File Line by Line – Example
Now, we have learned how to create StreamReader. We can go further by trying to do something more complicated: to read the entire text file line by line and print the read text on to the console. Our advice is to create the text file in the Debug folder of the project (.\bin\Debug), so that it will be in the same directory in which your compiled application will be and you will not have to set the full path to it when opening the file. Let’s see what our file looks like:
Sample.txt
This is our first line.
This is our second line.
This is our third line.
This is our fourth line.
We have a text file from which to read. Now we must create an object of type StreamReader to read the file and loop though it line by line:
FileReader.cs
class FileReader
{
	static void Main()
	{
		// Create an instance of StreamReader to read from a file
		StreamReader reader = new StreamReader("Sample.txt");

		int lineNumber = 0;

		// Read first line from the text file
		string line = reader.ReadLine();

		// Read the other lines from the text file
		while (line != null)
		{
			lineNumber++;
			Console.WriteLine("Line {0}: {1}", lineNumber, line);
			line = reader.ReadLine();
		}

		// Close the resource after you've finished using it
		reader.Close();
	}
}
There is nothing difficult to read text files. The first part of our program is already well known – create a variable of type StreamReader, to whose constructor we pass the file’s name, which will be read. The parameter of the constructor is the path to the file, but since our file is found in the Debug directory of the project, we set only its name as a path. If our file were located in the project directory, then we would have submitted the string – "..\..\Sample.txt" as a path.
After that, we create a variable – counter, whose purpose is to count and display on which row of the file we are currently located.
Then, we create a variable that will store each read line. With its creation, we directly read the first line of text file. If the text file is empty, the method ReadLine() of the StreamReader object will return null.
For the main part – reading the file line by line, we will use a while loop. The condition for the loop is: as long as there is something in the variable line, we should continue reading. In the body of the loop, our task is to increase the value of the counter variable by one and then print the current line in the format we like. Finally, again we use ReadLine() to read the next line in the file and write it in the variable line. For printing, we use a method that is well known to us from the tasks, which required something to be printed on to the console – WriteLine().
Once we have read everything we need from the file, we should not forget to close the object StreamReader, as to avoid loss of resources. For this, we use the method Close().
 	Always close the StreamReader instances after you finish working with them. Otherwise you risk losing system resources. Use the method Close() or the statement using.
The result of the program should look like this:
Line 1: This is our first line.
Line 2: This is our second line.
Line 3: This is our third line.
Line 4: This is our fourth line.
Automatic Closing of the Stream after Working with It
As noted in the previous example, having finished working with the object of type StreamReader, we called Close() and closed the stream behind the StreamReader object. Very often, however, novice programmers forget to call the Close() method, thus blocking the file they use. Also in case of runtime exception when reading from a file, the file might be left open. This causes resource leakage and can lead to very unpleasant effects like program hanging, program misbehavior and strange errors.
The correct way to handle the file closing is though the using keyword:
using (<stream object>) { … }
The C# construct using(…) ensures that after leaving its body, the method Close() will automatically be called. This will happen even if an exception occurs when reading the file.
Now let’s rework the previous example to benefit from the using construct:
FileReader.cs
class FileReader
{
	static void Main()
	{
		// Create an instance of StreamReader to read from a file
		StreamReader reader = new StreamReader("Sample.txt");

		using (reader)
		{
			int lineNumber = 0;

			// Read first line from the text file
			string line = reader.ReadLine();

			// Read the other lines from the text file
			while (line != null)
			{
				lineNumber++;
				Console.WriteLine("Line {0}: {1}", lineNumber, line);
				line = reader.ReadLine();
			}
		}
	}
}
Now the code guarantees that once opened successfully, the text file will be closed correctly regardless of whether reading from it will succeed or fail.
If you are wondering how it is best to take care of closing your program’s streams and files, follow the following rule:
 	Always use the using construct in C# in order to properly close files and streams!
File Encodings. Reading in Cyrillic
Let’s now consider the problems that occur when reading a file using an incorrect encoding, such as reading a file in Cyrillic.
Character Encodings
You know that in memory everything is stored in binary form. This means that it is necessary for text files to be represented digitally, so that they can be stored in memory, as well as on the hard disk. This process is called encoding files or more correctly encoding the characters stored in text files.
The encoding process consists of replacing the text characters (letters, digits, punctuation, etc.) with specific sequences of binary values. You can imagine this as a large table in which each character corresponds to a certain value (sequence of bytes).
We already know the concept of character encodings and few character encoding schemes like UTF-8 and Windows-1251 from the section "Encoding Schemes" of chapter "Numeral Systems and Data Representation" and also from the section about "File Encodings in Visual Studio" of chapter "Defining Classes". Now we will extend this concept a bit and will use character encodings to work correctly with text files.
Character encodings specify the rules for converting from text to sequence of bytes and vice versa. An encoding scheme is a table of characters along with their numbers, but may also contain special rules. For example, the character "accent" (U + 0300) is special and sticks to the last character that precedes it. It is encoded as one or more bytes (depending on the character encoding scheme), and it does not correspond to any character, but to a part of the character. We will take a look at two encodings that are used most often when working with Cyrillic: UTF-8 and Windows-1251.
UTF-8 is a universal encoding scheme, which supports all languages and alphabets in the world. In UTF-8 the most commonly used characters (Latin alphabet, numerals and special characters) are encoded in one byte, rarely used Unicode characters (such as Cyrillic, Greek and Arabic) are encoded in two bytes and all other characters (Chinese, Japanese and many others) are encoded in 3 or 4 bytes. UTF-8 encoding can convert any Unicode text in binary form and back and support all of the 100,000 characters of Unicode standard. UTF-8 encoding is universal and suitable for any language alphabet.
Another commonly used encoding is Windows-1251, which is usually used for encoding of Cyrillic texts (such as messages sent by e-mail). It contains 256 characters, including the Latin alphabet, Cyrillic alphabet and some commonly used signs. It uses one byte for each character, but at the expense of some characters that cannot be stored in it (as the Chinese alphabet characters), and are lost in an attempt of doing so.
Other examples of encoding schemes (encodings or charsets) are ISO 8859-1, Windows-1252, UTF-16, KOI8-R, etc. They are used in specific regions of the world and define their own sets of characters and rules for the transition from text to binary data and vice versa.
For working with encodings (charsets) in .NET Framework, the class System.Text.Encoding is used, which is created the following way:
Encoding win1251 = Encoding.GetEncoding("Windows-1251");
Reading a Cyrillic Content
You probably already guessed that if we want to read from a file that contains characters from the Cyrillic alphabet, we must use the correct encoding that "understands" correctly these special characters. Typically, in a Windows environment, text files, containing Cyrillic text, are stored in Windows-1251 encoding. To use it, we should set it as the encoding of the stream, which our StreamReader will process:
Encoding win1251 = Encoding.GetEncoding("Windows-1251");
StreamReader reader = new StreamReader("test.txt", win1251);
If you do not explicitly set the encoding scheme (encoding) for the file read, in .NET Framework, the default encoding UTF-8 will be used.
You might wonder what happens if you use wrong encoding when reading or writing a file. There are several scenarios possible:
	If you use read / write only Latin letters, everything will work normally.
	If you write Cyrillic letters, to a files open with encoding, which does not support the Cyrillic alphabet (e.g. ASCII), Cyrillic letters will be permanently replaced by the character "?" (question mark).
In any case, these are unpleasant problems, which cannot be immediately noticed.
 	To avoid problems with incorrect encoding of files, always check the encoding explicitly. Otherwise, you may work incorrectly or break at a later stage.
The Unicode Standard. Reading in Unicode
Unicode is an industry standard that allows computers and other electronic devices always to present and manipulate text, which was written in most of the world’s literacies. It consists of over 100,000 characters, as well as various encoding schemes (encodings). The unification of different characters, which Unicode offers, leads to its greater distribution. As you know, characters in C# (types char and string) are also presented in Unicode.
To read characters, stored in Unicode, we must use one of the supported encoding schemes for this standard. The most popular and widely used is UTF-8. We can set it as a code scheme with an already familiar way:
StreamReader reader = new StreamReader("test.txt",
	Encoding.GetEncoding("UTF-8"));
If you are wondering, whether to read a text file, encoded in Cyrillic, Windows-1251 or UTF-8, then this question has no clear answer. Both standards are widely used for the recording of non-Latin text. Both encoding schemes are allowed and can be used. You should only always follow the rule that a certain files should always be read and written using the same encoding.
Writing to a Text File
Text files are very convenient for storing various types of information. For example, we can record the results of a program. We can use text files to make something like a journal (log) for the program – a convenient way to monitor it at runtime.
Again, as with reading a text file, we will use a similar to the Console class when writing, called StreamWriter.
The StreamWriter Class
The class StreamWriter is part of the System.IO namespace and is used exclusively for working with text data. It resembles the class StreamReader, but instead of methods for reading, it offers similar methods for writing to a text file. Unlike other streams, before writing data to the desired destination, StreamWriter turns it into bytes. StreamWriter enables us to set a preferred character encoding at the time it is created. We can create an instance of the class the following way:
StreamWriter writer = new StreamWriter("test.txt");
In the constructor of the class can pass as a parameter a file path, as well as an existing stream, to which we will write, or an encoding scheme. The StreamWriter class has several predefined constructors, depending on whether we will write to a file or a stream. In the examples, we will use the constructor with the parameter – file path. Example of the usage of the StreamWriter class constructor with more than one parameter is:
StreamWriter writer = new StreamWriter("test.txt",
	false, Encoding.GetEncoding("Windows-1251"));
In this example, we pass a file path as the first parameter. As a second parameter, we pass a Boolean variable that indicates whether to overwrite the file or to append the data at the end of the file. As a third parameter, we pass an encoding scheme (charset).
The example lines of code could trigger an exception, but the handling of input / output exceptions will be discussed later in this chapter.
Printing the Numbers [1…20] in a Text File – Example
Once we know how to create a StreamWriter class, we will use it as intended. Our goal is to enroll in a text file the numbers from 1 to 20, each number on a separate line. We can do this the following way:
class FileWriter
{
	static void Main()
	{
		// Create a StreamWriter instance
		StreamWriter writer = new StreamWriter("numbers.txt");

		// Ensure the writer will be closed when no longer used
		using(writer)
		{
			// Loop through the numbers from 1 to 20 and write them
			for (int i = 1; i <= 20; i++)
			{
				writer.WriteLine(i);
			}
		}
	}
}
We start by creating an instance of StreamWriter in the already well-known way from the examples.
To list the numbers from 1 to 20 we will use a for-loop. Inside the loop, we use the method WriteLine(…), which again we know from our previous work with the console, to record the current number on a new line in the file. You need not worry if a file with the chosen name does not exist. If such the case, it will automatically be created in the folder of the project and if it already exists, it will be overwritten (old content will be deleted). The outcome is:
numbers.txt
1
2
3
…
20
To make sure that after the end of the file it will be closed, we should use the using construct.
 	Be sure to close the stream after you finish using it! The best way to dispose any unused resources is with the using construct in C#.
When you want to print text in Cyrillic and are unsure what encoding to use, prefer the UTF-8 encoding. It is universal and not only supports Cyrillic, but all widespread international alphabets: Greek, Arabic, Chinese, Japanese, etc.
Input / Output Exception Handling
If you have followed the examples so far, you have probably noticed that many of the operations, related to files, can cause exceptional situations. The basic principles and approaches for their capture and processing are already familiar to you from the chapter "Handling Exceptions". Now we will concentrate on the specific errors when working with files and best practices for their handling.
Intercepting Exceptions when Working with Files
Perhaps the most common exception when working with files is the FileNotFoundException (its name infers that the desired file was not found). It can occur when creating StreamReader.
When setting a specified encoding by the creation of a StreamReader or a StreamWriter object, an ArgumentException can be thrown. This means, that the encoding we have chosen is not supported.
Another common mistake is IOException. This is the base class for all IO errors when working with streams.
The standard approach for handling exceptions when working with files is the following: declare variables of class StreamReader or StreamWriter in try-catch block. Initialize them with the necessary values in the block and handle the potential exceptions properly. To close the stream, we use the structure using. To illustrate what we just said, will give an example.
Catching an Exception when Opening a File – Example
Here’s how we can catch exceptions that occur when working with files:
class HandlingExceptions
{
	static void Main()
	{
		string fileName = @"somedir\somefile.txt";
		try
		{
			StreamReader reader = new StreamReader(fileName);
			Console.WriteLine(
				"File {0} successfully opened.", fileName);
			Console.WriteLine("File contents:");
			using (reader)
			{
				Console.WriteLine(reader.ReadToEnd());
			}
		}
		catch (FileNotFoundException)
		{
			Console.Error.WriteLine(
				"Can not find file {0}.", fileName);
		}
		catch (DirectoryNotFoundException)
		{
			Console.Error.WriteLine(
				"Invalid directory in the file path.");
		}
		catch (IOException)
		{
			Console.Error.WriteLine(
				"Can not open the file {0}", fileName);
		}
	}
}
The example demonstrates reading a file and printing its contents to the console. If we accidentally have confused the name of the file or have deleted it, an exception of type FileNotFoundException will be thrown. In the catch block we intercept this sort of exception and if such occurs, we will process it properly and print a message to the console, saying that this file cannot be found. The same will happen if there were no directory named "somedir". Finally, for better security, we have also added a catch block for IOExceptions. There all other IO exceptions, that might occur when working with files, will be intercepted.
Text Files – More Examples
We hope the theoretical explanations and examples so far have helped you get into the subtleties when working with text files. Now we will take a look at some more complex examples, so as to review the gained knowledge and to illustrate how to use them in solving practical problems.
Occurrences of a Substring in a File – Example
Here is how to implement a simple program that counts how many times a substring occurs in a text file. In the example, let’s look for the substring "C#" in a text file as follows:
sample.txt
This is our "Intro to Programming in C#" book.
In it you will learn the basics of C# programming.
You will find out how nice C# is.
We can implement the counting as follows: will read the file line by line and each time we meet the desired word inside the last read line, we will increase the value of a variable (counter). We will process the possible exceptional situations to enable users to receive adequate information in case of errors. Here is a sample implementation:
CountingWordOccurrences.cs
static void Main()
{
	string fileName = @"..\..\sample.txt";
	string word = "C#";
	try
	{
		StreamReader reader = new StreamReader(fileName);
		using (reader)
		{
			int occurrences = 0;
			string line = reader.ReadLine();
			while (line != null)
			{
				int index = line.IndexOf(word);
				while (index != -1)
				{
					occurrences++;
					index = line.IndexOf(word, (index + 1));
				}
				line = reader.ReadLine();
			}
			Console.WriteLine(
				"The word {0} occurs {1} times.", word, occurrences);
		}
	}
	catch (FileNotFoundException)
	{
		Console.Error.WriteLine(
			"Can not find file {0}.", fileName);
	}
	catch (IOException)
	{
		Console.Error.WriteLine(
			"Cannot read the file {0}.", fileName);
	}
}
For simplicity of the example, the word we seek is hardcoded. You can implement the program to search a word entered by the user.
You can see that the example is not very different from the previous ones. We initialize the variables outside of the try-catch block. Again, we use a while-loop to read the lines of the text file one by one. Inside its body, there is another while-loop, which counts how many times the searched word occurs in the given line, and then increases the number of occurrences. This is done using the method IndexOf(…) of the class String (remember what it does in case you have forgotten). We do not forget to ensure the closing of the StreamReader object using the using structure. All that remains is to print the results on to the console.
For our example, the result is the following:
The word C# occurs 3 times.
Editing a Subtitles File – Example
Now we will look at a more complex example, in which we at the same time read from a file and record to another. This program fixes a subtitles file for a movie.
Our goal will be to read a file with subtitles, that are incorrect and do not appear at the right time, and to shift the times in an appropriate manner, so that they can appear correctly. One such file generally contains the time of the on-screen duration and the text, that should appear in the defined time interval. Here is how typical subtitles files look like:
GORA.sub
{1029}{1122}{Y:i}Captain, systems are|at the ready.
{1123}{1270}{Y:i}The preassure is stable.|Prepare for landing.
{1343}{1468}{Y:i}Please,fasten your seatbelts|and take your places.
{1509}{1610}{Y:i}Coordinates 5.6|- Five, Five, Six, dot com.
{1632}{1718}{Y:i}Where did the coordinates|go to?
{1756}{1820}Commander Logar,|everyone is speaking in English.
{1821}{1938}Can't we switch|to Turkish from the beginning?
{1942}{1992}Yes, we can!
{3104}{3228}{Y:b}G.O.R.A.|a movie about the cosmos
…

StarWars.sub
{1029}{1122}{Y:i}I'll never join you.
{1123}{1270}{Y:i}If you only knew | the power of the dark side.
{1343}{1468}{Y:i}Obi One never told you what happened to your father!
{1509}{1610}{Y:i}He told me enough! | He told me you killed him.
{1632}{1718}{Y:i}No... I am your father!
{1756}{1820}(dramatic music playing)...
{1821}{1938}No, no that's not true... | That's impossible!
{1942}{1992}Search your feelings,| you know it's true.
{3104}{3228}{Y:b}Nooo…
…
To fix the subtitles, we usually just need to make an adjustment in the time for displaying the subtitles. Such an adjustment may be offsetting the start / end time for each subtitle (by addition or subtraction of a constant) or changing the speed (multiplying by a factor, say 1.05).
Here is sample code that can implement such a program:
FixingSubtitles.cs
using System;
using System.IO;

class FixingSubtitles
{
	const double COEFFICIENT = 1.05;
	const int ADDITION = 5000;
	const string INPUT_FILE = @"..\..\source.sub";
	const string OUTPUT_FILE = @"..\..\fixed.sub";

	static void Main()
	{
		try
		{
			// Create reader
			StreamReader streamReader = new StreamReader(INPUT_FILE);

			// Create writer
			StreamWriter streamWriter =
				new StreamWriter(OUTPUT_FILE, false);

			using (streamReader)
			{
				using (streamWriter)
				{
					string line;
					while ((line = streamReader.ReadLine()) != null)
					{
						streamWriter.WriteLine(FixLine(line));
					}
				}
			}
		}
		catch (IOException exc)
		{
			Console.WriteLine("Error: {0}.", exc.Message);
		}
	}

	static string FixLine(string line)
	{
		// Find closing brace
		int bracketFromIndex = line.IndexOf('}');

		// Extract 'from' time
		string fromTime = line.Substring(1, bracketFromIndex - 1);

		// Calculate new 'from' time
		int newFromTime = (int) (Convert.ToInt32(fromTime) *
			COEFFICIENT + ADDITION);

		// Find the following closing brace
		int bracketToIndex = line.IndexOf('}',
			bracketFromIndex + 1);

		// Extract 'to' time
		string toTime = line.Substring(bracketFromIndex + 2,
			bracketToIndex - bracketFromIndex - 2);

		// Calculate new 'to' time
		int newToTime = (int) (Convert.ToInt32(toTime) *
			COEFFICIENT + ADDITION);

		// Create a new line using the new 'from' and 'to' times
		string fixedLine = "{" + newFromTime + "}" + "{" +
			newToTime + "}" + line.Substring(bracketToIndex + 1);

		return fixedLine;
	}
}
Again, we use the already familiar method for reading a file line by line. The difference this time is, that in the body of the loop, we write every line of the file with already corrected subtitles, after we have fixed them with the method FixLine(string) (this method is not the subject of our discussion, since it can be implemented in many different ways depending on what you want to adjust). Because we use the using block for both files, we can guarantee that they will be closed even if an exception occurs during processing (this may happen, for example if one of the lines in the file is not in the expected format).
Exercises
	Write a program that reads a text file and prints its odd lines on the console.
	Write a program that joins two text files and records the results in a third file.
	Write a program that reads the contents of a text file and inserts the line numbers at the beginning of each line, then rewrites the file contents.
	Write a program that compares two text files with the same number of rows line by line and prints the number of equal and the number of different lines.
	Write a program that reads a square matrix of integers from a file and finds the sub-matrix with size 2 ? 2 that has the maximal sum and writes this sum to a separate text file. The first line of input file contains the size of the recorded matrix (N). The next N lines contain N integers separated by spaces.
Sample input file:
4
2 3 3 4
0 2 3 4
3 7 1 2
4 3 3 2
Sample output: 17.
	Write a program that reads a list of names from a text file, arranges them in alphabetical order, and writes them to another file. The lines are written one per row.
	Write a program that replaces every occurrence of the substring "start" with "finish" in a text file. Can you rewrite the program to replace whole words only? Does the program work for large files (e.g. 800 MB)?
	Write the previous program so that it changes only the whole words (not parts of the word).
	Write a program that deletes all the odd lines of a text file.
	Write a program that extracts from an XML file the text only (without the tags). Sample input file:
<?xml version="1.0"><student><name>Peter</name>
<age>21</age><interests count="3"><interest> Games</interest><interest>C#</interest><interest> Java</interest></interests></student>
Sample output:
Peter
21
Games
C#
Java
	Write a program that deletes all words that begin with the word "test". The words will contain only the following chars: 0…9, a…z, A…Z.
	A text file words.txt is given, containing a list of words, one per line. Write a program that deletes in the file text.txt all the words that occur in the other file. Catch and handle all possible exceptions.
	Write a program that reads a list of words from a file called words.txt, counts how many times each of these words is found in another file text.txt, and records the results in a third file – result.txt, but before that, sorts them by the number of occurrences in descending order. Handle all possible exceptions.
Solutions and Guidelines
	Use the examples discussed in this chapter. Use the using structure to ensure proper closing of the input and the resulting stream.
	You will have to first read the input file line by line and save it in the resulting file in overwrite mode. Then you must open the second input file and save it line by line in the result file in append mode. To create a StreamWriter in overwrite / use mode use the appropriate constructor (find it in MSDN).
An alternative way is to read both files in a string with ReadToEnd(), store them in memory and save them in the resulting file. This approach does not work for large files (the likes of several gigabytes).
	Follow the examples in this chapter. Think of how you would solve the task if the file were large (several gigabytes).
	Follow the examples in this chapter. You will have to open both files simultaneously and read them line by line in a loop. If you reach the end of the (read null) file, that does not match the other’s, that means that both files have different number of rows and an exception should be thrown.
	Read the first line of the file and create a matrix with the specified size. After that read the following lines, line by line and separate the numbers. Then save them in the corresponding (row, column) in the matrix. Finally, find the sub-matrix using two nested loops.
	Write each read name in a list (List<string>), then sort it properly (look for information on the method Sort()) and then print it in the result file.
	Read the file line by line and use the methods of the class String. If you load the entire file into memory, instead of reading it line by line, problems when loading large files might occur.
	For every occurrence of "start", check if that is the whole word or just a part of it.
	Look at the examples in this chapter.
	Read the input file character by character. When you encounter a "<", then this is a starting tag, but when you encounter a ">", that means a closing tag. All characters you encounter outside of the tags build up the text that must be extracted. You can store it in StringBuilder and print its contents when you encounter "<" or reach the end of the file.
	Read the file line by line and replace words that start with "test" with an empty string. Use Regex.Replace(…) with an appropriate regular expression. Alternatively, you can search in the line the substring "test" and every time you find it, get all of its neighboring letters to the left and right. This way you find the word in which the string "test" is part of and you can delete it if it begins with "test".
	The task is similar to the previous one. You can read the text line by line and replace each of the given words with an empty string. Test whether your program properly handles exceptions by simulating different scenarios (e.g. no file, lack of rights for reading and writing, etc.).
	Create a hash table with keys – the words from words.txt and value number of occurrences of each word (Dictionary<string, int>). Firstly, save to the hash table that all words are found 0 times. Then read the file line by line and split each line into words. Check whether each obtained word can be found in the hash table, and if so, add 1 to the number of occurrences. Finally, save all the words and their number of occurrences in an array of type KeyValuePair<string, int>. Sort the array with a suitable comparison function like so:
Array.Sort<KeyValuePair<string, int>>(
	arr, (a, b) => a.Value.CompareTo(b.Value));
 
  

Chapter 17. Trees and Graphs

In This Chapter
In this chapter we will discuss tree data structures, like trees and graphs. The abilities of these data structures are really important for the modern programming. Each of this data structures is used for building a model of real life problems, which are efficiently solved using this model. We will explain what tree data structures are and will review their main advantages and disadvantages. We will present example implementations and problems showing their practical usage. We will focus on binary trees, binary search trees and self-balancing binary search tree. We will explain what graph is, the types of graphs, how to represent a graph in the memory (graph implementation) and where graphs are used in our life and in the computer technologies. We will see where in .NET Framework self-balancing binary search trees are implemented and how to use them.
Tree Data Structures
Very often we have to describe a group of real life objects, which have such relation to one another that we cannot use linear data structures for their description. In this chapter, we will give examples of such branched structures. We will explain their properties and the real life problems, which inspired their creation and further development.
A tree-like data structure or branched data structure consists of set of elements (nodes) which could be linked to other elements, sometimes hierarchically, sometimes not. Trees represent hierarchies, while graphs represent more general relations such as the map of city.
¬Trees
Trees are very often used in programming, because they naturally represent all kind of object hierarchies from our surroundings. Let’s give an example, before we explain the trees’ terminology.
Example – Hierarchy of the Participants in a Project
We have a team, responsible for the development of certain software project.
The participants in it have manager-subordinates relations. Our team consists of 9 teammates:
 
What is the information we can get from this hierarchy? The direct boss of the developers is the "Team Leader", but indirectly they are subordinate to the "Project Manager". The "Team Leader" is subordinate only to the "Project Manager". On the other hand "Developer 1" has no subordinates. The "Project Manager" is the highest in the hierarchy and has no manager.
The same way we can describe every participant in the project. We see that such a little figure gives us so much information.
Trees Terminology
For a better understanding of this part of the chapter we recommend to the reader at every step to draw an analogy between the abstract meaning and its practical usage in everyday life.
 
We will simplify the figure describing our hierarchy. We assume that it consists of circles and lines connecting them. For convenience we name the circles with unique numbers, so that we can easily specify about which one we are talking about.
We will call every circle a node and each line an edge. Nodes "19", "21", "14" are below node "7" and are directly connected to it. This nodes we are called direct descendants (child nodes) of node "7", and node "7" their parent. The same way "1", "12" and "31" are children of "19" and "19" is their parent. Intuitively we can say that "21" is sibling of "19", because they are both children of "7" (the reverse is also true – "19" is sibling of "21").For "1", "12", "31", "23" and "6" node "7" precedes them in the hierarchy, so he is their indirect parent – ancestor, ant they are called his descendants.
Root is called the node without parent. In our example this is node "7"
Leaf is a node without child nodes. In our example – "1", "12", "31", "21", "23" and "6".
Internal nodes are the nodes, which are not leaf or root (all nodes, which have parent and at least one child). Such nodes are "19" and "14".
Path is called a sequence of nodes connected with edges, in which there is no repetition of nodes. Example of path is the sequence "1", "19", "7" and "21". The sequence "1", "19" and "23" is not a path, because "19" and "23" are not connected.
Path length is the number of edges, connecting the sequence of nodes in the path. Actually it is equal to the number of nodes in the path minus 1. The length of our example for path ("1", "19", "7" and "21") is three.
Depth of a node we will call the length of the path from the root to certain node. In our example "7" as root has depth zero, "19" has depth one and "23" – depth two.
Here is the definition about tree:
Tree – a recursive data structure, which consists of nodes, connected with edges. The following statements are true for trees:
	Each node can have 0 or more direct descendants (children).
	Each node has at most one parent. There is only one special node without parent – the root (if the tree is not empty).
	All nodes are reachable from the root – there is a path from the root to each node in the tree.
We can give more simple definition of tree: a node is a tree and this node can have zero or more children, which are also trees.
Height of tree – is the maximum depth of all its nodes. In our example the tree height is 2.
Degree of node we call the number of direct children of the given node. The degree of "19" and "7" is three, but the degree of "14" is two. The leaves have degree zero.
Branching factor is the maximum of the degrees of all nodes in the tree. In our example the maximum degree of the nodes is 3, so the branching factor is 3.
Tree Implementation – Example
Now we will see how to represent trees as data structure in programming. We will implement a tree dynamically. Our tree will contain numbers inside its nodes, and each node will have a list of zero or more children, which are trees too (following our recursive definition).
Each node is recursively defined using itself. Each node of the tree (TreeNode<T>) contains a list of children, which are nodes (TreeNode<T>). The tree itself is another class Tree<T> which can be empty or can have a root node. Tree<T> implements basic operations over trees like construction and traversal.
Let’s have a look at the source code of our dynamic tree representation:
using System;
using System.Collections.Generic;

/// <summary>Represents a tree node</summary>
/// <typeparam name="T">the type of the values in nodes
/// </typeparam>
public class TreeNode<T>
{
	// Contains the value of the node
	private T value;

	// Shows whether the current node has a parent or not
	private bool hasParent;

	// Contains the children of the node (zero or more)
	private List<TreeNode<T>> children;

	/// <summary>Constructs a tree node</summary>
	/// <param name="value">the value of the node</param>
	public TreeNode(T value)
	{
		if (value == null)
		{
			throw new ArgumentNullException(
				"Cannot insert null value!");
		}
		this.value = value;
		this.children = new List<TreeNode<T>>();
	}

	/// <summary>The value of the node</summary>
	public T Value
	{
		get
		{
			return this.value;
		}
		set
		{
			this.value = value;
		}
	}

	/// <summary>The number of node's children</summary>
	public int ChildrenCount
	{
		get
		{
			return this.children.Count;
		}
	}

	/// <summary>Adds child to the node</summary>
	/// <param name="child">the child to be added</param>
	public void AddChild(TreeNode<T> child)
	{
		if (child == null)
		{
			throw new ArgumentNullException(
				"Cannot insert null value!");
		}

		if (child.hasParent)
		{
			throw new ArgumentException(
				"The node already has a parent!");
		}

		child.hasParent = true;
		this.children.Add(child);
	}

	/// <summary>
	/// Gets the child of the node at given index
	/// </summary>
	/// <param name="index">the index of the desired child</param>
	/// <returns>the child on the given position</returns>
	public TreeNode<T> GetChild(int index)
	{
		return this.children[index];
	}
}

/// <summary>Represents a tree data structure</summary>
/// <typeparam name="T">the type of the values in the
/// tree</typeparam>
public class Tree<T>
{
	// The root of the tree
	private TreeNode<T> root;

	/// <summary>Constructs the tree</summary>
	/// <param name="value">the value of the node</param>
	public Tree(T value)
	{
		if (value == null)
		{
			throw new ArgumentNullException(
				"Cannot insert null value!");
		}

		this.root = new TreeNode<T>(value);
	}

	/// <summary>Constructs the tree</summary>
	/// <param name="value">the value of the root node</param>
	/// <param name="children">the children of the root
	/// node</param>
	public Tree(T value, params Tree<T>[] children)
		: this(value)
	{
		foreach (Tree<T> child in children)
		{
			this.root.AddChild(child.root);
		}
	}

	/// <summary>
	/// The root node or null if the tree is empty
	/// </summary>
	public TreeNode<T> Root
	{
		get
		{
			return this.root;
		}
	}

	/// <summary>Traverses and prints tree in
	/// Depth-First Search (DFS) manner</summary>
	/// <param name="root">the root of the tree to be
	/// traversed</param>
	/// <param name="spaces">the spaces used for
	/// representation of the parent-child relation</param>
	private void PrintDFS(TreeNode<T> root, string spaces)
	{
		if (this.root == null)
		{
			return;
		}

		Console.WriteLine(spaces + root.Value);

		TreeNode<T> child = null;
		for (int i = 0; i < root.ChildrenCount; i++)
		{
			child = root.GetChild(i);
			PrintDFS(child, spaces + "   ");
		}
	}

	/// <summary>Traverses and prints the tree in
	/// Depth-First Search (DFS) manner</summary>
	public void TraverseDFS()
	{
		this.PrintDFS(this.root, string.Empty);
	}
}

/// <summary>
/// Shows a sample usage of the Tree<T> class
/// </summary>
public static class TreeExample
{
	static void Main()
	{
		// Create the tree from the sample
		Tree<int> tree =
			new Tree<int>(7,
				new Tree<int>(19,
					new Tree<int>(1),
					new Tree<int>(12),
					new Tree<int>(31)),
				new Tree<int>(21),
				new Tree<int>(14,
					new Tree<int>(23),
					new Tree<int>(6))
			);

		// Traverse and print the tree using Depth-First-Search
		tree.TraverseDFS();

		// Console output:
		// 7
		//	   19
		//	      1
		//	      12
		//	      31
		//	   21
		//	   14
		//	      23
		//	      6
	}
}
How Does Our Implementation Work?
Let’s discuss the given code a little. In our example we have a class Tree<T>, which implements the actual tree. We also have a class TreeNode<T>, which represents a single node of the tree.
The functions associated with node, like creating a node, adding a child node to this node, and getting the number of children, are implemented at the level of TreeNode<T>.
The rest of the functionality (traversing the tree for example) is implemented at the level of Tree<T>. Logically dividing the functionality between the two classes makes our implementation more flexible.
The reason we divide the implementation in two classes is that some operations are typical for each separate node (adding a child for example), while others are about the whole tree (searching a node by its number). In this variant of the implementation, the tree is a class that knows its root and each node knows its children. In this implementation we can have an empty tree (when root = null).
Here are some details about the TreeNode<T> implementation. Each node of the tree consists of private field value and a list of children – children. The list of children consists of elements of the same type. That way each node contains a list of references to its direct children. There are also public properties for accessing the values of the fields of the node. The methods that can be called from code outside the class are:
	AddChild(TreeNode<T> child) – adds a child
	TreeNode<T> GetChild(int index) – returns a child by given index
	ChildrenCount – returns the number of children of certain node
To satisfy the condition that every node has only one parent we have defined private field hasParent, which determines whether this node has parent or not. This information is used only inside the class and we need it in the AddChild(Tree<T> child) method. Inside this method we check whether the node to be added already has parent and if so we throw and exception, saying that this is impossible.
In the class Tree<T> we have only one get property TreeNode<T> Root, which returns the root of the tree.
Depth-First-Search (DFS) Traversal
In the class Tree<T> is implemented the method TraverseDFS(), that calls the private method PrintDFS(TreeNode<T> root, string spaces), which traverses the tree in depth and prints on the standard output its elements in tree layout using right displacement (adding spaces).
The Depth-First-Search algorithm aims to visit each of the tree nodes exactly one. Such a visit of all nodes is called tree traversal. There are multiple algorithms to traverse a tree but in this chapter we will discuss only two of them: DFS (depth-first search) and BFS (breadth-first search).
The DFS algorithm starts from a given node and goes as deep in the tree hierarchy as it can. When it reaches a node, which has no children to visit or all have been visited, it returns to the previous node. We can describe the depth-first search algorithm by the following simple steps:
	Traverse the current node (e.g. print it on the console or process it in some way).
	Sequentially traverse recursively each of the current nodes’ child nodes (traverse the sub-trees of the current node). This can be done by a recursive call to the same method for each child node.
Creating a Tree
We to make creating a tree easier we defined a special constructor, which takes for input parameters a node value and a list of its sub-trees. That allows us to give any number of arguments of type Tree<T> (sub-trees). We used exactly the same constructor for creating the example tree.
Traverse the Hard Drive Directories
Let’s start with another example of tree: the file system. Have you noticed that the directories on your hard drive are actually a hierarchical structure, which is a tree? We have folders (tree nodes) which may have child folders and files (which both are also tree nodes).
You can think of many real life examples, where trees are used, right?
Let’s get a more detailed view of Windows file system. As we know from our everyday experience, we create folders on the hard drive, which can contain subfolders and files. Subfolders can also contain subfolders and so on until you reach certain max depth limit.
The directory tree of the file system is accessible through the build in .NET functionality: the class System.IO.DirectoryInfo. It is not present as a data structure, but we can get the subfolders and files of every directory, so we can traverse the file system tree by using a standard tree traversal algorithm, such as Depth-First Search (DFS).
Below we can see what the typical directory tree in Windows looks like:
 
Recursive DFS Traversal of the Directories
The next example illustrates how we can recursively traverse recursively the tree structure of given folder (using Depth-First-Search) and print on the standard output its content:
DirectoryTraverserDFS.cs
using System;
using System.IO;

/// <summary>
/// Sample class, which traverses recursively given directory
/// based on the Depth-First-Search (DFS) algorithm
/// </summary>
public static class DirectoryTraverserDFS
{
	/// <summary>
	/// Traverses and prints given directory recursively
	/// </summary>
	/// <param name="dir">the directory to be traversed</param>
	/// <param name="spaces">the spaces used for representation
	/// of the parent-child relation</param>
	private static void TraverseDir(DirectoryInfo dir,
		string spaces)
	{
		// Visit the current directory
		Console.WriteLine(spaces + dir.FullName);

		DirectoryInfo[] children = dir.GetDirectories();

		// For each child go and visit its sub-tree
		foreach (DirectoryInfo child in children)
		{
			TraverseDir(child, spaces + "  ");
		}
	}

	/// <summary>
	/// Traverses and prints given directory recursively
	/// </summary>
	/// <param name="directoryPath">the path to the directory
	/// which should be traversed</param>
	static void TraverseDir(string directoryPath)
	{
		TraverseDir(new DirectoryInfo(directoryPath),
			string.Empty);
	}

	static void Main()
	{
		TraverseDir("C:\\");
	}
}
As we can see the recursive traversal algorithm of the content of the directory is the same as the one we used for our tree.
Here we can see part of the result of the traversal:
C:\
  C:\Config.Msi
  C:\Documents and Settings
    C:\Documents and Settings\Administrator
      C:\Documents and Settings\Administrator\.ARIS70
      C:\Documents and Settings\Administrator\.jindent
      C:\Documents and Settings\Administrator\.nbi
        C:\Documents and Settings\Administrator\.nbi\downloads
        C:\Documents and Settings\Administrator\.nbi\log
        C:\Documents and Settings\Administrator\.nbi\cache
        C:\Documents and Settings\Administrator\.nbi\tmp
        C:\Documents and Settings\Administrator\.nbi\wd
      C:\Documents and Settings\Administrator\.netbeans
        C:\Documents and Settings\Administrator\.netbeans\6.0
…
Note that the above program may crash with UnauthorizedAccessException in case you do not have access permissions for some folders on the hard disk. This is typical for some Windows installations so you could start the traversal from another directory to play with it, e.g. from "C:\Windows\assembly".
Breath-First-Search (BFS)
Let’s have a look at another way of traversing trees. Breath-First-Search (BFS) is an algorithm for traversing branched data structures (like trees and graphs). The BFS algorithm first traverses the start node, then all its direct children, then their direct children and so on. This approach is also known as the wavefront traversal, because it looks like the waves caused by a stone thrown into a lake.
The Breath-First-Search (BFS) algorithm consists of the following steps:
	Enqueue the start node in queue Q.
	While Q is not empty repeat the following two steps:
	Dequeue the next node v from Q and print it.
	Add all children of v in the queue.
The BFS algorithm is very simple and always traverses first the nodes that are closest to the start node, and then the more distant and so on until it reaches the furthest. The BFS algorithm is very widely used in problem solving, e.g. for finding the shortest path in a labyrinth.
A sample implementation of BFS algorithms that prints all folders in the file system is given below:
DirectoryTraverserBFS.cs
using System;
using System.Collections.Generic;
using System.IO;

/// <summary>
/// Sample class, which traverses given directory
/// based on the Breath-First-Search (BFS) algorithm
/// </summary>
public static class DirectoryTraverserBFS
{
	/// <summary>
	/// Traverses and prints given directory with BFS
	/// </summary>
	/// <param name="directoryPath">the path to the directory 		/// which should be traversed</param>
	static void TraverseDir(string directoryPath)
	{
		Queue<DirectoryInfo> visitedDirsQueue =
			new Queue<DirectoryInfo>();
		visitedDirsQueue.Enqueue(new DirectoryInfo(directoryPath));
		while (visitedDirsQueue.Count > 0)
		{
			DirectoryInfo currentDir = visitedDirsQueue.Dequeue();
			Console.WriteLine(currentDir.FullName);

			DirectoryInfo[] children = currentDir.GetDirectories();
			foreach (DirectoryInfo child in children)
			{
				visitedDirsQueue.Enqueue(child);
			}
		}
	}

	static void Main()
	{
		TraverseDir(@"C:\");
	}
}
If we start the program to traverse our local hard disk, we will see that the BFS first visits the directories closest to the root (depth 1), then the folders at depth 2, then depth 3 and so on. Here is a sample output of the program:
C:\
C:\Config.Msi
C:\Documents and Settings
C:\Inetpub
C:\Program Files
C:\RECYCLER
C:\System Volume Information
C:\WINDOWS
C:\wmpub
C:\Documents and Settings\Administrator
C:\Documents and Settings\All Users
C:\Documents and Settings\Default User
…
Binary Trees
In the previous section we discussed the basic structure of a tree. In this section we will have a look at a specific type of tree – binary tree. This type of tree turns out to be very useful in programming. The terminology for trees is also valid about binary trees. Despite that below we will give some specific explanations about thus structure.
Binary Tree – a tree, which nodes have a degree equal or less than 2 or we can say that it is a tree with branching degree of 2. Because every node’s children are at most 2, we call them left child and right child. They are the roots of the left sub-tree and the right sub-tree of their parent node. Some nodes may have only left or only right child, not both. Some nodes may have no children and are called leaves.
Binary tree can be recursively defined as follows: a single node is a binary tree and can have left and right children which are also binary trees.
Binary Tree – Example
Here we have an example of binary tree. The nodes are again named with some numbers. An the figure we can see the root of the tree – "14", the left sub-tree (with root 19) and the right sub-tree (with root 15) and a right and left child – "3" and "21".

 
We have to note that there is one very big difference in the definition of binary tree from the definition of the classical tree – the order of the children of each node. The next example will illustrate that difference:
 
On this figure above two totally different binary trees are illustrated – the first one has root "19" and its left child "23" and the second root "19" and right child "23". If that was an ordinary tree they would have been the same. That’s why such tree we would illustrate the following way:
 
 	Remember! Although we take binary trees as a special case of a tree structure, we have to notice that the condition for particular order of children nodes makes them a completely different structure.
Binary Tree Traversal
The traversal of binary tree is a classic problem which has classical solutions. Generally there are few ways to traverse a binary tree recursively:
	In-order (Left-Root-Right) – the traversal algorithm first traverses the left sub-tree, then the root and last the left sub-tree. In our example the sequence of such traversal is: "23", "19", "10", "6", "21", "14", "3", "15".
	Pre-order (Root-Left-Right) – in this case the algorithm first traverses the root, then the left sub-tree and last the right sub-tree. The result of such traversal in our example is: "14", "19", "23", "6", "10", "21", "15", "3".
	Post-order (Left-Right-Root) – here we first traverse the left sub-tree, then the right one and last the root. The result after the traversal is: "23", "10", "21", "6", "19", "3", "15", "14".
Recursive Traversal of Binary Tree – Example
The next example shows an implementation of binary tree, which we will traverse using the in-order recursive scheme.
using System;
using System.Collections.Generic;

/// <summary>Represents a binary tree</summary>
/// <typeparam name="T">Type of values in the tree</typeparam>
public class BinaryTree<T>
{
	/// <summary>The value stored in the curent node</summary>
	public T Value { get; set; }

	/// <summary>The left child of the current node</summary>
	public BinaryTree<T> LeftChild { get; private set; }

	/// <summary>The right child of the current node</summary>
	public BinaryTree<T> RightChild { get; private set; }
	
	/// <summary>Constructs a binary tree</summary>
	/// <param name="value">the value of the tree node</param>
	/// <param name="leftChild">the left child of the tree</param>
	/// <param name="rightChild">the right child of the tree
	/// </param>
	public BinaryTree(T value,
		BinaryTree<T> leftChild, BinaryTree<T> rightChild)
	{
		this.Value = value;
		this.LeftChild = leftChild;
		this.RightChild = rightChild;
	}

	/// <summary>Constructs a binary tree with no children
	/// </summary>
	/// <param name="value">the value of the tree node</param>
	public BinaryTree(T value) : this(value, null, null)
	{
	}

	/// <summary>Traverses the binary tree in pre-order</summary>
	public void PrintInOrder()
	{
		// 1. Visit the left child
		if (this.LeftChild != null)
		{
			this.LeftChild.PrintInOrder();
		}

		// 2. Visit the root of this sub-tree
		Console.Write(this.Value + " ");

		// 3. Visit the right child
		if (this.RightChild != null)
		{
			this.RightChild.PrintInOrder();
		}
	}
}

/// <summary>
/// Demonstrates how the BinaryTree<T> class can be used
/// </summary>
public class BinaryTreeExample
{
	static void Main()
	{
		// Create the binary tree from the sample
		BinaryTree<int> binaryTree =
			new BinaryTree<int>(14,
					new BinaryTree<int>(19,
							new BinaryTree<int>(23),
							new BinaryTree<int>(6,
									new BinaryTree<int>(10),
									new BinaryTree<int>(21))),
					new BinaryTree<int>(15,
							new BinaryTree<int>(3),
							null));

		// Traverse and print the tree in in-order manner
		binaryTree.PrintInOrder();
		Console.WriteLine();

		// Console output:
		// 23 19 10 6 21 14 3 15
	}
}
How Does the Example Work?
This implementation of binary tree is slightly different from the one of the ordinary tree and is significantly simplified.
We have a recursive class definition BinaryTree<T>, which holds a value and left and right child nodes which are of the same type BinaryTree<T>. We have exactly two child nodes (left and right) instead of list of children.
The method PrintInOrder() works recursively using the DFS algorithm. It traverses each node in "in-order" (first the left child, then the node itself, then the right child). The DFS traversal algorithm performs the following steps:
	Recursive call to traverse the left sub-tree of the given node.
	Traverse the node itself (print its value).
	Recursive call to traverse the right sub-tree.
We highly recommend the reader to try and modify the algorithm and the source code of the given example to implement the other types of binary tree traversal of binary (pre-order and post-order) and see the difference.
Ordered Binary Search Trees
Till this moment we have seen how we can build traditional and binary trees. These structures are very summarized in themselves and it will be difficult for us to use them for a bigger project. Practically, in computer science special and programming variants of binary and ordinary trees are used that have certain special characteristics, like order, minimal depth and others. Let's review the most important trees used in programming.
As examples for a useful properties we can give the ability to quickly search of an element by given value (Red-Black tree); order of the elements in the tree (ordered search trees); balanced depth (balanced trees); possibility to store an ordered tree in a persistent storage so that searching of an element to be fast with as little as possible read operations (B-tree), etc.
In this chapter we will take a look at a more specific class of binary trees – ordered trees. They use one often met property of the nodes in the binary trees – unique identification key in every node. Important property of these keys is that they are comparable. Important kind of ordered trees are the so called "balanced search trees".
Comparability between Objects
Before continuing, we will introduce the following definition, which we will need for the further exposure.
Comparability – we call two objects A and B comparable, if exactly one of following three dependencies exists:
	"A is less than B"
	"A is bigger than B"
	"A is equal to B"
Similarly we will call two keys A and B comparable, if exactly one of the following three possibilities is true: A < B, A > B or A = B.
The nodes of a tree can contain different fields but we can think about only their unique keys, which we want to be comparable. Let’s give an example. We have two specific nodes A and B:
 
In this case, the keys of A and B hold the integer numbers 19 and 7. From Mathematics we know that the integer numbers (unlike the complex numbers) are comparable, which according the above reasoning give us the right to use them as keys. That’s why we can say that "A is bigger than B", because "19 is bigger than 17".
 	Please notice! In this case the numbers depicted on the nodes are their unique identification keys and not like before, just some numbers.
And we arrive to the definition of the ordered binary search tree:
Ordered Binary Tree (binary search tree) is a binary tree, in which every node has a unique key, every two of the keys are comparable and the tree is organized in a way that for every node the following is satisfied:
	All keys in the left sub-tree are smaller than its key.
	All keys in the right sub-tree are bigger than its key.
Properties of the Ordered Binary Search Trees
On the figure below we have given an example of an ordered binary search tree. We will use this example, to give some important properties of the binary tree’s order:
 
By definition we know that the left sub-tree of every node consists only of elements, which are smaller than itself, while in the right sub-tree there are only bigger elements. This means that if we want to find a given element, starting from the root, either we have found it or should search it respectively in its left or its right sub-tree, which will save unnecessary comparisons. For example, if we search 23 in our tree, we are not going to search for it in the left sub-tree of 19, because 23 is not there for sure (23 is bigger than 19, so eventually it is in the right sub-tree). This saves us 5 unnecessary comparisons with each of the left sub-tree elements, but if we were using a linked list, we would have to make these 5 comparisons.
From the elements’ order follows that the smallest element in the tree is the leftmost successor of the root, if there is such or the root itself, if it does not have a left successor. In our example this is the minimal element 7 and the maximal – 35. Next useful property from this is, that every single element from the left sub-tree of given node is smaller than every single element from the right sub-tree of the same node.
Ordered Binary Search Trees – Example
The next example shows a simple implementation of a binary search tree. Our point is to suggest methods for adding, searching and removing an element in the tree. For every single operation from the above, we will give an explanation in details. Note that our binary search tree is not balanced and may have poor performance in certain circumstances.
Ordered Binary Search Trees: Implementation of the Nodes
Just like before, now we will define an internal class, which will describe a node’s structure. Thus we will clearly distinguish and encapsulate the structure of a node, which our tree will contain within itself. This separate class BinaryTreeNode<T> that we have defined as internal is visible only in the ordered tree’s class.
Here is its definition:
BinaryTreeNode.cs
…
/// <summary>Represents a binary tree node</summary>
/// <typeparam name="T">Specifies the type for the values
/// in the nodes</typeparam>
internal class BinaryTreeNode<T> :
	IComparable<BinaryTreeNode<T>> where T : IComparable<T>
{
	// Contains the value of the node
	internal T value;

	// Contains the parent of the node
	internal BinaryTreeNode<T> parent;

	// Contains the left child of the node
	internal BinaryTreeNode<T> leftChild;

	// Contains the right child of the node
	internal BinaryTreeNode<T> rightChild;

	/// <summary>Constructs the tree node</summary>
	/// <param name="value">The value of the tree node</param>
	public BinaryTreeNode(T value)
	{
		if (value == null)
		{
			// Null values cannot be compared -> do not allow them
			throw new ArgumentNullException(
				"Cannot insert null value!");
		}

		this.value = value;
		this.parent = null;
		this.leftChild = null;
		this.rightChild = null;
	}

	public override string ToString()
	{
		return this.value.ToString();
	}

	public override int GetHashCode()
	{
		return this.value.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		BinaryTreeNode<T> other = (BinaryTreeNode<T>)obj;
		return this.CompareTo(other) == 0;
	}

	public int CompareTo(BinaryTreeNode<T> other)
	{
		return this.value.CompareTo(other.value);
	}
}
…
Let’s have a look to the proposed code. Still in the name of the structure, which we are considering – "ordered search tree", we are talking about order and we can achieve this order only if we have comparability among the elements in the tree.
Comparability between Objects in C#
What does "comparability between objects" mean for us as developers? It means that we must somehow oblige everyone who uses our data structure, to create it passing it a type, which is comparable.
In C# the sentence "type, which is comparable" will sound like this:
T : IComparable<T>
The interface IComparable<T>, located in the namespace System, specifies the method CompareTo(T obj), which returns a negative integer number, zero or a positive integer number respectively if the current object is less, equal or bigger than the one which is given to the method for comparing. Its definition looks approximately like this:
public interface IComparable<T>
{
	/// <summary>Compares the current object with another
	/// object of the same type.</summary>
	int CompareTo(T other);
}
On one hand, the implementation of this interface by given class ensures us that its instances are comparable (more about interfaces in OOP can be found in the "Interfaces" section of the "Defining Classes" chapter).
On the other hand, we need those nodes, described by BinaryTreeNode<T> class to be comparable between them too. That is why it implements IComparable<T> too. As it is shown in the code, the implementation of IComparable<T> to the BinaryTreeNode<T> class calls the type T’s implementation internally.
In the code we have also implemented the methods Equals(Object obj) and GetHashCode() too. A good (recommended) practice is these two methods to be consistent in their behavior, i.e. when two objects are the same, then their hash-code is the same. As we will see in the chapter about hash tables, the opposite is not necessary at all. Similarly – the expected behavior of the Equals(Object obj) is to return true, exactly when CompareTo(T obj) returns 0.
 	It’s recommended to sync the work of Equals(Object obj), CompareTo(T obj) and GetHashCode() methods. This is their expected behavior and it will save you a lot of hard to find problems.
Till now, we have discussed the methods, suggested by our class. Now let’s see what fields it provides. They are respectively for value (the key) of type T parent – parent, left and right successor – leftChild and rightChild. The last three are of the type of the defining them class – BinaryTreeNode
Ordered Binary Trees – Implementation of the Main Class
Now, we go to the implementation of the class, describing an ordered binary tree – BinarySearchTree<T>. The tree by itself as a structure consists of a root node of type BinaryTreeNode<T>, which contains internally its successors – left and right. Internally they also contain their successors, thus recursively down until it reaches the leaves.
An important thing is the definition BinarySearchTree<T> where T : IComparable<T>. This constraint of the type T is necessary because of the requirement of our internal class, which works only with types, implementing IComparable<T>. Due to this restriction we can use BinarySearchTree<int> and BinarySearchTree<string>, but cannot use BinarySearchTree<int[]> and BinarySearchTree<StreamReader>, because int[] and StreamReader are not comparable, while int and string are.
BinarySearchTree.cs
public class BinarySearchTree<T>	where T : IComparable<T>
{
	/// <summary>
	/// Represents a binary tree node
	/// </summary>
	/// <typeparam name="T">The type of the nodes</typeparam>
	internal class BinaryTreeNode<T> :
		IComparable<BinaryTreeNode<T>> where T : IComparable<T>
	{
		// …
		// … The implementation from above comes here!!! …
		// …
	}

	/// <summary>
	/// The root of the tree
	/// </summary>
	private BinaryTreeNode<T> root;

	/// <summary>
	/// Constructs the tree
	/// </summary>
	public BinarySearchTree()
	{
		this.root = null;
	}

	// …
	// … The implementation of tree operations come here!!! …
	// …
}
As we mentioned above, now we will examine the following operations:
	insert an element;
	searching for an element;
	removing an element.
Inserting an Element
Inserting (or adding) an element in a binary search tree means to put a new element somewhere in the tree so that the tree must stay ordered. Here is the algorithm: if the tree is empty, we add the new element as a root. Otherwise:
	If the element is smaller than the root, we call recursively the same method to add the element in the left sub-tree.
	If the element is bigger than the root, we call recursively to the same method to add the element in the right sub-tree.
	If the element is equal to the root, we don’t do anything and exit from the recursion.
We can clearly see how the algorithm for inserting a node, conforms to the rule "elements in the left sub-tree are less than the root and the elements in the right sub-tree are bigger than the root". Here is a sample implementation of this method. You should notice that in the addition there is a reference to the parent, which is supported because the parent must be changed too.
/// <summary>Inserts new value in the binary search tree
/// </summary>
/// <param name="value">the value to be inserted</param>
public void Insert(T value)
{
	this.root = Insert(value, null, root);
}

/// <summary>
/// Inserts node in the binary search tree by given value
/// </summary>
/// <param name="value">the new value</param>
/// <param name="parentNode">the parent of the new node</param>
/// <param name="node">current node</param>
/// <returns>the inserted node</returns>
private BinaryTreeNode<T> Insert(T value,
		BinaryTreeNode<T> parentNode, BinaryTreeNode<T> node)
{
	if (node == null)
	{
		node = new BinaryTreeNode<T>(value);
		node.parent = parentNode;
	}
	else
	{
		int compareTo = value.CompareTo(node.value);
		if (compareTo < 0)
		{
			node.leftChild =
				Insert(value, node, node.leftChild);
		}
		else if (compareTo > 0)
		{
			node.rightChild =
				Insert(value, node, node.rightChild);
		}
	}

	return node;
}
Searching for an Element
Searching in a binary search tree is an operation which is more intuitive. In the sample code we have shown how the search of an element can be done without recursion and with iteration instead. The algorithm starts with element node, pointing to the root. After that we do the following:
	If the element is equal to node, we have found the searched element and return it.
	If the element is smaller than node, we assign to node its left successor, i.e. we continue the searching in the left sub-tree.
	If the element is bigger than node, we assign to node its right successor, i.e. we continue the searching in the right sub-tree.
At the end, the algorithm returns the found node or null if there is no such node in the tree. Additionally we define a Boolean method that checks if certain value belongs to the tree. Here is the sample code:
/// <summary>Finds a given value in the tree and
/// return the node which contains it if such exsists
/// </summary>
/// <param name="value">the value to be found</param>
/// <returns>the found node or null if not found</returns>
private BinaryTreeNode<T> Find(T value)
{
	BinaryTreeNode<T> node = this.root;
	while (node != null)
	{
		int compareTo = value.CompareTo(node.value);
		if (compareTo < 0)
		{
			node = node.leftChild;
		}
		else if (compareTo > 0)
		{
			node = node.rightChild;
		}
		else
		{
			break;
		}
	}

	return node;
}

/// <summary>Returns whether given value exists in the tree
/// </summary>
/// <param name="value">the value to be checked</param>
/// <returns>true if the value is found in the tree</returns>
public bool Contains(T value)
{
	bool found = this.Find(value) != null;
	return found;
}
Removing an Element
Removing is the most complicated operation from the basic binary search tree operations. After it the tree must keep its order.
The first step before we remove an element from the tree is to find it. We already know how it happens. After that, we have 3 cases:
	If the node is a leaf – we point its parent’s reference to null. If the element has no parent, it means that it is a root and we just remove it.
	If the node has only one sub-tree – left or right, it is replacing with the root of this sub-tree.
	The node has two sub-trees. Then we have to find the smallest node in the right sub-tree and swap with it. After this exchange the node will have one sub-tree at most and then we remove it grounded on some of the above two rules. Here we have to say that it can be done analogical swap, just that we get the left sub-tree and it is the biggest element.
We leave to the reader to check the correctness of these three steps, as a little exercise.
Now, let’s see a sample removal in action. Again we will use our ordered tree, which we have displayed at the beginning of this point. For example, let’s remove the element with key 11.
 
The node 11 has two sub-trees and according to our algorithm, it must be exchanged with the smallest element from the right sub-tree, i.e. with 13. After the exchange, we can remove 11 (it is a leaf). Here is the final result:
 
Below is the sample code, which implements the described algorithm:
/// <summary>Removes an element from the tree if exists
/// </summary>
/// <param name="value">the value to be deleted</param>
public void Remove(T value)
{
	BinaryTreeNode<T> nodeToDelete = Find(value);
	if (nodeToDelete != null)
	{
		Remove(nodeToDelete);
	}
}

private void Remove(BinaryTreeNode<T> node)
{
	// Case 3: If the node has two children.
	// Note that if we get here at the end
	// the node will be with at most one child
	if (node.leftChild != null && node.rightChild != null)
	{
		BinaryTreeNode<T> replacement = node.rightChild;
		while (replacement.leftChild != null)
		{
			replacement = replacement.leftChild;
		}
		node.value = replacement.value;
		node = replacement;
	}

	// Case 1 and 2: If the node has at most one child
	BinaryTreeNode<T> theChild = node.leftChild != null ?
			node.leftChild : node.rightChild;

	// If the element to be deleted has one child
	if (theChild != null)
	{
		theChild.parent = node.parent;

		// Handle the case when the element is the root
		if (node.parent == null)
		{
			root = theChild;
		}
		else
		{
			// Replace the element with its child sub-tree
			if (node.parent.leftChild == node)
			{
				node.parent.leftChild = theChild;
			}
			else
			{
				node.parent.rightChild = theChild;
			}
		}
	}
	else
	{
		// Handle the case when the element is the root
		if (node.parent == null)
		{
			root = null;
		}
		else
		{
			// Remove the element - it is a leaf
			if (node.parent.leftChild == node)
			{
				node.parent.leftChild = null;
			}
			else
			{
				node.parent.rightChild = null;
			}
		}
	}
}
We add also a DFS traversal method to enable printing the values stored in the tree in ascending order (in-order):
/// <summary>Traverses and prints the tree</summary>
public void PrintTreeDFS()
{
	PrintTreeDFS(this.root);
	Console.WriteLine();
}

/// <summary>Traverses and prints the ordered binary search tree
/// tree starting from given root node.</summary>
/// <param name="node">the starting node</param>
private void PrintTreeDFS(BinaryTreeNode<T> node)
{
	if (node != null)
	{
		PrintTreeDFS(node.leftChild);
		Console.Write(node.value + " ");
		PrintTreeDFS(node.rightChild);
	}
}
Finally we demonstrate our ordered binary search tree in action:
class BinarySearchTreeExample
{
	static void Main()
	{
		BinarySearchTree<string> tree =
			new BinarySearchTree<string>();
		tree.Insert("Telerik");
		tree.Insert("Google");
		tree.Insert("Microsoft");
		tree.PrintTreeDFS(); // Google Microsoft Telerik
		Console.WriteLine(tree.Contains("Telerik")); // True
		Console.WriteLine(tree.Contains("IBM")); // False
		tree.Remove("Telerik");
		Console.WriteLine(tree.Contains("Telerik")); // False
		tree.PrintTreeDFS(); // Google Microsoft
	}
}
Note that when we print our binary search tree, it is always sorted in ascending order (in our case in alphabetical order). Thus in our example the binary search tree of strings behaves like a set of strings (we will explain the "Set" data structure in the chapter "Dictionaries, Hash Tables and Sets").
It is important to know that our class BinarySearchTree<T> implements a binary search tree, but not balanced / self-balancing binary search tree. Although it works correctly, its performance can be poor in certain circumstances, like we shall explain in the next section. Balanced trees are more complex concept and use more complex algorithm which guarantees their balanced depth. Let’s take a look at them.
Balanced Trees
As we have seen above, the ordered binary trees are a very comfortable structure to search within. Defined in this way, the operations for creating and deleting the tree have a hidden flaw: they don't balance the tree and its depth could become very big.
Think a bit what will happen if we sequentially include the elements: 1, 2, 3, 4, 5, 6? The ordered binary tree will look like this:
 
In this case, the binary tree degenerates into a linked list. Because of this the searching in this tree is going to be much slower (with N steps, not with log(N)), as to check whether an item is inside, in the worst case we will have to go through all elements.
We will briefly mention the existence of data structures, which save the logarithmic behavior of the operations adding, searching and removing an element in the common case. We will introduce to you the following definitions before we go on to explain how they are achieved:
Balanced binary tree – a binary tree in which no leaf is at "much greater" depth than any other leaf. The definition of "much greater" is rough depends on the specific balancing scheme.
Perfectly balanced binary tree – binary tree in which the difference in the left and right tree nodes’ count of any node is at most one.
Without going in details we will mention that when given binary search tree is balanced, even not perfectly balanced, then the operations of adding, searching and removing an element in it will run in approximately a logarithmic number of steps even in the worst case. To avoid imbalance in the tree to search, apply operations that rearrange some elements of the tree when adding or removing an item from it. These operations are called rotations in most of the cases. The type of rotation should be further specified and depends on the implementation of the specific data structure. As examples for structures like these we can give Red-Black tree, AVL-tree, AA-tree, Splay-tree and others.
Balanced search trees allow quickly (in general case for approximately log(n) number of steps) to perform the operations like searching, adding and deleting of elements. This is due to two main reasons:
	Balanced search trees keep their elements ordered internally.
	Balanced search trees keep themselves balanced, i.e. their depth is always in order of log(n).
Due to their importance in computer science we will talk about balanced search trees and their standard implementations in .NET Framework many times when we discuss data structures and their performance in this chapter and in the next few chapters.
Balanced search trees can be binary or non-binary.
Balanced binary search trees have multiple implementations like Red-Black Trees, AA Trees and AVL Trees. All of them are ordered, balanced and binary, so they perform insert / search / delete operations very fast.
Non-binary balanced search trees also have multiple implementations with different special properties. Examples are B-Trees, B+ Trees and Interval Trees. All of them are ordered, balanced, but not binary. Their nodes can typically hold more than one key and can have more than two child nodes. These trees also perform operations like insert / search / delete very fast.
For a more detailed examination of these and other structures we recommend the reader to look closely at literature about algorithms and data structures.
The Hidden Class TreeSet<T> in .NET Framework
Once we have seen ordered binary trees and seen what their advantage is comes the time to show and what C# has ready for us concerning them. Perhaps each of you secretly hoped that he / she will never have to implement a balanced ordered binary search tree, because it looks quite complicated.
So far we have looked at what balanced trees are to get an idea about them. When you need to use them, you can always count on getting them from somewhere already implemented. In the standard libraries of the .NET Framework there are ready implementations of balanced trees, but also on the Internet you can find a lot of external libraries.
In the namespace System.Collections.Generic a class TreeSet<T> exists, which is an implementation of a red-black tree. This, as we know, means that adding, searching and deleting items in the tree will be made with logarithmic complexity (i.e. if we have one million items operation will be performed for about 20 steps). The bad news is that this class is internal and it is visible only in this library. Fortunately, this class is used internally by a class, which is publicly available – SortedDictionary<T>. More info about the SortedDictionary<T> class you can find in the section "Sets" of chapter "Dictionaries, Hash-Tables and Sets".
Graphs
The graphs are very useful and fairly common data structures. They are used to describe a wide variety of relationships between objects and in practice can be related to almost everything. As we will see later, trees are a subset of the graphs and also lists are special cases of trees and thus of graphs, i.e. the graphs represent a generalized structure that allows modeling of very large set of real-world situations.
Frequent use of graphs in practice has led to extensive research in "graph theory", in which there is a large number of known problems for graphs and for most of them there are well-known solutions.
Graphs – Basic Concepts
In this section we will introduce some of the important concepts and definitions. Some of them are similar to those introduced about the tree data structure, but as we shall see, there are very serious differences, because trees are just special cases of graphs.
Let’s consider the following sample graph (which we would later call a finite and oriented). Again, like with trees, we have numbered the graph, as it is easier to talk about any of them specifically:
 
The circles of this scheme we will call vertices (nodes) and the arrows connecting them we will call directed edges. The vertex of which the arrow comes out we will call predecessor of that the arrow points. For example "19" is a predecessor of "1". In this case, "1" is a successor of "19". Unlike the structure tree, here each vertex can have more than one predecessor. Like "21", it has three – "19", "1" and "7". If two of the vertices are connected with edge, then we say these two vertices are adjacent through this edge.
Next follows the definition of finite directed graph.
Finite directed graph is called the couple (V, E), in which V is a finite set of vertices and E is a finite set of directed edges. Each edge e that belongs to E is an ordered couple of vertices u and v or e = (u, v), which are defining it in a unique way.
For better understanding of this definition we are strongly recommending to the reader to think of the vertices as they are cities, and the directed edges as one-way roads. That way, if one of the vertices is Sofia and the other is Paris, the one-way path (edge) will be called Sofia – Paris. In fact this is one of the classic examples for the use of the graphs – in tasks with paths.
If instead of arrows, the vertices are connected with segments, then the segments will be called undirected edges, and the graph – undirected. Practically we can imagine that an undirected edge from vertex A to vertex B is two-way edge and equivalent to two opposite directed edges between the same two vertices:
 
Two vertices connected with an edge are called neighbors (adjacent).
For the edges a weight function can be assigned, that associates each edge to a real number. These numbers we will call weights (costs). For examples of the weights we can mention some distance between neighboring cities, or the length of the directed connections between two neighboring cities, or the crossing function of a pipe, etc. A graph that has weights on the edges is called weighted. Here is how it is illustrated a weighted graph.
 
Path in a graph is a sequence of vertices v1, v2, …, vn,, such as there is an edge from vi to vi+1 for every i from 1 to n-1. In our example path is the sequence "1", "12", "19", "21". "7", "21" and "1" is not a path because there is no edge starting from "21" and ending in "1".
Length of path is the number of edges connecting vertices in the sequence of the vertices in the path. This number is equal to the number of vertices in the path minus one. The length of our example for path "1", "12", "19", "21" is three.
Cost of path in a weighted graph, we call the sum of the weights (costs) of the edges involved in the path. In real life the road from Sofia to Madrid, for example, is equal to the length of the road from Sofia to Paris plus the length of the road from Madrid to Paris. In our example, the length of the path "1", "12", "19" and "21" is equal to 3 + 16 + 2 = 21.
Loop is a path in which the initial and the final vertex of the path match. Example of vertices forming loop are "1", "12" and "19". In the same time "1", "7" and "21" do not form a loop.
Looping edge we will call an edge, which starts and ends in the same vertex. In our example the vertex "14" is looped.
A connected undirected graph we call an undirected graph in which there is a path from each node to each other. For example, the following graph is not connected because there is no path from "1" to "7".
 
So we already have enough knowledge to define the concept tree in other way, as a special kind of graph:
Tree – undirected connected graph without loops.
As a small exercise we let the reader show why all definitions of tree we gave in this chapter are equivalent.
Graphs – Presentations
There are a lot of different ways to present a graph in the computer programming. Different representations have different properties and what exactly should be selected depends on the particular algorithm that we want to apply. In other words – we present the graph in a way, so that the operations that our algorithm does on it to be as fast as possible. Without falling into greater details we will set out some of the most common representations of graphs.
	List of successors – in this representation for each vertex v a list of successor vertices is kept (like the tree’s child nodes). Here again, if the graph is weighted, then to each element of the list of successors an additional field is added indicating the weight of the edge to it.
	Adjacency matrix – the graph is represented as a square matrix g[N][N], where if there is an edge from vi to vj, then the position g[i][j] is contains the value 1. If such an edge does not exist, the field g[i][j] is contains the value 0. If the graph is weighted, in the position g[i][j] we record weight of the edge, and matrix is called a matrix of weights. If between two nodes in this matrix there is no edge, then it is recorded a special value meaning infinity. If the graph is undirected, the adjacency matrix will be symmetrical.
	List of the edges – it is represented through the list of ordered pairs (vi, vj), where there is an edge from vi to vj. If the graph is weighted, instead ordered pair we have ordered triple, and its third element shows what the weight of the edge is.
	Matrix of incidence between vertices and edges – in this case, again we are using a matrix but with dimensions g[M][N], where N is the number of vertices, and M is the number of edges. Each column represents one edge, and each row a vertex. Then the column corresponding to the edge (vi, vj) will contain 1 only at position i and position j, and other items in this column will contain 0. If the edge is a loop, i.e. is (vi, vi), then on position i we record 2. If the graph we want to represent is oriented and we want to introduce edge from vi to vj, then to position i we write 1 and to the position j we write -1.
The most commonly used representation of graphs is the list of successors.
Graphs – Basic Operations
The basic operations in a graph are:
	Creating a graph
	Adding / removing a vertex / edge
	Check whether an edge exists between two vertices
	Finding the successors of given vertex
We will offer a sample implementation of the graph representation with a list of successors and we will show how to perform most of the operations. This kind of implementation is good when the most often operation we need is to get the list of all successors (child nodes) for a certain vertex. This graph representation needs a memory of order N + M where N is the number of vertices and M is the number of edges in the graph.
In essence the vertices are numbered from 0 to N-1 and our Graph class holds for each vertex a list of the numbers of all its child vertices. It does not work with the nodes, but with their numbers in the range [0...N-1]. Let’s explore the source code of our sample graph:
using System;
using System.Collections.Generic;

/// <summary>Represents a directed unweighted graph structure
/// </summary>
public class Graph
{
	// Contains the child nodes for each vertex of the graph
	// assuming that the vertices are numbered 0 ... Size-1
	private List<int>[] childNodes;

	/// <summary>Constructs an empty graph of given size</summary>
	/// <param name="size">number of vertices</param>
	public Graph(int size)
	{
		this.childNodes = new List<int>[size];
		for (int i = 0; i < size; i++)
		{
			// Assing an empty list of adjacents for each vertex
			this.childNodes[i] = new List<int>();
		}
	}

	/// <summary>Constructs a graph by given list of
	/// child nodes (successors) for each vertex</summary>
	/// <param name="childNodes">children for each node</param>
	public Graph(List<int>[] childNodes)
	{
		this.childNodes = childNodes;
	}

	/// <summary>
	/// Returns the size of the graph (number of vertices)
	/// </summary>
	public int Size
	{
		get { return this.childNodes.Length; }
	}

	/// <summary>Adds new edge from u to v</summary>
	/// <param name="u">the starting vertex</param>
	/// <param name="v">the ending vertex</param>
	public void AddEdge(int u, int v)
	{
		childNodes[u].Add(v);
	}

	/// <summary>Removes the edge from u to v if such exists
	/// </summary>
	/// <param name="u">the starting vertex</param>
	/// <param name="v">the ending vertex</param>
	public void RemoveEdge(int u, int v)
	{
		childNodes[u].Remove(v);
	}

	/// <summary>
	/// Checks whether there is an edge between vertex u and v
	/// </summary>
	/// <param name="u">the starting vertex</param>
	/// <param name="v">the ending vertex</param>
	/// <returns>true if there is an edge between
	/// vertex u and vertex v</returns>
	public bool HasEdge(int u, int v)
	{
		bool hasEdge = childNodes[u].Contains(v);
		return hasEdge;
	}

	/// <summary>Returns the successors of a given vertex
	/// </summary>
	/// <param name="v">the vertex</param>
	/// <returns>list of all successors of vertex v</returns>
	public IList<int> GetSuccessors(int v)
	{
		return childNodes[v];
	}
}
To illustrate how our graph data structure works, we will create small program that creates a graph and traverses it by the DFS algorithm. To play a bit with graphs, the goal of our graph traversal algorithm will be to count how many connected components the graph has.
By definition in undirected graph if a path exists between two nodes, they belong to the same connected component and if no path exists between two nodes, they belong to different connected components. For example consider the following undirected graph:
 
It has 3 connected components: {0, 4}, {1, 2, 6, 3} and {5}.
The code below creates a graph corresponding to the figure above and by DFS traversal finds all its connected components. This is straightforward: pass through all vertices and once unvisited vertex is found, all connected to it vertices (directly or indirectly via some a path) are found by DFS traversal, each of them is printed and marked as visited. Below is the code:
class GraphComponents
{
	static Graph graph = new Graph(new List<int>[] {
		new List<int>() {4},       // successors of vertice 0
		new List<int>() {1, 2, 6}, // successors of vertice 1
		new List<int>() {1, 6},    // successors of vertice 2
		new List<int>() {6},       // successors of vertice 3
		new List<int>() {0},       // successors of vertice 4
		new List<int>() {},        // successors of vertice 5
		new List<int>() {1, 2, 3}  // successors of vertice 6
	});

	static bool[] visited = new bool[graph.Size];

	static void TraverseDFS(int v)
	{
		if (!visited[v])
		{
			Console.Write(v + " ");
			visited[v] = true;
			foreach (int child in graph.GetSuccessors(v))
			{
				TraverseDFS(child);
			}
		}
	}

	static void Main()
	{
		Console.WriteLine("Connected graph components: ");
		for (int v = 0; v < graph.Size; v++)
		{
			if (!visited[v])
			{
				TraverseDFS(v);
				Console.WriteLine();
			}
		}
	}
}
If we run the above code, we will get the following output (the connected components of our sample graph shown above):
Connected graph components:
0 4
1 2 6 3
5
Common Graph Applications
Graphs are used to model many situations of reality, and tasks on graphs model multiple real problems that often need to be resolved. We will give just a few examples:
	Map of a city can be modeled by a weighted oriented graph. On each street, edge is compared with a length, corresponding to the length of the street, and direction – the direction of movement. If the street is a two-way, it can be compared to two edges in both directions. At each intersection there is a node. In such a model there are natural tasks such as searching for the shortest path between two intersections, checking whether there is a road between two intersections, checking for a loop (if we can turn and go back to the starting position) searching for a path with a minimum number of turns, etc.
	Computer network can be modeled by an undirected graph, whose vertices correspond to the computers in the network, and the edges correspond to the communication channels between the computers. To the edges different numbers can be compared, such as channel capacity or speed of the exchange, etc. Typical tasks for such models of a network are checking for connectivity between two computers, checking for double-connectivity between two points (existence of double-secured channel, which remains active after the failure of any computer), finding a minimal spanning tree (MST), etc. In particular, the Internet can be modeled as a graph, in which are solved problems for routing packets, which are modeled as classical graph problems.
	The river system in a given region can be modeled by a weighted directed graph, where each river is composed of one or more edges, and each node represents the place where two or more rivers flow into another one. On the edges can be set values, related to the amount of water that goes through them. Naturally with this model there are tasks such as calculating the volume of water, passing through each vertex and anticipate of possible flood in increasing quantities.
You can see that the graphs can be used to solve many real-world problems. Hundreds of books and research papers are written about graphs, graph theory and graph algorithms. There are dozens of classic tasks for graphs, for which there are known solutions or it is known that there is no efficient solution. The scope of this chapter does not allow mentioning all of them, but we hope that through the short presentation we have awaken your interest in graphs, graph algorithms and their applications and spur you to take enough time to solve the tasks about graphs in the exercises.
Exercises
	Write a program that finds the number of occurrences of a number in a tree of numbers.
	Write a program that displays the roots of those sub-trees of a tree, which have exactly k nodes, where k is an integer.
	Write a program that finds the number of leaves and number of internal vertices of a tree.
	Write a program that finds in a binary tree of numbers the sum of the vertices of each level of the tree.
	Write a program that finds and prints all vertices of a binary tree, which have for only leaves successors.
	Write a program that checks whether a binary tree is perfectly balanced.
	Let’s have as given a graph G(V, E) and two of its vertices x and y. Write a program that finds the shortest path between two vertices measured in number of vertices staying on the path.
	Let’s have as given a graph G(V, E). Write a program that checks whether the graph is cyclic.
	Implement a recursive traversal in depth in an undirected graph and a program to test it.
	Write breadth first search (BFS), based on a queue, to traverse a directed graph.
	Write a program that searches the directory C:\Windows\ and all its subdirectories recursively and prints all the files which have extension *.exe.
	Define classes File {string name, int size} and Folder {string name, File[] files, Folder[] childFolders}. Using these classes, build a tree that contains all files and directories on your hard disk, starting from C:\Windows\. Write a method that calculates the sum of the sizes of files in a sub-tree and a program that tests this method. To crawl the directories use recursively crawl depth (DFS).
	* Write a program that finds all loops in a directed graph.
	Let’s have as given a graph G (V, E). Write a program that finds all connected components of the graph, i.e. finds all maximal connected sub-graphs. A maximal connected sub-graph of G is a connected graph such that no other connected sub-graphs of G, contains it.
	Suppose we are given a weighted oriented graph G (V, E), in which the weights on the side are nonnegative numbers. Write a program that by a given vertex x from the graph finds the shortest paths from it to all other vertical.
	We have N tasks to be performed successively. We are given a list of pairs of tasks for which the second is dependent on the outcome of the first and should be executed after it. Write a program that arranges tasks in such a way that each task is be performed after all the tasks which it depends on have been completed. If no such order exists print an appropriate message.
Example: {1, 2}, {2, 5}, {2, 4}, {3, 1} ? 3, 1, 2, 5, 4
	An Eulerian cycle in a graph is called a loop that starts from a vertex, passes exactly once through all edges in the graph returns to the starting vertex. Vertices can be visited repeatedly. Write a program that by a given graph, finds whether the graph has an Euler loop.
	A Hamiltonian cycle in a graph is a cycle containing every vertex in the graph exactly once. Write a program, which by given weighted oriented graph G (V, E), finds Hamiltonian loop with a minimum length, if such exists.
Solutions and Guidelines
	Traverse the tree recursively in depth (using DFS) and count the occurrences of the given number.
	Traverse the tree recursively in depth (using DFS) and check for each node the given condition. For each node the number of nodes in its subtree is: 1 + the sum of the nodes of each of its child subtrees.
	You can solve the problem by traversing the tree in depth recursively.
	Use traversing in depth or breadth and when shifting from one node to another keep its level (depth). Knowing the levels of the nodes at each step, the wanted amount can be easily calculated.
	You can solve the problem by recursively traversing the tree in depth and by checking the given condition.
	By recursive traversal in depth (DFS) for every node of the tree calculate the depths of its left and right sub-trees. Then check immediately whether the condition of the definition for perfectly balanced tree is executed (check the difference between the left and right sub-tree’s depths).
	Use the algorithm of traversing in breadth (BFS) as a base. In the queue put every node always along with its predecessor. This will help you to restore the path between the nodes (in reverse order).
	Use traversing in depth or in breadth. Mark every node, if already visited. If at any time you reach to a node, which has already been visited, then you have found loop.
Think about how you can find and print the loop itself. Here is an idea: while traversing every node keep its predecessor. If at any moment you reach a node that has already been visited, you should have a path to the initial node. The current path in the recursion stack is also a path to the wanted node. So at some point we have two different paths from one node to the initial node. By merging the two paths you can easily find the loop.
	Use the DFS algorithm. Testing can be done with few example graphs.
	Use the BFS algorithm. Instead of putting the vertices of the graph in the queue, put their numbers (0 … N-1). This will simplify the algorithm.
	Use traversing in depth and System.IO.Directory class.
	Use the example of the tree data structure given in this chapter. Each directory from the tree should two arrays (or lists) of descendants: subdirectories and files.
	Use the solution of problem 8, but modify it so it does not stop when it finds a loop, but continues. For each loop you should check if you have already found it. This problem is more complex than you may expect!
	Use the algorithms for traversing in breadth or depth as a base.
	Use the Dijkstra’s algorithm (find it on the Internet).
	The requested order is called "topological sorting of a directed graph". It can be implemented in two ways:
For every task t we should know how many others tasks P(t) it depends on. We find task t0, which is independent, i.e. P(t0)=0 and we execute it. We reduce P(t) for every task, which depends from task t0. Again we look for a task, which is independent and we execute it. We repeat until the tasks end or until we find a moment when there is no task tk having P(tk)=0. In the last case no solution exists due to a cyclic dependency.
We can solve the task with traversing the graph in depth and printing every node just before leaving it. That means that at any time of printing of a task, all the tasks that depend on it should have already been printed. The topological sorting will be produced in reversed order.
	The graph must be connected and the degree of each of its nodes must be even in order an Eulerian cycle in a graph to exits (can you prove this?). With series of DFS traversals you can find cycles in the graph and to remove the edges involved in them. Finally, by joining the cycles you will get the Eulerian cycle. See more about Eulerian paths and cycles at http://en.wikipedia.org/wiki/Eulerian_path.
	If you write a true solution of the problem, check whether it works for a graph with 200 nodes. Do not try to solve the problem so it could work with a large number of nodes! If someone manages to solve it for large numbers of nodes, he will remain permanently in history! See also the Wikipedia article http://en.wikipedia.org/wiki/Hamiltonian_path_problem. You might try some recursive algorithm for generating all paths but accept that it will be slow. Techniques like backtracking and branch and bound could help a bit but generally this problem is NP-complete and thus no efficient solution is known to exist for it.
 
  



Chapter 21. High-Quality Programming Code

In This Chapter
In this chapter we review the basic rules and recommendations for writing quality program code. We pay attention to naming the identifiers in the program (variables, methods, parameters, classes, etc.), formatting and code organization rules, good practices for composing methods, and principles for writing quality documentation. We describe the official "Design Guidelines for Developing Class Libraries for .NET" from Microsoft. In the meantime we explain how the programming environment can automate operations such as code formatting and refactoring.
This chapter is a kind of continuation of the previous one – "Object-Oriented Programming Principles". The reader is expected to be familiar with the basic OOP principles: abstraction, inheritance, polymorphism, encapsulation and exception handling. Those do greatly affect the quality of the code.
Why Is Code Quality Important?
Let’s examine the following code:
static void Main()
{
  int value=010, i=5, w;
  switch(value){case 10:w=5;Console.WriteLine(w);break;case 9:i=0;break;
          case 8:Console.WriteLine("8 ");break;
     default:Console.WriteLine("def ");{
	        Console.WriteLine("hoho ");	}
     for (int k = 0; k < i; k++, Console.WriteLine(k - 'f'));break;} { Console.WriteLine("loop!"); }
}
Are you able to comprehend what this code does in a short glance? Does it do its job correctly, does it contain any errors?
What Does Quality Programming Code Mean?
The quality of a program encompasses two aspects: the quality perceived by the user (called external quality), and the quality in regard to the internal organization (called internal quality).
The external quality is largely determined by the operational correctness of the particular program (absence of defects). Things like usability and intuitiveness of the user interface (UI) do greatly influence the external quality as well. Performance, a term which includes operational speed, memory usage and resource utilization, also plays in the equation, whenever these things matter.
Internal quality, on the other hand, is determined by how well the program is built. It depends on whether the employed design and architecture are suitable and sufficiently simple, and whether it is easy to make a change or to add new functionality (maintainability). The comprehensibility of the implementation and the readability of the code are vital as well. In general, internal quality mostly has to do with the code of the program and its internal work.
Characteristics of Quality Code
Quality code is easy to read and understand. It is maintained easily and straightforwardly. It must withstand any kind of input without breaking or behaving strangely, and be well tested. The design and the architecture must be suitable and not over-engineered. Documentation should be at a decent level, or at least the code should be self-documenting. Formatting should be adequately chosen and applied consistently throughout the whole project.
At all levels (modules, classes, methods) there should be a strong relation and a high focus of the responsibilities (strong cohesion) – that means, a piece of code should only do one particular thing.
Functional independence (or more precisely, loose coupling) between modules, classes and methods is crucially important. Suitable and consistent naming of all program identifiers is a must. Documentation should be embedded in the code itself.
Why Should We Write Quality Code?
Let’s have a look again at our example:
static void Main()
{
  int value=010, i=5, w;
  switch(value){case 10:w=5;Console.WriteLine(w);break;case 9:i=0;break;
          case 8:Console.WriteLine("8 ");break;
     default:Console.WriteLine("def ");{
	        Console.WriteLine("hoho ");	}
     for (int k = 0; k < i; k++, Console.WriteLine(k - 'f'));break;} { Console.WriteLine("loop!"); }
}
Can you tell whether this code compiles without errors? Can you tell what it does just by glancing at it? Can you add new functionality and be sure that you will not break it up? Can you tell what the purpose of the k or the w variable is?
Visual Studio has an option for automatic code formatting. If the above code is put there and that option is invoked (via the keyboard combination [Ctrl+K, Ctrl+F]) it will be reformatted and will look completely differently. Unfortunately, the purpose of the variables will still remain unclear, but at least it should become obvious where each block ends:
static void Main()
{
	int value = 010, i = 5, w;
	switch (value)
	{
		case 10: w = 5; Console.WriteLine(w); break;
		case 9: i = 0; break;
		case 8: Console.WriteLine("8 "); break;
		default: Console.WriteLine("def ");
			{
				Console.WriteLine("hoho ");
			}
			for (int k = 0; k < i; k++, Console.WriteLine(k - 'f'));
			break;
	} { Console.WriteLine("loop!"); }
}
If everyone was writing code as in the above example, it would not be possible to create big and serious software projects, because they are written by large teams of software engineers. If every team member’s code was like that, no one would ever be able to understand how the other members’ code works (and whether it works at all), and hardly anyone could even understand his / her own code.
Over the time, a serious amount of good practices have emerged and a lot of experience has been gained for writing quality code, to enable each programmer to understand and maintain his colleagues’ code. These practices endorse a variety of rules and recommendations for code formatting, identifier naming and proper program structure, all of which make writing software easier. Consistent and quality code is especially helpful when changing and maintaining a program. Quality code is flexible and stable. Because it is self-documenting and intuitive, its intentions become clear at a first sight. Quality code is easy to reuse because it does just one thing (strong cohesion), but does it well, depending on a minimal amount of other components (loose coupling), using only their public interfaces. As an end result, quality code saves time and labor, and makes the produced software more valuable.
Some programmers consider quality code as being overly simple. They tend to think that it limits their opportunity to demonstrate their knowledge. That is the reason why they write code that is hard to read, and for using features of the language which are unpopular or poorly documented. They squeeze functions on a single line. This is an entirely wrong practice.
Coding Conventions
Before continue with the recommendations on writing quality code, we should talk a bit about coding conventions. A coding convention is a set of rules for writing code, used within the boundaries of a particular organization or a project. It can include naming and formatting rules, and rules for logical composition. One such rule would recommend that class names start with a capital letter while variable names start with a lowercase letter. Another rule may state that the opening curly bracket preceding a block of statements should be on the same line, rather than on a new line.
 	Inconsistent usage of a single convention is worse and more dangerous than not having a convention at all.
Conventions started to emerge in big and serious projects, where a large number of programmers had each been writing in their own style and everyone was adhering to their own (if any) rules. This was making the code harder to read and has forced project managers to introduce written rules. Later, the best coding conventions gained popularity and have become a de facto standard.
Microsoft provides an official coding convention called .NET Framework Guidelines and Best Practices for .NET 4.5 (http://msdn.microsoft.com/en-us/library/ms184412.aspx).
Since then, this coding convention has gained significant popularity and has become very widespread. The naming and formatting rules presented here are in sync with the above convention from Microsoft.
Large organizations adhere to strict conventions. Among separate teams, conventions may differ, however. Most team leaders choose to stick with the official convention of Microsoft, and they eventually extend it when necessary.
 	Code quality is not just a set of rules, which must be adhered to; it is rather a way of thinking.
Managing Complexity
The management of complexity plays a central role when writing software. The main objective is to reduce the complexity that each member has to deal with at a certain moment. This way the brain of each of the members is burdened with less stuff to think about.
The complexity management starts from the architecture and the design. Each and every module (or rather, each autonomous code unit) should be designed with reducing complexity in mind.
Good practices should be applied at all levels – classes, methods, member variables, naming, operators, error handling, formatting, comments, etc. They transform a lot of the decisions about the code in a strictly-defined set of rules, which enables a developer to think about one thing less while reading and writing code.
The complexity management can be approached in another way: it is especially helpful for a developer to be able to abstract himself away from the big picture while writing a small piece of code. For that to be possible, the piece of code should have very clear boundaries, which are in-tact with the big picture. The old Roman rule "Divide and conquer" still applies when complexity is concerned.
The rules we are talking about later on are directed exactly towards eliminating complexity while working on a single, small piece of the system.
Identifier Naming
Identifiers are the names of classes, interfaces, structures, enumerations, properties, methods, parameters and variables. In C# and in many other languages, names are chosen by the developer. Names should not be random. They should be composed in such a way that they carry meaningful information about their purpose and their role in the code. This makes the code easier to read.
When naming an identifier, it is good to ask yourself these questions: What does this class do? What is the purpose of this variable? What is that method being used for? What information does this parameter hold?
Some good names are: FactorialCalculator, studentsCount, Math.PI, configFileName, CreateReport.
Some bad names are: k, k2, k3, junk, f33, KJJ, button1, variable, temp, tmp, temp_var, something, someValue.
It is especially bad to have a class or a method called Problem12. Some beginner programmers would give such a name to their solution of Problem 12 from the exercises. What will the name Problem12 tell you in a week or a month? If the problem is about finding a path in a labyrinth, name it PathInLabyrinth. Three months later you may encounter a similar problem and you will be able to find the labyrinth problem. How would you find it if you have named it inappropriately? Do not give a name that contains digits – this is an indication for bad naming.
 	The name of an identifier should describe its purpose. The solution of problem 12 from the exercises should NOT be called Problem12. That is a huge mistake!
Avoid Abbreviations
Abbreviations should be avoided because they can be confusing. What does the class name GrBxPnl tell you? Isn’t GroupBoxPanel clearer? Exceptions are made for acronyms, which are more popular than their full form, for example HTML or URL. In that sense, HTMLParser is recommended over the excessive long name HyperTextMarkupLanguageParser.
Use English
One of the most basic rules is to always use English. Would you be able to understand the code of a foreigner who names variables and methods in his own language? The one and only human language, which all programmers should know, is English.
 	English is a de facto standard in writing software. Always use English for naming the identifiers in the code (variables, methods, classes, etc.). Use English for comments as well.
Let’s see how we pick appropriate identifiers in different cases.
Consistency in Naming
Naming should be consistent. What does this mean?
In a group of methods called LoadFile(), LoadSettings(), LoadFont(), LoadImageFromFile() and LoadLibrary() it is inappropriate to have a method ReadTextFile(). The word Read is not consistent with Load.
Opposite activities should be symmetrically named (you should be able to guess the name of the opposite activity just by knowing the complementing one): LoadLibrary() goes with UnloadLibrary(), but does not go with FreeHandle(). OpenFile() goes with CloseFile(), but does not go with DeallocateResource(). It is unnatural to have AssignName next to a GetName / SetName pair.
Notice that in .NET Framework class library, big groups of classes have consistent naming: collections (the namespace and all classes use the words like Collection and List, and never their synonyms), streams are always Streams, etc.
 	Use consistent names: use the same words for the same situations, do not use synonyms. Name opposite things symmetrically.
Names of Classes, Interfaces and Other Types
From the chapter "Principles of Object-Oriented Programming" we know that classes describe real-world objects. Class names should consist of a noun (denominative or substantive) and possibly a number of adjectives (before or after the noun). For example, a class describing an African lion should be called AfricanLion.
The recommended casing of the letters (small / capital letters) for naming types in C# is Pascal Case: the first letter of every word in the name is always uppercase and the rest of the letters are lowercase. This way it is easier to read the identifier’s name (compare the lowercase name idatagridcolumnstyleeditingnotificationservice to its Pascal Case version IDataGridColumnStyleEditingNotificationService). The latter is the public class with probably the longest name in the .NET Framework (46 characters, from System.Windows.Forms).
Let’s give a few more examples. We are to write a class, which finds the prime numbers in a given range. A good name for that class is PrimeNumbers or PrimeNumbersFinder, or maybe PrimeNumbersScanner. Bad names would be FindPrimeNumber (a verb should not be used in the name of a class) or Numbers (it is not clear what the numbers are and what we are doing with them) or Prime (a class name should not be an adjective).
How Long Should Class Names Be?
In the common case, class names should not exceed 20 characters, but sometimes this rule is not adhered to if a real-world object is described which contains numerous longer words. As we saw above, it is possible to have a class with a name that is 46 characters long. Although the name is long, it is very clear what this class does. Because of this, the recommendation for class names being less than 20 characters is only advisory, not mandatory. If you are about to choose between a class name that is short and clear and another one which is longer and as clear as the short one, prefer the short name.
A bad advice would be to abbreviate names in order to keep them short. Are the following class names clear enough: CustSuppNotifSrvc, FNFException? Obviously they are not easy readable. Names like FileNotFoundException and CustomerSupportNotificationService are much clearer, although being longer.
Naming Interfaces and Other Types
Interface names should follow the same convention as class names: they are written in Pascal Case and consist of a noun and possibly a few adjectives. In order to distinguish them from the rest of the types, the convention suggests prefixing them with an "I".
Some good examples are: IEnumerable, IFormattable, IDataReader, IList, IHttpModule, ICommandExecutor.
Bad examples would be: List, FindUsers, IFast, IMemoryOptimize, Optimizer, FastFindInDatabase, CheckBox.
In .NET there is one more notation for naming interfaces: naming them so that they end in "able": ICloneable, IEnumerable, IFormattable. These are interfaces that most often augment the basic role of an object. Most interfaces, however, do not follow this notation, such as the IList and ICollection interfaces.
Names of Enumeration Types
A few formats are allowed for naming enumerations: [Noun] or [Verb] or [Adjective]. Names can be in singular or plural form. Every member of an enumerated type should be named in the same manner. The below examples show correctly named enumerations:
enum Days
{
	Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};

enum Color
{
	Black, Red, Green, Blue, Yellow, Orange, Pink, Gray, White
};
Attribute Names
Attribute names in C# should be suffixed with Attribute. For example: WebServiceAttribute. Attributes are special annotations (metadata) for a class / method or other piece of code which specify a special instruction for the compiler or the runtime. For more information see the documentation in MSDN: http://msdn.microsoft.com/en-us/library/z0w1kczw(v=vs.110).aspx.
Exception Names
The convention for naming exception classes suggests that exceptions end with Exception. The name should be informative and Pascal case should be used just like when naming classes. A good example of correctly named exception class would be FileNotFoundException. A bad example for exception class is FileNotFoundError.
Delegate Names
Delegates in C# and .NET Framework should be suffixed with Delegate or EventHandler. Thus DownloadFinishedDelegate would be a good example while WakeUpNotification would not adhere to the convention. A delegate is a data type which holds a reference to method with compatible signature. For more information about delegates see the official documentation in MSDN: http://msdn.microsoft.com/en-us/library/ms173171(v=vs.110).aspx.
Naming Namespaces
Namespaces, covered in details in the "Creating and Using Objects" chapter, should use Pascal Case like class names. The following forms are preferable:
	Company.Product.Component…
	Product.Component…
Good example for naming a namespace is: Telerik.WinControls.GridView.
Bad examples for naming namespaces are: Classes, TELERIK.CONSTANTS and Telerik_WinControlsGridView.
Assembly Names
Assembly names should match the name of the base namespace which they hold. Good examples of correctly named assemblies are:
	Telerik.WinControls.GridView.dll
	Oracle.DataAccess.dll
	Interop.CAPICOM.dll
Improper (bad) assembly names are the following:
	Telerik_WinControlsGridView.dll
	OracleDataAccess.dll
	Oracle.dll
Method Names
Method names should be PascalCase, e.g. each separate word starts with an uppercase letter.
Method names should be constructed according to the following pattern: <verb> + <object>, for example PrintReport(), LoadSettings() or SetUserName(). The object can be a noun or a noun and an adjective: ShowAnswer(), ConnectToRandomTorrentServer() or FindMaxValue().
A method name should address what that method does. If you are not able to come up with a good name, you most probably have to review the method itself and whether it is decently written.
Some bad examples for method names are: DoWork() (what kind of work?), Printer() (no verb), Find2() (why not Find7() then?), ChkErr() (abbreviations are not recommended), NextPosition() (no verb).
Sometimes a single verb is a good name for a method, as long as it becomes clear what the particular method does and what objects it operates on. For example, within a Task class, the methods Start(), Stop() and Cancel() are well-named because it is clear that they start, stop or cancel a task. In other cases a single verb is inappropriate. For example, within an Utils class, methods called Evaluate(), Create() and Stop() are inadequate because the context is not entirely clear.
Methods that Return a Value
Names of methods that return a value should describe the returned value in some way, e.g. GetNumberOfProcessors(), FindMinPath(), GetPrice(), GetRowsCount(), CreateNewInstance().
Bad examples for names of methods that return a value are the following: ShowReport() (it is not clear what the method returns), Value() (should be either GetValue() or HasValue()), Student() (no verb), Empty() (should be IsEmpty()).
Whenever a value is returned, the measuring unit should be clear: MeasureFontInPixels(…), instead of MeasureFont(…).
Single Purpose of a Method
A method that does more than one thing is hard to be appropriately named: how would you call a method that does an annual income report, downloads software updates from the web and scans the system for viruses? Maybe CreateAnnualIncomesReportDownloadUpdatesAndScanForViruses?
 	Methods should have one purpose only, solving only one task, not multiple tasks at the same time!
Methods solving multiple tasks (weak cohesion) cannot and should not be named properly. They must be refactored.
Cohesion and Naming
A name should describe everything that the method does. If a suitable name cannot be found, it most probably means that the cohesion is weak, i.e. the method does many things and should be split up into separate methods.
Here is an example: we have a method that sends an e-mail, prints a report and calculates the distance between two points in 3D Euclidean space. How would you call it? Maybe SendEmailAndPrintReportAndCalc3DDistance()? It is obvious that something is wrong with this method – we should refactor it instead of striving to find a better name. It is even worse if that method is simply called SendEmail(). This way we are misleading other programmers that this method only sends email, while in reality it does many other things. The last is very, very bad practice.
 	Naming a method misleadingly is even worse than naming it method1(). If a method calculates a cosine and we name it sqrt(), we will likely enrage other colleagues that are willing to use our code.
How Long Should Method Names Be?
The same recommendations apply here as for classes – you should not abbreviate unless it is clear. The names should be meaningful and this is more important than its length. If the method name is too long (e.g. more than 50 characters), check whether it does a single task.
Good method names are: LoadCustomerSupportNotificationService(), Math.Sqrt(), CreateMonthlyAndAnnualIncomesReport().
Bad method names are LoadCustSuppSrvc(), CreateMonthIncReport().
Method Parameters
Parameters should be named in the following form: [Noun] or [Adjective] + [Noun]. Every word of the name should start with an uppercase letter, except for the first word. This notation is called camelCase. As with any other code element, parameter naming should be meaningful and should carry useful information.
Good examples of parameter names are the following: firstName, report, fontSizeInPixels, speedKmH, font, usersList.
Bad examples of parameter names are: p, p1, p2, populate, LastName, last_name, convertImage.
Property Names
Property names start with an uppercase letter (PascalCase, like methods), but do not contain a verb (like variables). A property name consists of an [Adjective] + [Noun] or just [Noun].
In the presence of a property called X, it is not a good practice to have a method called GetX() – it will be confusing.
If the property is of type enumeration, you could think about naming the property like the enumeration type itself. In the presence of an enumeration called CacheLevel, the property would as well be called CacheLevel.
Using the same name for the property and its type is allowed and is usual in .NET Framework class library. For example the property Cursor of the class Button in Windows Forms is of type Cursor.
Variable Names
Variable names (local variables in a method) and member-variables (fields in a class) should adhere to the camelCase notation, according to Microsoft.
Variables should have a good name, as all other identifiers in the code should. A good variable name clearly and precisely describes the object that the variable holds. Good variable names are: account, blockSize and customerDiscount. Bad names are: r18pq, __hip, rcfd, val1, val2.
A name should address the problem that the variable solves. It should answer the question "What?", not "How?". In this sense, good names are employeeSalary, employees. Bad names are the ones that are irrelevant to the solved problem: myArray, customerFile, customerHashTable.
 	Prefer names from the business domain in which the software operates, not from the technical names that come from the programming language: use CompanyNames rather than StringArray.
The optimal length of a variable name is from 10 to 16 characters. The length of the name depends on the scope – variables with wider scope and a longer lifetime should have a more descriptive name:
protected Account[] customerAccounts;
Variables with a narrower scope and a shorter lifetime could have shorter length:
for (int i=0; i < customers.Length; i++) { … }
Variable names should be instantly understandable. Because of this it is not a good idea to remove vowels from the name in order to abbreviate it – btnDfltSvRzlts is not quite understandable.
The most important thing is: whatever naming rules are chosen for variables, they should be applied consistently throughout the code – in all the modules of the project and by the whole team. An inconsistently applied rule is worse than not having a rule at all.
Names of Boolean Identifiers
Parameters, properties and variables can be of a Boolean type. In this point we describe the specifics of these identifiers.
Their names should be a prerequisite for either truth or falsehood. For example, names like canRead, available, isOpen and valid are good. Examples of inadequate names for Boolean variables are: student, read, reader.
It would be useful if Boolean identifiers start with is, has or can (with an uppercase letter for properties), but only if this adds for clarity.
Negated names should not be used (avoid prefixing with "not"), because the following oddities may occur:
if (! notFound) { … }
Good examples: configFileLoaded, hasPendingPayment, customerFound, validAddress, positiveBalance, isPrime.
Bad examples: notFound, fsafdashghg, run, programStop, player, list, findCustomerById, isUnsuccessfull.
Named Constants
Like we already know from the chapter "Defining Classes" constants in C# are something like static immutable variables and are defined as follows:
public struct Int32
{
	public const int MaxValue = 2147483647;
}
Names of constants should be written in Pascal Case or entirely in uppercase, with underscores between words (ALL_CAPS):
public static class Math
{
	public const double PI = 3.14159265359;
	public const double GoldenRatio = 1.61803398875;
}
Named constants should clearly describe what the purpose of the particular number, string or whatever value is, rather than the value itself. A constant named number314159 is useless and confusing.
The official recommendation from Microsoft for naming the constants (const and readonly identifiers) is to use Pascal Case but some developers prefer the ALL_CAPS style which is widely used in C++ and Java.
Naming of Specific Data Types
Names of variables used as counters are recommended to contain a word that specifies that, for example usersCount, rolesCount, filesCount.
Variables that represent the state of an object should be named accordingly. A few examples: threadState, transactionState.
Temporary variables should most often have common and short names, which make obvious that they are temporary, with a very short lifetime. Good examples are index, oldValue, count. Inappropriate names are a, aa, tmpvar1, tmpvar2. Although using names like tmp and temp is acceptable it is better to choose more meaningful name like oldValue and lastIndex.
Naming by Prefixing or Suffixing
Prefix and suffix naming conventions do exist in older languages such as C. A very popular notation during many years has been the Hungarian notation. Hungarian notation is a prefix naming notation in which every variable comes with a prefix that indicates its type and purpose. For example, in Win32 API, the name lpcstrUserName would mean a variable that is a pointer to an array of characters, which ends in 0, and is interpreted as a non-Unicode string.
In C#, .NET Framework, Java and all modern programming languages, similar conventions have never gained popularity because the development environments are able to show the type of any variable. Do not use Hungarian notation in C#! Exceptions are made by some graphics libraries, to a certain extent.
Code Formatting
Formatting, along with naming is one of the most basic prerequisites for readable code. Without proper formatting, the code is not going to be readable, whatever rules for naming and code structuring are chosen.
Formatting has two objectives: easier to read code, and, as a consequence – code that is easy to maintain. Formatting that makes the code harder to read is not good. Every aspect of formatting (indentation, empty lines, alignment, etc.) can provide benefits as well as cause harm. Formatting should follow the logical structure of the program so that the logical understanding is supported.
 	The formatting of a program should represent its logical structure. All formatting rules are introduced towards improving code readability by exposing its logical structure.
In Visual Studio, the code can be automatically formatted with the [Ctrl+K, Ctrl+F] key combination. Different standards can be applied whenever auto formatting is performed – the Microsoft conventions as well as user-defined standards are available. Try it yourself: select a piece of code and press [Ctrl+K] followed by [Ctrl+F].
Now we are going to review the formatting rules according to the coding convention of Microsoft for C#.
Why Does Code Need Formatting?
First let’s look at the below example:
public   const    string                    FILE_NAME
="example.bin"  ;  static void Main   (             ){
FileStream   fs=     new FileStream(FILE_NAME,FileMode
.   CreateNew)   // Create the writer      for data  .
;BinaryWriter w=new BinaryWriter     (    fs      );//
Write data to                               Test.data.
for(  int i=0;i<11;i++){w.Write((int)i);}w   .Close();
fs   .   Close  (  ) // Create the reader    for data.
;fs=new FileStream(FILE_NAME,FileMode.            Open
,  FileAccess.Read)     ;BinaryReader                r
= new BinaryReader(fs);  // Read data from  Test.data.
for (int i = 0; i < 11; i++){ Console      .WriteLine
(r.ReadInt32                                       ())
;}r       .    Close   (   );  fs .  Close  (  )  ;  }
Is that enough as an answer?
Block Formatting
Blocks are surrounded by "{" and "}". In C# they should be on separate lines (unlike in Java and JavaScript). The contents of the block should be indented to the right by a single tab:
if (some condition)
{
	// Block contents indented by a single [Tab]
	// Don't use spaces for indentation
}
This rule applies for namespaces, classes, methods, conditional statements, loops, etc.
Nested blocks are indented additionally. The body of the class here is indented relative to the body of the namespace, and the body of the method is indented additionally, as well as the conditional statement:
namespace Chapter_21_Quality_Code
{
	public class IndentationExample
	{
		private int Zero()
		{
			if (true)
			{
				return 0;
			}
		}
	}
}
Rules for Formatting a Method
According to the Microsoft’s coding convention, some formatting rules when declaring methods should be adhered to.
Formatting Multiple Method Declarations
Whenever a class has more than one method, their declarations should be separated by an empty line:
IndentationExample.cs
public class IndentationExample
{

	public static void FirstMethod()
	{
		// …
	} // One blank line follows

	public static void SecondMethod()
	{
		// …
	}
}
How to Put Parentheses?
The Microsoft coding convention suggests that a space should be put between a keyword (for, while, if, switch) and an opening parenthesis:
while (!EOF)
{
	// … Code …
}
This is made for the keywords to stand out.
Next to a method name and before an opening parenthesis, no whitespace should be present:
public void CalculateCircumference(int radius)
{
	return 2 * Math.PI * radius;
}
In this line of thought, between the name of the method and the opening parenthesis "(" there should not be any whitespace (spaces, tabs etc.):
public static void PrintLogo()
{
	// … Code …
}
Formatting the Parameter List of Methods: Space after Commas
When a method has many parameters, we should put a space between the previous comma and the type of the next parameter, but not before the comma:
public void CalcDistance(Point startPoint, Point endPoint)
Similarly, the same rule is applied when calling a method with more than one parameter. Before the arguments preceded by a comma, a space should be put:
DoSmth(1, 2, 3);
Rules for Formatting of Types
When classes, interfaces, structures and enumerations are created, a few recommendations should be followed for formatting the code inside.
Rules for Ordering the Contents of a Class
As we know, the class name is declared on the first line, preceded by the class keyword:
public class Dog
{
Constants follow next. They should be ordered according to their access modifier – public constants are first, then protected and then private:
	// Static variables
	public const string SPECIES = "Canis Lupus Familiaris";
Then follow the non-static fields. Like static fields, those labeled public are first, then protected and finally private fields follow:
	// Instance variables
	private int age;
After non-static class fields, constructor declarations follow:
	// Constructors
	public Dog(string name, int age)
	{
		this.Name = name;
		this.age = age;
	}
After the constructors, properties are declared:
	// Properties
	public string Name { get; set; }
Finally, after the properties, the methods are declared. It is recommended that methods are grouped by functionality, not by access level or scope. For example, a method with a private access modifier could easily be between two methods with a public modifier in order to make reading and understanding the code easier. We end by putting a curly bracket for the end of the class:
	// Methods
	public void Breath()
	{
		// TODO: breathing process
	}

	public void Bark()
	{
		Console.WriteLine("wow-wow");
	}
}
Formatting Rules for Loops and Conditional Statements
Formatting of loops and conditional statements follows the same rules as methods and classes. The body of a conditional statement or a loop is always put in a block beginning with "{" and ending with "}". The opening bracket is always on a new line, immediately after the condition of the loop or the conditional statement. The body of a loop or a conditional statement is always indented to the right by a single tabulation. If the condition is long and does not fit at a single line, it is carried over on a new line and then indented to the right by two tabs. Here is an example of a correctly formatted loop and a conditional statement:
static void Main()
{
	Dictionary<int, string> bulgarianNumbersHashtable =
		new Dictionary<int, string>();
	bulgarianNumbersHashtable.Add(1, "one");
	bulgarianNumbersHashtable.Add(2, "two");
	bulgarianNumbersHashtable.Add(3, "three");

	foreach (KeyValuePair<int, string> pair in
		bulgarianNumbersHashtable.ToArray())
	{
		Console.WriteLine("Pair: [{0},{1}]", pair.Key, pair.Value);
	}
}
It is especially wrong to indent the body of a loop or a conditional statement as follows:
foreach (Student s in students) {
			   Console.WriteLine(s.Name);
			   Console.WriteLine(s.Age);
}
Usage of Empty Lines
It is very common for beginner programmers to insert empty lines in a chaotic manner. Really, when new lines do not harm, why shouldn’t we put them wherever we want and why should we remove them since they do not affect the meaning of the code? The reason is very simple: empty lines are used for separating parts of the program, which are not logically connected, much like new lines separate the end and the beginning of two paragraphs.
Empty lines are used to separate two methods, to separate a group of member-variables from another group of member-variables with a different logical task, for separating a group of related statements from another group of related statements.
Here is a bad example of two methods in which empty lines are used inappropriately and that hinders code readability:
public static void PrintList(IList<int> list)
{
	Console.Write("{ ");
	foreach (int item in list)
	{
		Console.Write(item);

		Console.Write(" ");


	}
	Console.WriteLine("}");
}
static void Main()
{
	IList<int> firstList = new List<int>();
	firstList.Add(1);

	firstList.Add(2);
	firstList.Add(3);
	firstList.Add(4);
	firstList.Add(5);
	Console.Write("firstList = ");
	PrintList(firstList);
	List<int> secondList = new List<int>();
	secondList.Add(2);

	secondList.Add(4);
	secondList.Add(6);
	Console.Write("secondList = ");
	PrintList(secondList);
	List<int> unionList = new List<int>();
	unionList.AddRange(firstList);
	Console.Write("union = ");

	PrintList(unionList);
}
You see that the empty lines do not represent the logical structure of the program, and that is why they break the main rule in formatting.
If we reformat the program so that empty lines are properly used to separate logically related groups of statements, we will come up with much more readable code:
public static void PrintList(IList<int> list)
{
	Console.Write("{ ");
	foreach (int item in list)
	{
		Console.Write(item);
		Console.Write(" ");
	}
	Console.WriteLine("}");
}

static void Main()
{
	IList<int> firstList = new List<int>();
	firstList.Add(1);
	firstList.Add(2);
	firstList.Add(3);
	firstList.Add(4);
	Console.Write("firstList = ");
	PrintList(firstList);

	List<int> secondList = new List<int>();
	secondList.Add(2);
	secondList.Add(4);
	secondList.Add(6);
	Console.Write("secondList = ");
	PrintList(secondList);

	List<int> unionList = new List<int>();
	unionList.AddRange(firstList);
	Console.Write("union = ");
	PrintList(unionList);
}
Rules for Moving to the Next Line and Alignment
When a line is longer, split it up into two or more lines and indent the lines after the first one by a single tab:
Dictionary<int, string> egyptianNumbersHashtable =
	new Dictionary<int, string>();
It is wrong to align similar statements according to the longest of them, since that can obstruct the maintenance of the code:
DateTime				date			= DateTime.Now.Date;
int						count		= 0;
Student	 				student		= new Strudent();
List<Student>		students 	= new List<Student>();
Or
matrix[x, y]									== 0;
matrix[x + 1, y + 1]						== 0;
matrix[2 * x + y, 2 * y + x] 		== 0;
matrix[x * y, x * y]						== 0;
It is wrong to align arguments to the right, based on the opening parenthesis of a method call:
Console.WriteLine("word '{0}' is seen {1} times in the text",
                  wordEntry.Key,
                  wordEntry.Value);
The above code should be properly formatted as follows (this is not the only proper way, though):
Console.WriteLine(
	"word '{0}' is seen {1} times in the text",
	wordEntry.Key,
	wordEntry.Value);
High-Quality Classes
Let’s now discuss the classes and the best practices about using efficiently classes when writing high-quality code.
Software Design
When a system is designed, separate subtasks are often divided into separate modules or subsystems. The task that each one solves must be clearly defined. The relationships between the modules should be decided in advance, not on the go.
In the previous chapter we explained OOP and we showed how object-oriented modeling can be used to define classes of the real actors in the domain of the solved problem. We mentioned design patterns as well.
Good software design has minimal complexity and is easy to understand. It is maintained easily and changes are incorporated straightforwardly (see the "Spaghetti Code" section in the previous chapter). Every program element (method, class, module) is logically connected internally (strong cohesion), functionally-independent and minimally tied to the other modules (loose coupling). Well-designed code is easily reused.
Object-Oriented Programming (OOP)
When creating quality classes, the main rules stem from the four main OO principles: abstraction, inheritance, encapsulation and polymorphism.
Abstraction
A few basic rules:
	Public properties of a class should have the same level of abstraction.
	The interface of a class should be simple and clear.
	A class should describe only one thing.
	A class should hide its internal implementation.
Code is developed and changes and evolves over time. In spite of the evolution of classes, their interfaces should remain in-tact. A bad practice of a class having inconsistent interface is shown below:
class Employee
{
	public string firstName;
	public string lastName;
	…
	public SqlCommand FindByPrimaryKeySqlCommand(int id);
}
The latter method is incompatible with the level of abstraction at which Employee works. The user of this class should not be aware at all that a database is used internally.
Inheritance
Do not hide methods in derived classes:
public class Timer
{
	public void Start() { … }
}

public class AtomTimer : Timer
{
	public void Start() { … }
}
The method in the derived class hides the base (original) implementation. This is not recommended. If, in a rare case, this is desired and necessary, the keyword new should be used.
Move common methods, data and behavior as high as possible in the inheritance tree. This way, functionality is less likely to be duplicated and will be accessible to a wider audience.
If you have a class with a single successor only, consider this suspicious. That level of abstraction is probably unnecessary. A suspicious method would be one that re-implements a base method, but does nothing more than the corresponding base method.
Deep inheritance with more than 6 levels is hard for tracing, debugging and maintaining, and is not recommended. In a derived class, use member-variables through properties, rather than directly.
The example below demonstrates wrongly written code when inheritance should be preferred over type checking:
switch (shape.Type)
{
	case Shape.Circle:
		shape.DrawCircle();
		break;
	case Shape.Square:
		shape.DrawSquare();
		break;
	…
}
It would make more sense if Shape was inherited by Circle and Square, which implement the virtual method Shape.Draw().
Encapsulation
A good approach is to make all members private. Only those of them that should be visible from outside could be marked protected, or eventually public.
Implementation details should be hidden. The user of a high-quality class should not be aware of its inner-workings; he should only know what it does and how it is used.
Member-variables (fields) should be hidden behind properties. Public member-variables are a manifestation of low-quality code. Constants are an exception in this regard.
The public members of a class should be consistent with the abstraction represented by this class. Do not make assumptions about the usage scenario of a class.
 	Do not rely on undocumented, internal implementation logic.
Constructors
It is preferred that all class members are initialized in the constructor. Usage of an uninitialized class is dangerous. A half-initialized class is maybe even more dangerous. Initialize member-variables in the same order as they are declared.
Deep and Shallow Copy
When we assign values sometime we need to copy an object (make a duplicate). This can be done in two ways: deep copy or shallow copy.
Deep copies of an object are copies in which all member-variables are copied, and their member-variables also, and so on, until no other member-variables refer to objects. In a shallow copy, only the members at the first level are copied. Example of deep copied object and its members:
 
Shallow copies work differently. When a shallow copy is created, the original object and its copy share some of their members:
 
Shallow copies are dangerous because a change in one object leads to indirect changes in others. Notice how the change of Iren’s age in the original does not affect the age of Iren in the copy when we use deep copies. With shallow copies, the change will be reflected in both places.
High-Quality Methods
The quality of our methods is of significant importance to creating high-quality software and its maintenance. They contribute to more readable and more comprehensible programs. Methods do help us reduce the complexity of our software, in order to make it more flexible and easier to modify.
It is up to us, to what extent we will benefit from these advantages. The higher the quality of our methods, the more we gain from their usage. In the next paragraphs we are introducing some of the basic principles for creating quality methods.
Why Should We Use Methods?
Before talking about good method names, let’s spend some time and summarize the reasons for using methods.
A method solves a small problem. Many individual methods solve many small problems. Taken together, they solve a bigger problem – this is an illustration of the old Roman principle "Divide and conquer", which, in this case allows us to tackle smaller problems more easily.
With methods, the overall complexity of a task is reduced: complex problems are being split up into simpler ones, additional layers of abstraction are added, implementation details are hidden, and the risk of failure is lowered. Code duplication is avoided as well. Complex sequences of actions are hidden.
Since methods are the smallest reusable unit of code, their biggest advantage is the ability they give us to reuse code. In fact, that’s exactly how methods emerged.
What Should a Method Do?
A method should do the work described by its name, and nothing more. If a method does not do what its name suggests, then either its name is wrong, or it does many things at the same time, or the method simply is incorrectly implemented. In any of these three cases, the method does not meet the requirements for code quality and should be refactored accordingly.
A method should either do its expected job, or should inform for an error and terminate. In .NET, informing for errors is done by throwing an exception. In case of invalid input, it is unacceptable for a method to return a wrong result. Instead, the method should inform the caller that it cannot do its job because the necessary preconditions are not met (such as invalid parameters being supplied, or an unexpected internal object state, etc.).
For example, suppose we have a method for reading the contents of a file. It should be called ReadFileContents() and should return byte[] or string, depending on whether we are treating the contents as binary or text. If the file does not exist or cannot be opened for whatever reason, the method should throw an exception rather than return an empty string or null.
Returning a neutral value (such as null) instead of an error message is generally not recommended, except in cases where that value does not collide with an error condition, such as a Find() method returning null because nothing was found. Otherwise, the caller loses its ability to handle the error, and the cause of the error is lost because of the lack of a richly informative exception.
 	A public method should either correctly accomplish exactly what its name suggests, or should inform the caller for an error by throwing an exception.
Any other behavior is incorrect!
The above rule has some exceptions when private methods are concerned. Unlike public methods, which should either work correctly or throw an exception, a compromise can be made for private methods. Since only the author of the class is supposed to call them, he should be aware of the validity of the passed arguments. Therefore, error conditions need not be handled because they can be predicted and prevented in the first place. But do not forget – this is still a compromise.
Two examples of high-quality methods:
long Sum(int[] elements)
{
	long sum = 0;
	foreach (int element in elements)
	{
		sum = sum + element;
	}
	return sum;
}

double CalcTriangleArea(double a, double b, double c)
{
	if (a <= 0 || b <= 0 || c <= 0)
	{
		throw new ArgumentException("Sides should be positive.");
	}
	double s = (a + b + c) / 2;
	double area = Math.Sqrt(s * (s - a) * (s - b) * (s - c));
	return area;
}
Strong Cohesion and Loose Coupling
The rules regarding the logical relatedness of the responsibilities (strong cohesion) and the functional independence through a minimal amount of interaction with other methods and classes (loose coupling) are of a major importance when methods are concerned.
As we already explained, a method should solve only one problem, not many. A method should not solve numerous unrelated problems and should not have side effects. Otherwise, coming up with a precise and descriptive name is hard. This means that all of our methods should have strong cohesion, i.e. be concerned towards solving a single problem.
Methods should depend as little as possible on the rest of the methods in their class and on the methods / properties / fields in other classes. This concept is called loose coupling.
In the best-case scenario, a method should depend only on its parameters and not use any other data as its input or output. Such methods can be easily pulled out and reused in another project, because they are unbound to the environment in which they execute.
Sometimes methods depend on private variables declared within their class, or they alter the state of the object they belong to. This is not wrong and is entirely OK. In such a case we are talking about coupling between the method and its class. Such coupling is not problematic because the class and its internal data and logic are encapsulated: the whole class can still be moved into another project and reused without any modifications.
Most of the classes from .NET Common Type System (CTS) and .NET Framework define methods that depend only on the data within their class and the passed arguments. In standard libraries, the methods dependencies from external classes are minimal and that is why they are easy to reuse. The .NET Framework class library strongly follows the idea of loose coupling.
Whenever a method reads or modifies global data and depends on 10 additional objects, which must be initialized within the instance of its own class, it is considered a coupled to its environment and to all of these objects. This means that it functions in an overly complex way and is affected by too many external conditions, therefore the probability for an error is high. Methods that depend on too many external conditions are hard to read, understand and maintain. Strong functional coupling is bad and should be avoided as much as possible, because it often leads to spaghetti code.
Look at the same two methods like at our previous example. They are slightly modified and no longer fulfill the requirements of loose coupling and strong cohesion. Do you spot errors?
long Sum(int[] elements)
{
	long sum = 0;
	for (int i = 0; i < elements.Length; i++)
	{
		sum = sum + elements[i];
		elements[i] = 0; // Hidden side effect
	}
	return sum;
}

double CalcTriangleArea(double a, double b, double c)
{
	if (a <= 0 || b <= 0 || c <= 0)
	{
		return 0; // Incorrect result
	}
	double s = (a + b + c) / 2;
	double area = Math.Sqrt(s * (s - a) * (s - b) * (s - c));
	return area;
}
How Long Should a Method Be?
Throughout the years, research has been done regarding the optimal length of methods, but after all, a universal formula has not been found.
The practice shows that, in general, shorter methods (not longer than a single screen) should be preferred. Such methods are visible on the screen without scrolling and this simplifies their reading and understanding and the probability for making mistakes.
The longer a method, the more complex it becomes. Consequent modifica¬tions become considerably harder and more time-consuming than with shorter methods. These factors lead towards errors and harder maintenance.
The recommended length of a method is not more than a single screen, but this recommendation is only advisory. If a method fits on the screen, it is easier to read because scrolling is not needed. If a method is longer than one screen, we should think whether we can split it up into a few simpler methods. Since splitting is not always possible to be done in a meaningful way, the recommendation about method length is only advisory.
Although longer methods are not preferred, the latter should not be an absolute excuse for splitting up a method only to make it shorter. Methods should be as long as necessary.
 	Strong cohesion of methods is much more important than their length.
If we are implementing a complex algorithm and consequently come up with a longer, meaningful method, which does one thing and does it well, the length is not a problem.
In any case, we should at least consider splitting up a longer method into smaller methods solving particular subtasks, whenever the method becomes too long.
Method Parameters
One of the basic rules for ordering method parameters is that the primary one(s) should precede the rest. For example:
public void Archive(PersonData person, bool persistent) { … }
The opposite would be much more confusing:
public void Archive(bool persistent, PersonData person) { … }
Another rule is to have meaningful parameter names. A common mistake is to tie the parameter names to their type:
public void Archive(PersonData personData) { … }
Instead of the meaningless personData (which carries information only about the type), we can use a better name so that it becomes clear what kind of an object we are archiving:
public void Archive(PersonData loggedUser) { … }
If there are other methods with similar parameters, their ordering should be consistent:
public void Archive(PersonData person, bool persistent) { … }

public void Retrieve(PersonData person, bool persistent) { … }
It is important that no parameters are left unused. Unused parameters can only mislead the person who uses the code.
Parameters should not be used as local variables, that is, they should not be modified. Modifying method parameters makes the code harder to read and the logic becomes more convoluted. You can always declare a new variable instead of modifying a parameter. Conserving memory is not an excuse in such a scenario.
Implicit assumptions should be documented. An example would be to specify the measurement unit of a parameter to a method that computes the cosine of an angle – whether the angle is in radians or degrees, in case the name does not make it obvious.
The parameter count should not exceed 7. Seven is a special, magic number. It is proven in the psychology that the human mind cannot trace more than 7 (+/- 2) things simultaneously. As with parameter count, this recommendation is only advisory. Sometimes you need to pass more parameters. If that is the case, think about passing them as an object that represents a class with many fields. For example, instead of having an AddStudent(…) method with 15 parameters (name, address, contacts, etc.), you can reduce them by grouping logically related parameters into separate objects: AddStudent(personalData, contacts, universityDetails). This way, each of the three parameters will contain a few fields inside, and the same information will be passed to the method, but in an easier to understand form.
Sometimes it is more appropriate, from a logical standpoint, to pass only one or a few of the fields of an object, rather than the whole object. This mostly depends on whether the method should be aware of the existence of this object or not. Suppose we have a method that calculates the final grade of a given student – CalcFinalGrade(Student s). Because the final grade depends only on the previous grades and the rest of the student’s data does not matter, it would be better if only the list of grades is passed – CalcFinalGrade(IList<Grade>), instead of a Student object.
Proper Use of Variables
In this section we review a few good practices for using local variables.
Returning a Result
Whenever a result is returned, it should first be saved in a variable, before being returned. The following example does not hint at what exactly is returned:
return days * hoursPerDay * ratePerHour;
It would be better like that:
int salary = days * hoursPerDay * ratePerHour;
return salary;
There are a few reasons for saving the result before returning it. For one, the additional variable contributes to self-documenting the code and makes it clear exactly what is returned. Another reason is tracing the returned value when debugging – we can stop the program from executing as soon as the value is computed and then inspect it. A third reason is that it helps us avoid long expressions, which can become quite convoluted.
Principles for Initialization
In .NET, all member-variables (fields) belonging to a class are initialized automatically at the time of being declared (unlike C/C++). This is managed by the runtime and provides for a safer environment, less prone to errors caused from incorrectly initialized memory. All reference type variables are initialized to null and all primitive types to 0 (false for bool).
The compiler forces the explicit initialization of all local variables; otherwise a compile-time error is given. Here is an example that would cause such an error, because an attempt is made to use an uninitialized variable:
static void Main()
{
	int value;
	Console.WriteLine(value);
}
Here is how the compilation attempt looks like in Visual Studio:
 
Here is how the compilation attempt looks like in the console C# compiler:
 
Let’s look at the following more complex example:
int value;
if (condition1)
{
	if (condition2)
	{
		value = 1;
	}
}
else
{
	value = 2;
}
Console.WriteLine(value);
Fortunately, the compiler is smart enough to analyze the control flow and to catch such problems – the same error is thrown, because not all scenarios assign correctly the variable.
Note that adding an else to the nested if in the above code will make it compile without errors. If the variable is not initialized at its declaration, but is assigned to a value in all the possible paths of the control flow, the compiler will still be happy.
A good practice, however, is to initialize all variables explicitly at the time of their declaration:
int value = 0;
Student intern = null;
Partially Initialized Objects
Some objects, in order to be properly initialized, should have at least a few of their fields set. For example, an object of type Person should have valid values set for at least the name and the family name fields. This is something the compiler cannot prevent us from forgetting.
One way to solve this problem is to remove the default constructor (the one not taking any parameters) and to add one or more constructors, which take the sufficient data as their parameters, to enable the proper initialization of the object. This is the sole purpose of parameterized constructors.
Declaring a Variable within a Block or a Method
According to the coding convention for .NET, a local variable should be declared at the beginning of its enclosing block or method:
static int Archive()
{
	int result = 0; // beginning of method body
	// … Code …
}
Another example:
if (condition)
{
	int result = 0; // beginning of an "if" block
	// … Code …
}
An exception is made for variables declared within the initialization part of a for-loop:
for (int i = 0; i < data.Length; i++) { … }
The above recommendation is pretty disputable. Most good programmers prefer to declare a local variable as close to its intended place of use as possible. This helps reduce a variable’s lifetime (refer to the next paragraph), and, at the same time, the probability for mistakes.
Scope, Lifetime and Span of Variables
The term variable scope actually denotes how "famous" a variable is. In .NET, three layers of variable scope exist: static variables, member-variables of a class (fields), and local variables inside a method.
Minimizing the Variable Scope
The wider the scope of a variable, the higher the probability that more code will be tied to it, thereby increasing the level of coupling. Since strong coupling is not desirable, variable scope should be as narrow as possible.
A good approach in using variables is to initially declare them with the minimal scope, and extend it only when necessary. This is a natural way of assigning a variable the scope it needs. If you don’t know what scope to use, start with private and if needed, switch to protected or public.
Static variables should best be private and accessing them should be controlled via appropriate methods.
Here is an example of bad semantic coupling based on a static variable, a horribly bad practice:
public class Globals
{
	public static int state = 0;
}

public class Genious
{
	public static void PrintSomething()
	{
		if (Globals.state == 0)
			Console.WriteLine("Hello.");
		else
			Console.WriteLine("Good bye.");
	}
}
If the state variable was marked private, such coupling would be impossible, at least not possible directly.
Minimizing the Variable Span
The span of a variable corresponds to the average amount of lines between its occurrences in the code. Considering minimal variable span, variables should be declared and initialized as close as possible to their first occurrence in the code, and not necessarily in the beginning of a method or a code block.
Keep the variable span as small as possible! This improves the code quality, readability, understandability and maintainability because less code needs to be inspected in order to read and understand the code.
Minimizing the Variable Lifetime
The lifetime of a local variable inside a method lasts between the place of its declaration (the beginning of a block, most usually), until the end of the enclosing block. Class fields (member-variables) exist as long as their class is instantiated. Static variables last throughout the entire execution of the program.
As you may guess, the lifetime should be kept minimal. This reduces the lines of code that you should consider at the same time when reading the code. This will maximized the portion of the code you can safely ignore when you read the code. This will reduce the total complexity in your brain, because it works better with smaller and simpler pieces of code, right?
Minimizing the Variable Span and Lifetime – Example
Below we have an example of bad use of local variables (unnecessarily large span):
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23	int count;
int[] numbers = new int[100];

for (int i = 0; i < numbers.Length; i++)
{
	numbers[i] = i;
}
count = 0;

for (int i = 0; i < numbers.Length / 2; i++)
{
	numbers[i] = numbers[i] * numbers[i];
}

for (int i = 0; i < numbers.Length; i++)
{
	if (numbers[i] % 3 == 0)
	{
		count++;
	}
}

Console.WriteLine(count);	





lifetime =
23 lines
span =
23 / 4 =
5.75
In this example, the count variable’s purpose is to count the numbers, which are evenly divisible by 3. It is used only in the last for loop, but is declared and initialized long before it.
What's wrong with the above code? If you try to read it and find how the count is calculated, you will need to inspect all its 23 lines, right? The code might be written differently and the variable count might be declared and zeroed just before the last for-loop. Thus if we need to read the code and find how count is calculated, we will need to inspect only 10 lines, not 23.
See below how the above code fragment can be refactored in order to reduce the lifetime and span of the count variable:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21	int[] numbers = new int[100];
for (int i = 0; i < numbers.Length; i++)
{
	numbers[i] = i;
}

for (int i = 0; i < numbers.Length / 2; i++)
{
	numbers[i] = numbers[i] * numbers[i];
}

int count = 0;
for (int i = 0; i < numbers.Length; i++)
{
	if (numbers[i] % 3 == 0)
	{
		count++;
	}
}

Console.WriteLine(count);	








lifetime =
10 lines

span =
10 / 3 =
3.33
It is important that the programmer tracks the usage of a particular variable, along with its scope, span and lifetime. The main objective is to reduce the scope, the lifetime and the span as much as possible. This leads to an important rule about correctly using variables:
 	Declare local variables as late as possible, immediately before using them for the first time. Initialize them at the time of declaration.
Variables with a wider scope and a longer lifetime should have more descriptive names, such as totalStudentsCount instead of count. That is because they occur at more locations within a larger piece of code, and hence the context around them is not going to be entirely clear.
Variables that span across just 4-5 lines can have short and simple names, for example count. They do not need long names because their purpose becomes clear from their limited context (a few lines), and ambiguities can rarely arise there.
Use of Variables – More Rules
A very important rule is to use a variable for one purpose only. The excuse that memory is conserved the other way is not generally convincing. If a variable is used for multiple different purposes, what name can we give it? Consider a variable that is used to count the number of students, and occasionally the count of their grades. How would you call it: count, studentsCount, gradesCount or studentsOrGradesCount?
 	Use one variable for a single purpose only. Otherwise, an appropriate name cannot be found.
Unused local variables should not be present in the code. Their declarations alone are useless. Fortunately, most of the decent development environments do warn you about such anomalies.
The use of local variables with hidden meaning should be avoided. For example, John has left the variable X for Tom to see, so that he could get to the conclusion to implement another method that would use that same variable. Didn’t get it? Good, let’s hope you don’t do it either.
Proper Use of Expressions
When using expressions, the simple rule is: avoid complex expressions! A complex expression is one that performs more than one thing:
for (int i = 0; i < xCoord.Length; i++)
{
	for (int j = 0; j < yCoord.Length; j++)
	{
		matrix[i][j] =
			matrix[xCoord[FindMax(i) + 1]][yCoord[FindMin(i) + 1]] *
			matrix[yCoord[FindMax(i) + 1]][xCoord[FindMin(i) + 1]];
	}
}
In the above sample we have a complex calculation, which fills a given matrix based on a computation over some coordinates. It is in fact very hard to understand what exactly is going on, because the used expressions are overly complex.
There are many reasons to avoid the use of complex expressions as in the above example. Let’s mention a few:
	Code becomes hard to read. Therefore, tracing what is going on and whether the code is correct becomes hard, too.
	Code is hard to maintain – think about the effort involved in fixing an error, in case the code does not work as expected.
	Code is hard to fix in case of defects. If the above code throws IndexOutOfRangeException, how would we know exactly which array has been involved? It could be xCoord or yCoord or matrix, occurrences of which are all scattered within the expressions.
	Code is hard to debug. In case of an error, it would be much harder to debug a complex expression because it stays on a single line, and debuggers step through the code in terms of lines.
All of these reasons suggest that writing complex expressions is harmful and should be avoided. Instead of a single complex expression, we can write a few less complex ones and save them in variables with descriptive names. In this way the code becomes simpler, easier to read and understand and easier to maintain, debug and fix.
Let’s rewrite the above code without using complex expressions:
for (int i = 0; i < xCoord.Length; i++)
{
	for (int j = 0; j < yCoord.Length; j++)
	{
		int maxStartIndex = FindMax(i) + 1;
		int minStartIndex = FindMax(i) - 1;
		int minXcoord = xCoord[minStartIndex];
		int maxXcoord = xCoord[maxStartIndex];
		int minYcoord = yCoord[minStartIndex];
		int maxYcoord = yCoord[maxStartIndex];
		matrix[i][j] =
			matrix[maxXcoord][minYcoord] *
			matrix[maxYcoord][minXcoord];
	}
}
Notice how simple and readable the code has become. Without knowing the exact calculation that this code is supposed to do, it is still hard to understand it, but at least we can debug it in case of an exception and find which line is causing it, and eventually fix it.
 	Do not write complex expressions. Only one operation should be performed at one line, otherwise the code becomes hard to read, maintain, debug and modify.
Use of Constants
Well written code should not contain "magic numbers" and "magic strings". Such constants are all the literals in a program having a value other than 0, 1, -1, "" and null (with little exceptions).
In order to explain the concept why we need named constants, let’s examine the code below. In this code we use the number 3.14159206 (?) three times (directly and in a formula), which introduces duplicated code. If, for example, we decide to increase the precision of this constant or change it, we will need to modify the program at three different locations:
public class GeometryUtils
{
	public static double CalcCircleArea(double radius)
	{
		double area = 3.14159206 * radius * radius;
		return area;
	}

	public static double CalcCirclePerimeter(double radius)
	{
		double perimeter = 6.28318412 * radius;
		return perimeter;
	}

	public static double CalcElipseArea(
		double axis1, double axis2)
	{
		double area = 3.14159206 * axis1 * axis2;
		return area;
	}
}
It comes to mind that it is better to define the repeating values only once on the code. In .NET such values are declared as named constants as follows:
public const double PI = 3.14159206;
After this declaration, the PI constant is accessible to the whole program and can be used an unlimited number of times. In case we need to change the value, we change it at one location only, and the changes are reflected everywhere. Here is how our GeometryUtils class looks after declaring the number 3.14159206 as a named constant:
public class GeometryUtils
{
	public const double PI = 3.14159206;

	public static double CalcCircleArea(double radius)
	{
		double area = PI * radius * radius;
		return area;
	}

	public static double CalcCirclePerimeter(double radius)
	{
		double perimeter = 2 * PI * radius;
		return perimeter;
	}

	public static double CalcElipseArea(
		double axis1, double axis2)
	{
		double area = PI * axis1 * axis2;
		return area;
	}
}
When to Use Constants?
The use of constants allows us to avoid the use of "magic numbers" and strings in our programs, and enables us to give names to the numbers and strings we use. In the above example not only we avoided code duplication, but we documented the fact that the number 3.14159206 is the well-known mathematical constant ?.
Constants should be used whenever we need to use numbers or strings whose origin and meaning are not obvious. Constants should generally be defined for every number or string that is used more than once in a program (with some exceptions).
Here are a few typical cases in which named constants should be used:
	For filenames the program operates on. They need to be frequently changed and it is convenient to have them as named constants at the beginning of the program.
	For constants taking part in mathematical expressions. A good constant name improves the chance of understanding the formula.
	For buffer sizes and sizes of memory blocks. These sizes often need to be changed and that is why it is convenient to have them declared as named constants. Apart from that, using a constant named READ_BUFFER_SIZE rather than the number 8192 makes the code a lot more readable and comprehensible.
When Not to Use Constants?
Although many books recommend that all numbers and strings except 0, -1, 1, "" and null are best declared as named constants, there are a few exceptions in which declaring constants can be harmful. Remember, declaring constants is made in order to improve the readability and the maintainability of the code. When a constant does not contribute to the readability of the code, you should avoid it.
Here are a few situations in which using a named constant can be harmful:
	Error messages and other messages intended for the user ("Enter your name", for example). Making such strings named constants will actually hinder the readability.
	SQL queries in named constants are not recommended (in case you are using a database, queries are usually written in SQL, and that is usually a string in the terms of the programming language).
	Button labels, dialog box titles, menu entries and captions of other UI components should not be declared as named constants.
The .NET Framework provides libraries that facilitate internationalization and allow exporting all the messages, captions and labels from the UI in special resource files. These are not constants, however. This approach is encouraged if the program you are writing will have to be internationalized.
 	Use named constants to avoid the usage and duplication of magic numbers and strings, and mostly to improve code readability. If the introduction of a named constant hinders the readability, better leave the hardcoded value in the code!
Proper Use of Control Flow Statements
Control flow statements are represented by loops and conditional statements. We are going to review the good practices for using them properly.
With or Without Curly Brackets?
Loops and conditional statements allow their body to not be surrounded by brackets, in case the body consists only of a single statement. This can be dangerous. Consider the following example:
static void Main()
{
	int two = 2;
	if (two == 1)
		Console.WriteLine("This is the ...");
		Console.WriteLine("... number one.");
	Console.WriteLine(
		"Example of an if-clause without curly brackets.");
}
We are expecting to see only the last sentence, aren’t we? The result is a bit unexpected:
... number one.
Example of an if-clause without curly brackets.
That is because an if-statement without curly brackets only takes the first statement as its body, regardless of the indentation, which makes matters confusing.
 	Always enclose the body of loops and conditional statements in curly brackets – { and }.
Proper Usage of Conditional Statements
Conditional statements in C# are represented by the if-else and the switch-case statements.
if (condition)
{

}
else
{

}
Deep Nesting of Conditional Statements
Deep nesting of if statements is a bad practice because it obstructs the comprehensibility of the code:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44	private int Max(int a, int b, int c, int d)
{
	if (a < b)
	{
		if (b < c)
		{
			if (c < d)
			{
				return d;
			}
			else
			{
				return c;
			}
		}
		else if (b > d)
		{
			return b;
		}
		else
		{
			return d;
		}
	}
	else if (a < c)
	{
		if (c < d)
		{
			return d;
		}
		else
		{
			return c;
		}
	}
	else if (a > d)
	{
		return a;
	}
	else
	{
		return d;
	}
}
This code is hardly readable because of the deep nesting. In order to improve it, we could introduce a few more methods where parts of the logic are exported and isolated. Here is how we could do that:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35	private int Max(int a, int b)
{
	if (a < b)
	{
		return b;
	}
	else
	{
		return a;
	}
}

private int Max(int a, int b, int c)
{
	if (a < b)
	{
		return Max(b, c);
	}
	else
	{
		return Max(a, c);
	}
}

private int Max(int a, int b, int c, int d)
{
	if (a < b)
	{
		return Max(b, c, d);
	}
	else
	{
		return Max(a, c, d);
	}
}
Extracting parts of the code into separate methods is the easiest and most efficient way to reduce the level of nesting of a group of conditional statements, while preserving their logic.
The refactored method is split into a few smaller ones. The overall length of the code has been decreased by 9 lines. Each of the new methods is simpler and easier to read. As a side benefit, we get two methods that can be easily reused for other purposes.
Proper Use of Loops
Proper use of the different looping constructs is very important to the creation of quality software. In the next paragraphs we outline some of the principles, which help us decide when, and how to use a particular loop construct.
Choosing an Appropriate Looping Construct
If we are not able to decide whether to use for, while or do-while loop, we can easily pick up one, adhering to the following principles.
If we need a loop that will execute a fixed number of times, a for-loop is a good fit. This kind of loop is used in the most basic situations where interrupting the control is not necessary. The initialization, the check of the condition and the incrementing are all in the for-construct and the loop body does not care about that. The value of the counter should not be altered within the body.
If it is necessary to check some conditions in order to stop the execution of the loop, then it is probably better to pick a while loop. A while loop is suitable in cases where the exact number of iterations is not known. The execution there continues until the exit condition has been encountered. If the prerequisites for using a while loop are in place, but the loop body must unconditionally execute at least once, a do-while loop should be used instead.
Do Not Nest Too Many Loops
As with conditional statements, deep nesting of loops is a bad practice. Deep nesting usually happens because of a large number of loops and conditional statements residing in one another. This makes the code hard to read and maintain. Such code can easily be improved by moving away parts of it into separate methods. Modern development environments can do such refactoring automatically (we talk about that in the code refactoring section).
Defensive Programming
Defensive programming is a term denoting a practice towards defending the code from incorrect data. Defensive programming keeps the code from errors that nobody expects. It is implemented by checking the validity of all input data. This is the data coming from external sources, input parameters of methods, configuration files and settings, input from the user, and even the data from another local method.
The main idea behind defensive programming is that methods should check their input parameters (and other input data) and inform the caller when the object’s internal state or the input parameters are incorrect. 
Defensive programming requires that all data is checked, even if it is coming from a trusted source. If this trusted source happens to have a bug, the bug will be found earlier and more easily.
Defensive programming is implemented through assertions, exceptions and other means of error handling.
Assertions
Assertions are special conditions that should always be met. If not met, they throw an error message and the program terminates.
A quick example of assertion in C# is shown below:
void LoadTemplates(string fileName)
{
	bool templatesFileExist = File.Exists(fileName);
	Debug.Assert(templatesFileExist,
		"Can't load templates file: " + fileName);
}
Assertions vs. Exceptions
Exceptions are announcements for an error or for an unexpected event. They inform the programmer using the code for an error. Exceptions can be caught and program execution can still continue.
Assertions produce fatal errors. They cannot be caught or handled, because they are meant to indicate a bug in the code. A failed assertion causes the program to terminate.
Assertions can be turned off. The concept is to have them turned on only at the time of developing, in order to find as many bugs as possible. When turned off, the conditions are no longer checked. Turning off the assertions is plausible when the software goes to production, since these checks are affecting the performance and the messages are not always meaningful to the end user.
If a particular check should continue to exist when the software goes to production (for example, checking the input that comes from the user), it should not be implemented as an assertion in the first place. Exceptions should be used in such cases instead.
 	Assertions should only be used for conditions that, if not met, it is due to a bug in the program.
Defensive Programming with Exceptions
Exceptions provide a powerful mechanism for centralized handling of errors and unusual conditions. They are covered in details in the "Exception Handling" chapter.
Exceptions allow problematic situations to be handled at many levels. They ease the writing and the maintenance of reliable program code.
Another difference between exceptions and assertions is that, in defensive programming, exceptions are mainly used for protecting the public interface of a class or component. This provides for a fail-safe mechanism.
If the Archive method described above was a part of the public interface of an archiving component rather than an internal method, it would have to be implemented as follows:
public int Archive(PersonData user, bool persistent)
{
	if (user == null)
	{
		throw new StorageException("null parameter");
	}

	// Do some processing
	int resultFromProcessing = …

	Debug.Assert(resultFromProcessing >= 0,
		"resultFromProcessing is negative. There is a bug!");

	return resultFromProcessing;
}
The Assert still remains because it is validating a variable created within the method itself.
Exceptions should be used to inform other parts of the code for problems that should not be ignored. Throwing an exception is reasonable only in situations when an abnormal condition has occurred. For more information on the situations considered exceptional, refer to the "Exception Handling" chapter.
If a particular problem can be handled locally, the handling should be performed in the method itself and no exceptions should be thrown. If a problem cannot be handled locally, the exception should be thrown to the caller.
The thrown exceptions should be at an appropriate level of abstraction. For example GetEmployeeInfo() could throw EmployeeException, but not FileNotFoundException. The last example throws StorageException rather than NullReferenceException.
Code Documentation
The C# specification allows putting comments in the code. We are already familiar with the basic principles for writing comments. In the next few paragraphs we explain how to write effective comments.
Self-Documenting Code
A very important point to remember is that comments in the code are not the primary source of documentation. Good programming style provides the best documentation. Self-documenting code rarely needs comments because its intention becomes clear directly by reading it. Self-documenting code means a code that is easy-to-read and easy-to-understand without having comments inside.
 	The best way to document the code is to write quality code. Bad code should not be documented but should rather be rewritten! Comments are only a complement to the well-written code.
Properties of Self-Documenting Code
Self-documenting code boasts a good structure: everything mentioned in this chapter matters. The implementation should be as simple as possible so that anyone can understand it.
Self-Documenting Code – Important Questions
In order to qualify our code as self-documenting, there are a few questions we should ask ourselves:
	Is the class name appropriate and does it describe its main purpose?
	Is the public interface of the class intuitive to use?
	Does the name of a method describe its main purpose?
	Is every method performing a single, well-defined task?
	Are the names of the variables corresponding to the intent of their use?
	Are loops performing only a single task?
	Are conditional statements deeply nested?
	Does the organization of the code illustrate its logical structure?
	Is the design clear and unambiguous?
	Are implementation details hidden as much as possible?
Effective Comments
Comments can sometimes do more harm than good. Good comments do not repeat the code and do not explain it line by line: they rather clarify its idea. Comments should describe at a higher level what our intentions are. Comments enable us to think better about what we want to implement.
Here is an example of bad comments, which, instead of making the code more comprehensible, are actually annoying:
public List<int> FindPrimes(int start, int end)
{
	// Create new list of integers
	List<int> primesList = new List<int>();
	// Perform a loop from start to end
	for (int num = start; num <= end; num++)
	{
		// Declare boolean variable, initially true
		bool prime = true;
		// Perform loop from 2 to sqrt(num)
		for (int div = 2; div <= Math.Sqrt(num); div++)
		{
			// Check if div divides num with no remainder
			if (num % div == 0)
			{
				// We found a divider -> the number is not prime
				prime = false;
				// Exit from the loop
				break;
			}
			// Continue with the next loop value
		}

		// Check if the number is prime
		if (prime)
		{
			// Add the number to the list of primes
			primesList.Add(num);
		}
	}

	// Return the list of primes
	return primesList;
}
If, instead of writing naive comments, we write comments to clarify the unobvious facts in the code, comments can be very useful. Here is how the same code can be commented meaningfully:
/// <summary>Finds the primes from a range [start, end] and
/// returns them in a list.</summary>
/// <param name="start">Top of range</param>
/// <param name="end">End of range</param>
/// <returns>a list of all the found primes</returns>
public List<int> FindPrimes(int start, int end)
{
	List<int> primesList = new List<int>();
	for (int num = start; num <= end; num++)
	{
		bool isPrime = IsPrime(num);
		if (isPrime)
		{
			primesList.Add(num);
		}
	}
	return primesList;
}

/// <summary>Checks if a number is prime by checking for any
/// dividers in the range [2, sqrt(number)].</summary>
/// <param name="number">The number to be checked</param>
/// <returns>True if prime</returns>
public bool IsPrime(int number)
{
	for (int div = 2; div <= Math.Sqrt(number); div++)
	{
		if (number % div == 0)
		{
			return false;
		}
	}

	return true;
}
The logic of the code is obvious and does not need any comments. In such case it is sufficient only to describe what are the particular method’s purpose and its general idea, in a single sentence.
In order to write effective comments, it is desirable to use pseudo-code, whenever possible. Comments should be written at the time the code is written, not after that.
Productivity (i.e. writing code quickly) is never a good excuse for not writing comments. Everything that is not instantly obvious should be documented. Writing too much unnecessary comments is as bad as not having any at all.
Bad code cannot be improved by putting more comments. It should instead be rewritten or refactored.
XML Documentation in C#
You might have already noted the special comments in the code that explain the purpose of a class or a method and its parameters: 
/// <summary>Finds the primes from a range [start, end] and
/// returns them in a list.</summary>
/// <param name="start">Top of range</param>
/// <param name="end">End of range</param>
/// <returns>a list of all the found primes</returns>
public List<int> FindPrimes(int start, int end)
{ … }
This special style of documentation built-in the C# source code is called XML documentation. It is enclosed in the triple comments /// and uses few special XML tags: to document a type / method summary (<summary>), to describe method’s parameters (<param name="…">), to describe a method’s return value (<returns>), to document exceptions that eventually might be thrown (<exception cref="…"), to make a cross-reference link to related type (<seealso cref="…"/>), to describe some remarks (<remarks>), to give an example how to use the type / method (<example>), etc.
Using XML-style documentation in the source code has several advantages:
	The XML documentation is built-in the source code itself.
	The XML documentation is automatically processed by Visual Studio and is displayed in its autocomplete feature.
	The XML documentation can be compiled into an MSDN-style web site or e-book (in CHM format) through specialized tools like Sandcastle (http://shfb.codeplex.com).
More about writing and using XML documentation can be found in MSDN Library: http://msdn.microsoft.com/en-us/library/b2s063f7.aspx.
Code Refactoring
The term "refactoring" appears in 1993 and is popularized by Martin Fowler in his book with the same name. This book reviews a lot of techniques for code refactoring (called refactoring patterns). We are going to mention a few of them.
A program needs refactoring in case of code duplication. Code duplication is dangerous because a change in one place requires that all the other duplicated code be changed as well. The latter is error-prone and inconsistencies can arise therefore. Avoiding code duplication can be achieved by putting the particular piece of code in a method, or by moving common functionality to base classes.
Refactoring is necessary for methods, which have grown over time. The excessive length of a method is a good reason to think about splitting it up logically into few smaller and simpler methods.
Deeply nested constructs are another reason for refactoring. They can be eliminated by taking out a block of code into a method.
Classes that do not provide a sufficiently good level of abstraction or ones that perform unrelated tasks (weak cohesion) are candidates for refactoring as well.
Long parameter lists and public fields should also go to the fix-it list. Tightly coupled classes go in the same category.
Refactoring at Data Level
A good practice is to avoid magic numbers scattered throughout the code. They should be replaced by named constants. Variables with unclear names should be renamed. Long conditional expressions can be refactored into separate methods. Variables can be used to hold the intermediate results of expressions. A group of data that always appears together can be refactored into a separate class. Related constants should be grouped into enumerations.
Refactoring at Method and Class Level
Within a longer method, all tasks that are unrelated to its main purpose are better moved into separate methods. Similar tasks should be grouped in common classes, similar classes – in a common package. If a group of classes have common functionality, it should be moved into a base class.
Circular dependencies between the classes should not exist, they should be removed. In most cases the more common class has a reference to the more specialized class (parent-child relationship).
Unit Testing
Unit testing means to write a program that tests a certain method or class. A typical unit test executes the method that should be tested, passes a sample data to (parameters and object states) and checks whether the method’s result is correct (for this sample data), i.e. whether the method does exactly what it should do and whether it does it correctly.
A single method usually is tested by several unit tests, each implementing a different testing scenario. First, the typical case is checked. Then the border cases are checked. The border cases are special cases which could need special processing logic, e.g. the largest or the smallest possible value, the first or last element, etc. Finally the method is tested with incorrect data and an exception is expected to be thrown. Sometimes a performance test may be involved to check whether the method is fast enough.
Unit Testing – Example
Let’s see a small example – a method that sums an array of numbers:
static int Sum(int[] numbers)
{
	int sum = numbers[0];
	for (int i = 1; i < numbers.Length; i++)
	{
		sum += numbers[i];
	}
	return sum;
}
The above method may look correct but in fact it has several bugs that we will catch through unit testing. Let’s first test the typical case:
if (Sum(new int[] {1, 2}) != 3)
	throw new Exception("1 + 2 != 3");
Seems like the Sum(…) method is working correctly in its typical case: the sum 1+2 is 3 (as expected) and the above code produces nothing. The above piece of code is called "unit test". It tests a certain method, class or other functionality against certain testing scenario and notifies us if the code behaves unexpectedly. If the test passes, the code produces no result.
Let’s now test the border cases. What will happen if we sum only one number? Let’s try:
if (Sum(new int[] {1}) != 1)
	throw new Exception("Sum of 1 != 1");
Seems like our method still works correctly. New let’s try to sum an empty list of numbers. Their sum should be 0, right? Let’s try this:
if (Sum(new int[] {}) != 0)
	throw new Exception("Sum of 0 numbers != 0");
The above code produces unexpected exception in the Sum(…) method:
Unhandled Exception: System.IndexOutOfRangeException: Index was outside the bounds of the array.
We found a bug, right? Let’s fix it. We could start summing from 0 instead from the first element in the array (which could be missing when an empty array is passed as an argument). Below is the fixed code:
static int Sum(int[] numbers)
{
	int sum = 0;
	for (int i = 0; i < numbers.Length; i++)
	{
		sum += numbers[i];
	}
	return sum;
}
We repeat our last test (summing an empty array of numbers) and it now passes correctly. Next we could try other special (border) cases, e.g. summing negative numbers:
if (Sum(new int[] {-1, -2}) != -3)
	throw new Exception("-1 + -2 != -3");
What else to try? Seems like our method work correctly. We could try to find some extreme case when the method eventually fails. What will happen if we sum too big numbers? Int32 cannot hold too big integers. Let’s try:
if (Sum(new int[] { 2000000000, 2000000000 }) != 4000000000)
	throw new Exception("2000000000 + 2000000000 != 4000000000");
We found another bug in our method for summing numbers:
Unhandled Exception: System.Exception: 2000000000 + 2000000000 != 4000000000
Obviously the integer type Int32 overflows and this causes incorrect result when summing too large numbers. Let’s fix this. We can use long to keep the sum of the numbers instead of int:
static long Sum(int[] numbers)
{
	long sum = 0;
	for (int i = 0; i < numbers.Length; i++)
	{
		sum += numbers[i];
	}
	return sum;
}
Let’s repeat the last test. Now it works. What else to test? What will happen if we pass null as an argument to the Sum(…) method? The recommendations about high-quality methods say that "a method should return what its name says or throw and exception if it cannot do its job". So our method should throw an exception if we try to sum a null array. We could test this in the following way: 
try
{
	Sum(null);
	// An exception is expected --> the test fails
	throw new Exception("Null array cannot be summed.");
}
catch (NullReferenceException)
{
	// NullReferenceException is expected --> the test passes
}
The above unit test is a bit more complicated: it expects an exception and if it is not thrown, it fails.
What else to test? Maybe we could make a performance test? For example we could sum 10,000,000 numbers and expect this will take time less than 1 second (we assume a modern computer will run the tests):
DateTime startTime = DateTime.Now;
int[] arr = new int[10000000];
for (int i = 0; i < arr.Length; i++)
{
	arr[i] = 5;
}
if (Sum(arr) != 50000000)
	throw new Exception("5 + ... (10000000 times) != 50000000");
DateTime endTime = DateTime.Now;
if (endTime - startTime > new TimeSpan(0, 0, 1))
	throw new Exception("Performance issue: summing 10000000 " +
	"numbers takes more that 1 second");
The performance test passes without any issues.
We repeat all tests again to ensure that after the modifications we made all tests are still working correctly. All tests pass! We can now be confident that the Sum(…) method works correctly (even in unusual situations) and it is well tested. Let’s think about what are the benefits if we test in similar manner all methods in our code.
Benefits of Unit Testing
Unit testing has many benefits for our code quality. Let’s discuss the most important of them:
	Unit testing significantly improves the code quality. If the unit tests are well written and the entire functionality is covered, the code is expected to be bug free. In practice it is very hard to cover with tests any possible scenario so unit testing only dramatically reduces the number of bugs but does not make the code bug free.
	Unit testing allows the tests to be executed many times, continuously, e.g. at every hour. If some test fails, the problem is caught almost instantly. In software engineering the practice of executing the unit tests continuously is called "continuous integration".
	The code quality is preserved every time the method is modified. This dramatically simplifies the maintenance. If we change the algorithm inside some method or class and we have covered it well with tests, we will be sure that the new algorithm behaves the same way like the old.
	Unit tests allow code refactoring without worrying of something being broken. It can happen that we refactor the code to improve its internal quality but by mistake after the refactoring the code does not work correctly in all special cases.
All serious software development companies and software products use unit testing. For example if you download the source code of Firefox, you will notice that half of the code is written to perform unit tests over the other half of code. In practice it is impossible to write complex product (like for example MS Word or Android OS or Firefox browser) without unit testing.
Benefits of Unit Testing – Example
Let’s see one of the benefits of unit testing: the ability to change the internal implementation of a method and re-test it to ensure the new implementation works as expected. Consider the following new implementation of the Sum(…) method that uses the Sum() extension method from System.Linq:
using System;
using System.Linq;

static long Sum(int[] numbers)
{
	return numbers.Sum();
}
We will explain how the above code works in the next chapter "Lambda Expressions and LINQ". Now let’s test it to ensure this code behaves as expected. If we run the same set of tests we discussed above, we will find a problem: two of our tests do not work. The first failing test is:
if (Sum(new int[] { 2000000000, 2000000000 }) != 4000000000)
	throw new Exception("2000000000 + 2000000000 != 4000000000");
We found a bug in our new implementation of our Sum(…) method: instead of returning the correct result it produces System.OverflowException. We cannot find an easy solution to this problem so we can either assume that summing too big numbers will not be supported and modify the test to expect OverflowException or we can rewrite the Sum(…) method with a new implementation.
If we pass ahead, we will find that one more unit test fails: when we try to sum a null array, we will get System.ArgumentNullException instead of NullReferenceException. This is easy to fix by modifying the unit test code:
try
{
	Sum(null);
	// An exception is expected --> the test fails
	throw new Exception("Null array cannot be summed.");
}
catch (ArgumentNullException)
{
	// NullReferenceException is expected --> the test passes
}
Now all unit tests works correctly. The conclusion form the above experience is that when we modify the code and a unit test fails, either the tested code is incorrect, or the unit test is incorrect. In both cases we are notified that our new code behaves differently than our old code. This is very important in software engineering process. When we develop a complex software product, we want the features that work in its current version to continue to works the same way in all its next versions. For example, if we work on MS Word and we add PDF export for its next version, we want to be sure that saving in DOCX format still works after the PDF export is introduced.
Unit Testing Frameworks and Tools
To simplify writing unit tests and execute them many unit testing frameworks and tools have emerged. In C# we can use Visual Studio Team Test (VSTT) or NUnit frameworks to simplify the process of writing tests, asserting test conditions and executing test cases and test suites.
Unit Testing with Visual Studio Team Test (VSTT)
If you have installed Visual Studio 2010 edition which supports unit testing (e.g. Visual Studio 2010 Ultimate), you will have the [Create Unit Tests …] feature in the popup menu when you right click at some method in your C# code:
 
The above feature was introduced in VS 2010 and is missing in VS 2012 for unknown reason. So if you are using Visual Studio 2012, you need to create a unit test project by hand (File ? New Project ? Unit Test Project).
The unit tests in Visual Studio Team Test look like the following:
using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class SumatorTest
{
	[TestMethod]
	public void SumTestTypicalCase()
	{
		int[] numbers = new int[] { 1, 2 };
		long expected = 3;
		long actual = Sumator_Accessor.Sum(numbers);
		Assert.AreEqual(expected, actual);
	}

	[TestMethod]
	public void SumTestOverflow()
	{
		int[] numbers = new int[] { 2000000000, 2000000000 };
		long expected = 4000000000;
		long actual = Sumator_Accessor.Sum(numbers);
		Assert.AreEqual(expected, actual);
	}

	[TestMethod]
	[ExpectedException(typeof(NullReferenceException))]
	public void SumTestNullArray()
	{
		Sumator_Accessor.Sum(null);
	}
}
A detailed explanation of VSTT will not be given in this book, but anyone could research how to use unit testing in Visual Studio. As you see from the example above, VSTT simplifies unit testing by introducing test classes and test methods. Each test method has a meaningful name which and tests a certain test case. VSTT can test private methods, can set time limit for the test execution and can expect exception to be thrown by certain test case – things that simplify writing the testing code. Visual Studio can execute and visualize the results of the test execution:
 
Additional Resources
We hope this chapter made the first steps in making you a real high-quality software engineer. If you want to learn more about writing quality code, you might refer to these additional resources:
 	The Bible of quality programming code is called "Code Complete" and its second edition was published in 2004. Its author, Steve McConnell, is a world-famous expert on writing quality software, a former Microsoft employee. The book contains a lot more examples and more general practices for writing high-quality code.
 	Another good book on software quality is Martin Fowler’s "Refactoring: Improving the Design of Existing Code". This book is considered to be the Bible of code refactoring. Terms such as "extract method", "encapsulate field", "extract constant" and other basic modern refactoring patterns were first described in this book.
 	The free training course "High-Quality Code" @ Telerik Software Academy – http://codecourse.telerik.com. It provides comprehensive teaching materials, presentations, examples, homework assignments and videos (in Bulgarian) about writing high-quality code and high-quality software, unit testing and code refactoring.
Exercises
	Take the code from the first example in this chapter and refactor it to meet the quality standards discussed in this chapter.
	Review your own code from the exercises from the previous chapters and find the mistakes you have made. Refactor the code to improve its quality. Think how you can avoid such mistakes and bad coding style in the future.
	Open other people’s code and try to understand it only by reading the code itself. Is everything obvious at first sight? What would you change in that code, how would you write it?
	Review the classes from .NET Common Type System (CTS). Can you find examples of low-quality code?
	Have you used or seen any coding conventions? Having read this chapter, would you consider them good or bad?
	We are given a square matrix of n x n cells. A rotating walk in the matrix is walk that starts from the top left corner of the matrix and goes in down-right direction. When no continuation is available at the current direction (either the matrix wall or non-empty cell is reached), the direction is changed to the next possible direction clockwise. The eight possible directions are as follows:
 
When no empty cell is available at all directions, the walk is restarted from an empty cell at the smallest possible row and as close as possible to the start of this row. When no empty cell is left in the matrix, the walk is finished. Your task is to write a program that reads from the console an integer number n (1 ? n ? 100) and displays the filled matrix on the console.
Sample input:
n = 6
	Sample output:
 1  16  17  18  19  20
15   2  27  28  29  21
14  31   3  26  30  22
13  36  32   4  25  23
12  35  34  33   5  24
11  10   9   8   7   6

Download a sample low-quality solution of that problem from here: http://introcsharpbook.googlecode.com/files/High-Quality-Code.rar.
Refactor the code so that it meets the recommended standards for quality code stated in this chapter. Note that fixing bugs in the solution might be necessary if it does not work correctly.
Solutions and Guidelines
	Use [Ctrl+K, Ctrl+F] in Visual Studio to reformat the code and see the differences. Then rename the variables, omit the unnecessary statements and variables, and make the output that is printed more meaningful.
	Pay special attention to the recommendations for quality code from this chapter. Remember your most frequent mistakes and try to avoid them. The most often problem with the code written by inexperienced programmers is the naming. You can use the "rename" feature in Visual Studio (shortcut [Ctrl+R, Ctrl+R]) to rename the identifiers in the code when necessary. You may need to reformat your code through [Ctrl+K, Ctrl+F] in Visual Studio. You may need to extract pieces of code in separate method. This can be done through "Refactor" ? "Extract Method …" feature in Visual Studio (shortcut [Ctrl+R, Ctrl+M]).
	Take some well-written software as an example (e.g. Wintellect Power Collections for .NET – http://powercollections.codeplex.com). You would probably find things that you would write in a different way, or things that this chapter suggests should be done differently. Deviations are possible and are completely normal. One of the biggest differences between low-quality and high-quality code is the consistency in following the rules. The rules in different projects may be different (e.g. different formatting style, different documentation style, different naming style, different project structure, etc.) but the general recommendations for writing high-quality code will be followed.
Take another example: bad code that is hard to read, understand and maintain. You may find many examples in Internet but to save time you may look at the projects from the "High-Quality Code" course at Telerik Software Academy (May 2011): https://qualitycode.googlecode.com/svn/
trunk/2011/Exams/Final-Projects-19-May-2011/High-Quality-Code-2011-Final-Projects.rar. There are C#, Java, C++ and PHP projects with low-quality code that needs deep refactoring and quality improvement.
	The code from CTS is written by engineers with an extensive experience and you can rarely encounter low-quality code there. Despite of that, anomalies such as using complex expressions and inappropriately named variables can still be seen. Try to find some examples of bad coding practices in CTS. Use JustDecompile or other decompilation tool because the source code of CTS is unavailable. Keep in mind that local variable names and comments in the code are lost when the code is compiled and decompiled so the variable names might be incorrect.
Instead of decompiling the .NET CTS you may look at the source code of Mono (the open-source .NET implementation for Linux) at GitHub: https://github.com/mono/mono/tree/master/mcs/class/corlib. An example of code that needs improvement is the Dictionary<K,T> implementation in Mono: Dictionary.cs.
	Just answer based on your personal experience. You may ask your colleagues whether they use coding conventions. You may also read the official C# code conventions from Microsoft: http://msdn.microsoft.com/
en-us/library/vstudio/ff926074.aspx.
	Review all the learned concepts from this chapter and apply them to the code you are given. First understand how the code works and then fix the bugs you discover. The best way to start is by reformatting the code and renaming the identifiers. Then you may write unit tests to enable refactoring without a risk to break something. Then step by step you may extract methods, remove the duplicated code, and rewrite pieces of the code which cannot be refactored. Be sure to test after each change.


Chapter 22. Lambda Expressions and LINQ

In This Chapter
In this chapter we will become acquainted with some of the advanced capabilities of the C# language. To be more specific, we will pay attention on how to make queries to collections, using lambda expressions and LINQ, and how to add functionality to already created classes, using extension methods. We will get to know the anonymous types, describe their usage briefly and discuss lambda expressions and show in practice how most of the built-in lambda functions work. Afterwards, we will pay more attention to the LINQ syntax – we will learn what it is, how it works and what queries we can build with it. In the end, we will get to know the meaning of the keywords in LINQ, and demonstrate their capabilities with lots of examples.
Extension Methods
In practice, programmers often have to add new functionality to already existing code. If the code is available, we can simply add the required functionality and recompile. When a given assembly (.exe or .dll file) has already been compiled, and the source code is not available, a common way to extend the functionality of the types is trough inheritance. This approach can be quite difficult to apply, due to the fact that we will have to change the instances of the base class with the instances of the derived one to be able to use our new functionality. Unfortunately, that is the least of our problems. If the type we want to inherit is marked with the keyword sealed, inheritance is not possible.
Extension methods solve that very same problem – they present to us the opportunity to add new functionality to already existing type (class or interface), without having to change its original code or use inheritance, i.e. also works fine with types that cannot be inherited. Notice that trough extension methods we can add "implemented methods" even to interfaces.
The extension methods are defined as static in ordinary static classes. The type of their first argument is the class (or the interface) they extend. In front of it, we should place the keyword this. That is what makes them different from other static methods, and indicates the compiler that this is an extension method. The parameter with the keyword this in front of it can be used in the method body to create its functionality. Practically, it is the object that is used by the extension method.
Extension methods can be applied directly to objects of the class/interface they extend. They can also be invoked statically through the static class they are defined in, but it is not a good practice.
 	To refer to a specific extension method, we should add "using" and the corresponding namespace, where the static class, describing this method, is defined. Otherwise the compiler has no way of knowing about their existence.
Extension Methods – Examples
Let’s take for example the definition of an extension method that counts the number of words in a given string. Have in mind, that the type string is sealed, so it cannot be inherited.
public static class StringExtensions
{
	public static int WordCount(this string str)
	{
		return str.Split(new char[] { ' ', '.', '?', '!' },
			StringSplitOptions.RemoveEmptyEntries).Length;
	}
}
The method WordCount(…) extends the class String. This is indicated by the keyword this before the type and the name of the first argument of the method (in our case str). The method itself is static and it is defined in the static class StringExtensions. The usage of the extension method is done the same way as all the other methods of the class String. Do not forget to add the corresponding namespace, where the static class, describing the extension methods, is defined. Example of using an extension method:
static void Main()
{
	string helloString = "Hello, Extension Methods!";
	int wordCount = helloString.WordCount();
	Console.WriteLine(wordCount);
}
The method is invoked on the object helloString, which is of type string. It also takes the object as an argument and works with it (in our case refers to its Split(…) method and returns the number of elements of the array, produced by the Split(…) method).
Extension Methods for Interfaces
Extension methods can not only be used on classes, but on interfaces as well. Our next example takes an instance of a class, that implements the interface list of integers (IList<int>), and increases their value by a certain number. The method IncreaseWith(…) can access only those elements that are included in the interface IList (e.g. the property Count).
public static class IListExtensions
{
	public static void IncreaseWith(
		this IList<int> list, 	int amount)
	{
		for (int i = 0; i < list.Count; i++)
		{
			list[i] += amount;
		}
	}
}
The extension methods also give us the opportunity to work on generic types. Let’s take for example a method that loops trough a collection, using foreach, implementing IEnumerable from generic type T. Its purpose is to convert to a meaningful string a sequence of elements (e.g. a list of integers):
public static class IEnumerableExtensions
{
	public static string ToString<T>(
		this IEnumerable<T> enumeration)
	{
		StringBuilder result = new StringBuilder();
		result.Append("[");
		foreach (var item in enumeration)
		{
			result.Append(item.ToString());
			result.Append(", ");
		}
		if (result.Length > 1)
			result.Remove(result.Length - 2, 2);
		result.Append("]");
		return result.ToString();
	}
}
Example of how to use the two extension methods declared above:
static void Main()
{
	List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
	Console.WriteLine(numbers.ToString<int>());
	numbers.IncreaseWith(5);
	Console.WriteLine(numbers.ToString<int>());
}
The output of the execution of the program will be the following:
[1, 2, 3, 4, 5]
[6, 7, 8, 9, 10]
Anonymous Types
In object-oriented languages (such as C#), it is common to define small classes that will be used only once. Typical example is the class Point that has only two fields – the coordinates of a point. Creating a simple class with the idea of using it just once is inconvenient and time consuming for the programmer, especially when the standard operations for each class: ToString(), Equals() and GetHashCode() have to be predefined.
In C# there is a built-in way to create single-use types, called anonymous types. Objects of such type are created almost the same way as other objects in C#. The thing with them is that we don’t need to define data type for the variable in advance. The keyword var indicates to the compiler that the type of the variable will be automatically detected by the expression, after the equals sign. We actually don’t have a choice here, since we can’t tell the specific type of the variable, because it is defined as one of an anonymous type. After that, we specify name for the object, followed by the "=" operator and the keyword new. In curly braces we enumerate the names and the values of the properties of the anonymous type.
Anonymous Types – Example
Here is an example of creating an anonymous type that describes a car:
var myCar = new { Color = "Red", Brand = "BMW", Speed = 180 };
During compilation, the compiler will create a class with a unique name (something like <>f__AnonymousType0) and will generate properties for it (with getter and setter). In the example above, the compiler will guess by its own, that the properties Color and Brand are of type string and Speed will be set as int. Right after the initialization, the object of the anonymous type can be used as one of an ordinary type with its three properties:
Console.WriteLine("My car is a {0} {1}.",
	myCar.Color, myCar.Brand);
Console.WriteLine("It runs {0} km/h.", myCar.Speed);
The output of the code above will be as follows:
My car is a Red BMW.
It runs 180 km/h.
More about Anonymous Types
As any other type in .NET, the anonymous ones inherit the class System.
Object. During compilation, the compiler will automatically redefine the methods ToString(), Equals() and GetHashCode() for us.
Console.WriteLine("ToString: {0}", myCar.ToString());
Console.WriteLine("Hash code: {0}", 	myCar.GetHashCode().ToString());
Console.WriteLine("Equals? {0}", myCar.Equals(
	new { Color = "Red", Brand = "BMW", Speed = 180 }
));
Console.WriteLine("Type name: {0}", myCar.GetType().ToString());
The output of the code above will be the following:
ToString: { Color = Red, Brand = BMW, Speed = 180 }
Hash code: 1572002086
Equals? True
Type name: <>f__AnonymousType0`3[System.String,System.String,System.Int32]
As we can see from the result, the method ToString() is redefined, so that it can list the properties of the anonymous type in the order of their definition in the initialization of the object (in our case myCar). The method GetHashCode() is wrote in such a way, that it uses all fields and on their basis it calculates a hash function with a small number of collisions. The redefined by the compiler method Equals(…) compares the objects field by field. As we can notice from the example, we have created a new object that has exactly the same properties as myCar, and returns a result stating that the newly created object and the old one have equal values.
Arrays of Anonymous Types
The anonymous types, like ordinary ones, can be used as elements of arrays. We can initialize them with the keyword new, followed by square brackets. The values of the elements of the array are listed the same way, as the values assigned to the anonymous types. The values in the array should be homogeneous, i.e. it is not possible to have different anonymous types in the same array. An example of defining an array of anonymous types with two properties (X and Y):
var arr = new[] {
	new { X = 3, Y = 5 },
	new { X = 1, Y = 2 },
	new { X = 0, Y = 7 }
};
foreach (var item in arr)
{
	Console.WriteLine(item.ToString());
}
The result of the execution of the code above will be the following:
{ X = 3, Y = 5 }
{ X = 1, Y = 2 }
{ X = 0, Y = 7 }
Lambda Expressions
Lambda expressions are anonymous functions that contain expressions or sequence of operators. All lambda expressions use the lambda operator =>, which can be read as "goes to". The idea of the lambda expressions in C# is borrowed from the functional programming languages (e.g. Haskell, Lisp, Scheme, F# and others). The left side of the lambda operator specifies the input parameters and the right side holds an expression or a code block that works with the entry parameters and conceivably returns some result.
Usually lambda expressions are used as predicates or instead of delegates (a type that references a method instance), which can be applied on collections, processing their elements and/or returning a certain result.
Lambda Expressions – Examples
As an example, let’s take the extension method FindAll(…), which can be used to filter the necessary elements. It works on a certain collection by applying a given predicate on it that checks if an element matches a certain requirement. In order to use it we have to add a reference to the assembly System.Core.dll (if it is not already added) and include the namespace System.Linq, because the extension methods for the collections are there.
For example, if we want to take only the even numbers from a collection of integers, we can use the method FindAll(…) on that collection, passing a lambda method to it that checks if a certain number is even:
List<int> list = new List<int>() { 1, 2, 3, 4, 5, 6 };
List<int> evenNumbers = list.FindAll(x => (x % 2) == 0);
foreach (var num in evenNumbers)
{
	Console.Write("{0} ", num);
}
Console.WriteLine();
The result is:
2 4 6
The example above loops through the whole collection of numbers and for each element (named x) a check, if the number is multiple of 2, is made (through the Boolean expression (x % 2) == 0).
Let’s now focus on an example in which trough an extension method and a lambda expression we will create a collection, containing data from a certain class. In the example, from the class Dog (with properties Name and Age), we want to get a list that contains all dogs’ names. We can do that with the extension method Select(…) (defined in the namespace System.Linq) by assigning to it to turn each dog (x) into dog’s name (x.Name) and writing that result in the variable names. With the keyword var, we tell the compiler to define the type of the variable according to the result that we assign on the right side of the equals sign.
class Dog
{
	public string Name { get; set; }
	public int Age { get; set; }
}

static void Main()
{
	List<Dog> dogs = new List<Dog>() {
		new Dog { Name = "Rex", Age = 4 },
		new Dog { Name = "Sean", Age = 0 },
		new Dog { Name = "Stacy", Age = 3 }
	};
	var names = dogs.Select(x => x.Name);
	foreach (var name in names)
	{
		Console.WriteLine(name);
	}
}
The result is:
Rex
Sean
Stacy
Using Lambda Expressions with Anonymous Types
We can create collections of anonymous types from a collection with some elements by using lambda expressions. Let’s take the collection dogs, containing elements of type Dog, and create new collection consisting of elements of an anonymous type, having two properties – age and the initial letter of the dog’s name:
var newDogsList = dogs.Select(
	x => new { Age = x.Age, FirstLetter = x.Name[0] });
foreach (var item in newDogsList)
{
	Console.WriteLine(item);
}
The result is:
{ Age = 4, FirstLetter = R }
{ Age = 0, FirstLetter = S }
{ Age = 3, FirstLetter = S }
As it is obvious from the example above, the newly created collection newDogsList has elements of an anonymous type, taking the properties Age and FirstLetter as parameters. The first line of the example can be read as follows: "Create a variable of undefined (at this point) type, name it newDogsList and create a new element of an anonymous type for each element x of the dogs collection with two properties: Age that is equal to the property Age of the element x, and the property FirstLetter that is equal to the first character of the string x.Name".
Sorting with Lambda Expressions
If we want to sort the elements in a certain collection, we can use the extension methods OrderBy(…) and OrderByDescending(…), by defining the way of sorting in a lambda function. An example on our collection dogs:
var sortedDogs = dogs.OrderByDescending(x => x.Age);
foreach (var dog in sortedDogs)
{
	Console.WriteLine(string.Format(
		"Dog {0} is {1} years old.", dog.Name, dog.Age));
}
The result is:
Dog Rex is 4 years old.
Dog Stacy is 3 years old.
Dog Sean is 0 years old.
Statements in Lambda Expressions
Lambda functions can also have a body. So far we have used lambda functions with only one statement. Now we will pay more attention to lambda functions that have a body. Let’s return to the example with the even numbers. Suppose we want to print to the console the values of all numbers, to which our lambda function is applied to and to return the result if they are even or not. We can do it the following way:
List<int> list = new List<int>() { 20, 1, 4, 8, 9, 44 };
// Process each argument with code statements
var evenNumbers = list.FindAll((i) =>
{
	Console.WriteLine("Value of i is: {0}", i);
	return (i % 2) == 0;
});
The result from the above code is:
Value of i is: 20
Value of i is: 1
Value of i is: 4
Value of i is: 8
Value of i is: 9
Value of i is: 44
Lambda Expressions as Delegates
Lambda functions can be written in delegates. Delegates are such a type of variables that contains functions (methods). Some standard delegate types in .NET are: Action, Action<in T>, Action<in T1, in T2>, and so on and Func<out TResult>, Func<in T, out TResult>, Func<in T1, in T2, out TResult> and so on. The types Func and Action are generic and contain the types of the return value, and the types of the parameters of the functions. The variables of such types are references to functions. Below is an example for using and assigning values to these types:
Func<bool> boolFunc = () => true;
Func<int, bool> intFunc = (x) => x < 10;
if (boolFunc() && intFunc(5))
{
	Console.WriteLine("5 < 10");
}
The result is:
5 < 10
In the example above we define two delegates. The first one – boolFunc is a function that has no input parameters and returns a Boolean result. We have given an anonymous lambda function that does nothing and always returns true as a value to that function. The second delegate intFunc takes as an argument an int variable and returns a Boolean value – true when x is less than ten, and false otherwise. At the end, in the if statement, we call these two delegates as we give to the second one value of 5 as an argument, and the result from their invocation is true, as we can see.
LINQ Queries
LINQ (Language-Integrated Query) is a set of extensions of the .NET Framework, that includes language integrated queries and operations on the elements of a certain data source (most often arrays or collections). LINQ is a very powerful tool, similar to most SQL languages by logic and syntax. It actually works with collections in the same way as SQL languages work with table rows in databases. It is part of the syntax of C# and Visual Basic .NET and consists of few special keywords like from, in and select. In order to use LINQ queries in C#, we have to include a reference to System.Core.dll and to include the namespace System.Linq in the beginning of the C# program.
Data Sources with LINQ
To define the data source (collection, array and so on), we have to use the keywords from and in and a variable for the iteration of the collection (the iteration is similar to the one with the foreach operator). For example, a query that starts like this:
from culture
in CultureInfo.GetCultures(CultureTypes.AllCultures)
can be read as follows: "for each element of the collection CultureInfo.
GetCultures(CultureTypes.AllCultures) assign the variable culture and use it to refer to these items further in the query".
Data Filtering with LINQ
The keyword where can be used to set conditions, that should be kept by each item of the collection, in order to continue with the execution of the query. The expression after where is always of a Boolean type. We can say that where works as a filter for the elements. For example, if we want to see only those cultures, whose name begins with the lowercase Latin letter b, we can continue the query from our last example like this:
where culture.Name.StartsWith("b")
As we can notice, after where … in, we use only the name we gave for the iteration of the variables in the collection. The keyword where is compiled up to the invoking of the extension method Where().
where culture.Name.StartsWith("b")
Results of LINQ Queries
To choose the output data for the query, we can use the keyword select. The result is an object of an existing class or an anonymous type. The result can also be a property of the objects, the query runs through or the objects themselves. The select statement and everything following it is placed always at the end of the query. The four keywords: from, in, where and select, are completely enough to create a simple LINQ query. Here is an example:
List<int> numbers = new List<int>() {
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10
};
var evenNumbers =
	from num in numbers
	where num % 2 == 0
	select num;
foreach (var item in evenNumbers)
{
	Console.Write(item + " ");
}
The result is:
2 4 6 8 10 
The example above runs a query over a collection of integers called numbers and filters only the even ones in a new collection. The query can be read as follows: "for each number num from numbers check if it is multiple of 2, and if so, add it to the new collection".
Sorting Data with LINQ
Sorting with LINQ queries is done through the keyword orderby. The conditions, used for sorting the elements, are placed after it. For each condition the order of arrangement can be indicated: ascending (using the keyword ascending) and descending (with the keyword descending), as by default the elements are ordered in ascending order. If we want to sort an array of strings by their length in descending order, for example, we can write the following query:
string[] words = { "cherry", "apple", "blueberry" };
var wordsSortedByLength =
	from word in words
	orderby word.Length descending
	select word;
foreach (var word in wordsSortedByLength)
{
	Console.WriteLine(word);
}
The result is:
blueberry
cherry
apple
If no instruction for the order is given (i.e. the keyword orderby is missing from the query) the items are printed in the way they would be processed, if the foreach operator was used.
Grouping Results with LINQ
To group the results by some criteria the keyword group should be used. The pattern is as follows:
group [variable name] by [grouping condition] into [group name]
The result of grouping is a new collection of a special type that can be used further in the query. After the grouping, however, the query stops working with its initial variable. This means that in the select statement, we can use only the group. An example of grouping:
int[] numbers =
	{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0, 10, 11, 12, 13 };
int divisor = 5;

var numberGroups =
	from number in numbers
	group number by number % divisor into group
	select new { Remainder = group.Key, Numbers = group };

foreach (var group in numberGroups)
{
	Console.WriteLine(
	"Numbers with a remainder of {0} when divided by {1}:",
		group.Remainder, divisor);
	foreach (var number in group.Numbers)
	{
		Console.WriteLine(number);
	}
}
The result is:
Numbers with a remainder of 0 when divided by 5:
5
0
10
Numbers with a remainder of 4 when divided by 5:
4
9
Numbers with a remainder of 1 when divided by 5:
1
6
11
Numbers with a remainder of 3 when divided by 5:
3
8
13
Numbers with a remainder of 2 when divided by 5:
7
2
12
As we can see from the example above, the numbers printed to the console are grouped by their remainders of the division by 5. In the query, for each number number % divisor is calculated, and for each different result a new group is formed. Further in the query, the select operator works on the list of created groups, and for each group creates an anonymous type with two properties: Remainder and Numbers. To the property Remainder the key of the group is assigned (in our case the remainder of the division by the divisor of the number). And to the property Numbers the collection group is assigned, that contains all the elements in the group. Notice that select is executed only over the list of groups. The variable number cannot be used there. Further in the example of two nested foreach statements, the remainders (the groups) and the numbers that have the remainder (located in the group) are printed.
Joining Data with LINQ
The join statement is a bit more complicated than the other LINQ statements. It joins collections by certain matching criteria and extracts the needed data. Its syntax is as follows:
from [variable name from collection 1] in [collection 1] join [variable name from collection 2] in [collection 2] on [part of the compare condition from collection 1] equals [part of the compare condition from collection 2]
Further in the query (e.g. in the select part), both, the name of the variable from collection 1, and the name of the variable from collection 2, can be used. Example:
public class Product
{
	public string Name { get; set; }
	public int CategoryID { get; set; }
}

public class Category
{
	public int ID { get; set; }
	public string Name { get; set; }
}
The code that illustrates how to use LINQ joins:
List<Category> categories = new List<Category>()
{
	new Category() { ID = 1, Name = "Fruit" },
	new Category() { ID = 2, Name = "Food" },
	new Category() { ID = 3, Name = "Shoe" },
	new Category() { ID = 4, Name = "Juice" },
};
List<Product> products = new List<Product>()
{
	new Product() { Name = "Strawberry", CategoryID = 1 },
	new Product() { Name = "Banana", CategoryID = 1 },
	new Product() { Name = "Chicken meat", CategoryID = 2 },
	new Product() { Name = "Apple Juice", CategoryID = 4 },
	new Product() { Name = "Fish", CategoryID = 2 },
	new Product() { Name = "Orange Juice", CategoryID = 4 },
	new Product() { Name = "Sandal", CategoryID = 3 },
};
var productsWithCategories =
	from product in products
	join category in categories
		on product.CategoryID equals category.ID
	select new { 	Name = product.Name,
							Category = category.Name };
foreach (var item in productsWithCategories)
{
	Console.WriteLine(item);
}
The result is:
{ Name = Strawberry, Category = Fruit }
{ Name = Banana, Category = Fruit }
{ Name = Chicken meat, Category = Food }
{ Name = Apple Juice, Category = Juice }
{ Name = Fish, Category = Food }
{ Name = Orange Juice, Category = Juice }
{ Name = Sandal, Category = Shoe }
In the example above, we create two classes and an imaginary relationship between them. To each product some category CategoryID (represented by a number) corresponds, that matches the number ID from the class Category in the collection categories. If we want to use this relation and to create a new anonymous type, where to store the products and their names and category, we can write the above LINQ query. It joins the collection of elements of type Category with the one of type Product by the mentioned criteria (match between ID from Category and CategoryID from Products). In the select part of the query, we use both names category and product to construct an anonymous type with the name of the product and the name of the category.
Nested LINQ Queries
LINQ also supports nested queries. For example our last query can be written by nesting two queries in the following way (the result is exactly the same as the one with join):
var productsWithCategories =
	from product in products
	select new {
		Name = product.Name,
		Category =
			(from category in categories
			where category.ID == product.CategoryID
			select category.Name).First()
	};
Since each query in LINQ returns a collection of items (irrespective of whether the result from it is of 0, 1 or more elements), we need to use the extension method First() over the result of the nested query. The method First() returns the first element (in our case the only one) of the collection it is applied on. In this way we get the name of the category only by its ID number.
LINQ Performance
As a rule using LINQ and extension methods is slower than using direct operations over a collection of elements, so beware of using LINQ when processing large collections or the performance is critical.
Let’s compare the speed of adding 50,000,000 elements to a list through extension methods and directly with a for-loop:
List<int> l1 = new List<int>();
DateTime startTime = DateTime.Now;
l1.AddRange(Enumerable.Range(1, 50000000));
Console.WriteLine("Ext.method:\t{0}", DateTime.Now - startTime);

startTime = DateTime.Now;
List<int> l2 = new List<int>();
for (int i = 0; i < 50000000; i++) l2.Add(i);
Console.WriteLine("For-loop:\t{0}", DateTime.Now - startTime);
The result might be as follows (depends on the computer’s CPU speed):
Ext.method:     00:00:01.6430939
For-loop:       00:00:00.9120522
LINQ technology and extension methods work through the concept of expression trees. Each LINQ query is translated by the compiler to an expression tree and is executed when its results are actually accessed (not earlier). For example let’s consider the following code:
List<int> list = new List<int>();
list.AddRange(Enumerable.Range(1, 100000));

DateTime start = DateTime.Now;
for (int i = 0; i < 10000; i++)
{
	var elements = list.Where(e => e > 20000);
}
Console.WriteLine("No execution:\t{0}", DateTime.Now - start);

start = DateTime.Now;
for (int i = 0; i < 10000; i++)
{
	var element = list.Where(e => e > 20000).First();
}
Console.WriteLine("Execution:\t{0}", DateTime.Now - start);
The result might be as follows (depends on the computer’s CPU speed):
No execution:   00:00:00.0070004
Execution:      00:00:02.7231558
This shows that if we call a .Where(…) filter (or where clause in LINQ) it is not actually executed until its result is actually needed. The elements get filtered on demand, at the time they are really required. In our case this is when we invoke First() method. Moreover, if we get the first element of a sequence, the rest elements are not processes until needed. Thus if we use change the filtering lambda function from "e => e > 20000" to "e => e > 500000", the filtering becomes times slower because more elements are processed until the first matching the filtering condition is found:
No execution:   00:00:00.0060004
Execution:      00:00:06.3663641
Standard .NET Framework collection classes like List<T>, HashSet<T> and Dictionary<K,V> are optimized to work fast with LINQ. Most operations with LINQ work almost as fast as if we run them directly. Let’s check this example:
HashSet<Guid> set = new HashSet<Guid>();
for (int i = 0; i < 50000; i++)
{
	set.Add(Guid.NewGuid()); // Add random GUID
}

Guid keyForSearching = new Guid();
DateTime start = DateTime.Now;
for (int i = 0; i < 50000; i++)
{
	// Use HashSet.Contains(…)
	bool found = set.Contains(keyForSearching);
}
Console.WriteLine("HashSet: {0}", DateTime.Now - start);

start = DateTime.Now;
for (int i = 0; i < 50000; i++)
{
	// Use IEnumerable<Guid>.Contains(…) extension method
	bool found = set.Contains<Guid>(keyForSearching);
}
Console.WriteLine("Contains: {0}", DateTime.Now - start);

start = DateTime.Now;
for (int i = 0; i < 50000; i++)
{
	// Use IEnumerable<Guid>.Where(…) extension method
	bool found = set.Where(g => g==keyForSearching).Count() > 0;
}
Console.WriteLine("Where: {0}", DateTime.Now - start);
The result is as follows (though it depends on the computer’s CPU speed):
HashSet: 00:00:00.0030002
Contains: 00:00:00.0040003
Where: 00:02:49.9717218
Seems like .NET Framework takes into account the capability to search in constant time O(1) in a HashSet<T>, so searching though the native method Contains(…) and though the extension methods IEnumerable.Contains(…) both run in time O(1). By contrast, the IEnumerable.Where(…) method is dramatically slower and runs in linear time O(n). This is expected, because the Where(…) method checks certain condition for each element in a collection and it is expected to process all elements one by one. By contrast the Contains(…) method just searches for single element which is fast operation.
In case you do not remember about the asymptotic notation O(1) and O(n), please check the chapter "Data Structures and Algorithm Complexity".
In the above example we use the system structure Guid. This is a global unique identifier often used in computer technologies to identify an object. It may look like the following: 8668f585-faf8-4685-8025-6a8d1d2aba0a. If you want to generate a global unique (world-wide) identifier, you might benefit from the method Guid.NewGuid(), like we do in the code above.
Exercises
	Implement an extension method Substring(int index, int length) for the class StringBuilder that returns a new StringBuilder and has the same functionality as the method Substring(…) of the class String.
	Implement the following extension methods for the classes, implementing the interface IEnumerable<T>: Sum(), Min(), Max(), Average().
	Write a class Student with the following properties: first name, last name and age. Write a method that for a given array of students finds those, whose first name is before their last one in alphabetical order. Use LINQ.
	Create a LINQ query that finds the first and the last name of all students, aged between 18 and 24 years including. Use the class Student from the previous exercise.
	By using the extension methods OrderBy(…) and ThenBy(…) with lambda expression, sort a list of students by their first and last name in descending order. Rewrite the same functionality using a LINQ query.
	Write a program that prints to the console all numbers from a given array (or list), that are multiples of 7 and 3 at the same time. Use the built-in extension methods with lambda expressions and then rewrite the same using a LINQ query.
	Write an extension method for the class String that capitalizes all letters, which are the beginning of a word in a sentence in English. For example: "this iS a Sample sentence." should be converted to "This Is A Sample Sentence.".
	Create a hash-table to hold a phone book: a set of person names and their phone numbers (e.g. Kate Wilson ? +3592981981, +3598862536; Alex & Co. ? 1-800-ALEX; Steve Milton ? +496023456). Fill enough random data (e.g. 50,000 key-value pairs). Measure how much time it takes to perform searching by key in the hash-table using its native search capabilities, using the extension methods IEnumerable.Contains(…) and IEnumerable.Where(…). Can you explain the difference?
Solutions and Guidelines
	Follow the syntax explained in the section "Extension Methods". You may create a new StringBuilder and to write in it all the characters with indices, starting from index and with length length, from the object that the extension method will work on.
	For generic implementation of the Min() and Max() methods for any generic type T you can add a restriction to the passed type T to be comparable, i.e. you should have something like this:
public static T Min<T>(this IEnumerable<T> elements)
	where T : IComparable<T>
{ 	… }
Since not all data types have predefined operators + and /, it will not be possible to apply the functions Sum() and Average() to all types directly. There are no interfaces ISummable<T> and IDividable<T> in .NET. One way to work around this problem is to convert all input objects to decimal and then to calculate sum / average and return decimal as result. For the conversion you can use the static method Convert.ToDecimal(…).
Another interesting approach is to use the dynamic data type in C# to hold the arguments and results and to execute the operations over them at runtime (due to the dynamic evaluation capabilities in C#):
public static dynamic Min<T>(this IEnumerable<T> elements)
{	… }
This is easier to implement and works better but could have performance issues and some special cases to be handled.
	Review the keywords from, where and select from the "LINQ Queries" section in this chapter.
	Write a LINQ query to select the described students in an anonymous type that contains only two properties – FirstName and LastName.
	For the LINQ query use from, orderby, descending and select. For the implementation with the lambda expressions, you can use the methods OrderByDescending(…) and ThenByDescending(…).
	It is enough to check if the numbers are multiples of 21, instead of writing two where conditions.
	Use the method ToTitleCase(…) of the property TextInfo in the culture en-US in the following way:
new CultureInfo("en-US", false).TextInfo.ToTitleCase(text);
	See the examples at the end of the section "LINQ Performance". You can use Dictionary<string, List<string>> to hold the phone book. You may explain the difference in the execution speed by trying to explain how searching works internally and by the assumption that searching in a hash-table takes time O(1) and searching in a collection element by element runs in linear time O(n).


Chapter 23. Methodology of Problem Solving

In This Chapter
In this chapter we will discuss one recommended practice for efficiently solving computer programming problems and make a demonstration with appropriate examples. We will discuss the basic engineering principles of problem solving, why we should follow them when solving computer programming problems (the same principles can also be applied to find the solutions of many mathematical and scientific problems as well) and we will make an example of their use. We will describe the steps, in which we should go in order to solve some sample problems and show the mistakes that can occur when we do not follow these same steps. We will pay attention to some important steps from the methodology of problem solving, that we usually skip, e.g. the testing. We hope to be able to prove you, with proper examples, that the solving of computer programming problems has a "recipe" and it is very useful.
Basic Principles of Solving Computer Programming Problems
You probably think this chapter is about an idle talk like "first think, then act" or "be careful when you write and try to not miss something". In fact this chapter will not be so tedious and boring and will give you some practical guidelines for solving algorithmic problems as well as other problems.
Without making any claim of completeness, we will give you some important suggestions, based on Svetlin Nakov’s personal experience acquired during his work of 10+ years as a competitor in International and Bulgarian programming competitions. Svetlin has gained tens of International awards from programming contests including medals from International Olympiad in Informatics (IOI) and has been training students from Sofia University St. Kliment Ohridski (SU), New Bulgarian University (NBU), Technical University of Sofia (TU-Sofia), National Academy for Software Development (NASD), and Telerik Software Academy, and his experience during the last 10 years confirms that this methodology works well in practice.
Let’s start with the first key suggestion.
Use Pen and Paper
The use of a pen and sheet of paper and the making of drafts and sketches when solving problems is something normal and natural, which every experienced mathematician, physicist and software engineer does when tasked with a non-trivial problem.
Unfortunately, our experience with students showed us most of the novice programmers do not even bring with them a pen and paper. They have the false perception that in order to solve programming problem they only need a keyboard. Most of them need some time and exams’ failures to finally realize that the making of some kind of drafts on paper is crucial for understanding the problem and constructing a correct solution.
 	Everyone who does not use a pen and paper will be in a serious trouble when solving computer programming problems. It is important always to make drafts of your ideas on paper or blackboard before even start typing on the keyboard.
Maybe, it is a little old-fashioned, but the "era of the paper" is not over yet! The easiest way for you to visualize your idea is to put it on paper. It is very difficult for most people to try and think about a problem without some kind of visualization. The visual system in the human brain, which absorbs information, is strongly connected to these parts of the brain, which are responsible for the creative potential and logical thinking.
People who have well-developed their visual system in the brain are able to easily "see" the solution of a problem in their mind. Then they only have to polish their idea and implement it. These people actively use their visual memory and their ability to create visual imagery, which is the reason why they can quickly create ideas and reflect on algorithms for solving problems. These people can quickly recognize and discard the wrong ideas and visualize the correct algorithm for the programming problem in a matter of seconds. Regardless of whether you are a "visual" type of person or not, writing down and sketching your idea is very useful and will most certainly help your thoughts on the matter. Most people have the ability to easily present information to the brain visually.
Think for example, how hard it is for you to multiply five digit numbers in your head and how less effort does it cost when you use a pen and paper (we eliminate the possibility of using electronic calculating devices, of course). It is basically the same with problem-solving, when you need a clear view on the problem you should use pen and paper. When you need to check for flaws in your algorithm, you should make some calculations using a pen and paper. When you need to think about a case in which your algorithm might not work, you should use pen and paper. That’s why you should always use pen and paper!
Generate Ideas and Give Them a Try!
As we have mentioned previously, the first thing to do is to sketch some sample examples for the problem on a piece of paper. When we have a real example of the problem in front of us, we can reflect on it and the ideas come.
When the idea is a fact, we need more examples in order to check if it is a good one. Then we need some more examples, drafted on paper to verify it again. We should be completely sure our solution is correct. Then we should go through our solution one more time, step by step, the same way like one actual computer program would do, and see if everything runs correctly.
The next thing to do is to try "breaking" our solution and thinking of a case, in which our idea would not work properly (a counter-example). If we fail at that, then our idea is probably right. If our solution definitely has a flaw, we should think of a way to fix it. If our idea does not pass every test, we should invent a new one. Not always the first idea that comes to your mind is the right one and is a true solution of the problem.
Problem-solving is an iterative process, which represents the invention of ideas and then testing them over different examples until you reach one, which seems to work correctly with every example that you could think of.
Sometimes it can take hours for you to try and find the right solution of a given problem. This is completely normal. Nobody has an ability to instantly find the correct solution of a problem, but surely the more experience you have the faster the good ideas will come. If a particular problem has something in common with one that you have solved in the past, then the proper idea will come to your mind more quickly, because one of the basic characteristics of the human brain is to work with analogies. The experience you get from solving given type of problems will help you with the invention of ideas for a solution of other analogical problems.
In order to generate ideas and test them it is mandatory to have a piece of paper, pen and different examples, which you need to visualize with the help of drafts, sketches or other means. That can help you a lot to quickly try different ideas and reflect on the solutions, which can occur to you. The basic things you need to do when you solve problems is to logically think of some problems that are analogical to the current one, summarize or try to use general ideas and then construct your solution using pen and paper. When you have a sketch in front of you it is easier to imagine what could possibly go wrong. This might give you an idea for the next step or make you give up your current idea entirely. In this way we can get a complete algorithm, the correctness that can be tested by a specific example.
 	The problem solving starts with the invention of ideas and testing them. This is best done with a pen and paper in hand and sample sketches and drafts to help you think. Always test your ideas and solutions with proper examples!
The recommendations given above are also very useful in one more case – when you are at a job interview. Every experienced interviewer could agree, that when he gives an algorithmic problem to the interviewee he expects from him to take a pen and piece of paper, to reflect on the problem out loud and to give different suggestions for the solution. This is a sign this person can think and has a proper approach to the problem solving. Thinking out loud and rejecting different ideas shows that the interviewee has the right thinking. Even if he fails to solve the problem, this behavior will make a good impression to the interviewer!
Decompose the Task into Smaller Subtasks
Complex tasks can always be divided into smaller more manageable subtasks. We will show this with some examples below. There is not a single complex problem in this world that has been solved with one try. The correct formula for solving such a task is to split it into smaller simpler tasks, which have to be independent and different from one another. If these smaller subtasks prove to be complicated, we should split them again. This technique is called "divide and conquer" and it is in use since the time of the Roman Empire.
The division of the problem into smaller units is easier said than done. The essence of solving algorithmic problems is in the good technique of division of the given task into simpler subproblems and, of course, the invention of good ideas that can be achieved with gaining more experience.
 	Complex tasks can always be divided into smaller more manageable subtasks. When you have to solve big complicated tasks, you should always try to divide it into simpler problems, which are easier to solve.
"Cards Shuffle" Problem – Example
Let’s give the following example: we have one ordered deck of cards and we have to shuffle it in random order. Let’s assume that the deck is represented as an array or list of N objects (every card is an object). These types of tasks require multiple repeating steps (series of removal, placing, replacing and realignment of elements). Each of these steps itself is simpler, easier and more manageable subtask, than the "Cards Shuffle" task as a whole. If we succeed in decomposing the complex task into smaller subtasks, we will basically find the right way to solve the problem. Exactly this is the essence of the algorithmic thinking: the ability to decompose complex problems into smaller ones and then find the correct solutions for them. Of course, this principle can be applied not only to programming problems, but also to ones from other scientific disciplines like math and physics. In fact this algorithmic thinking is the reason why the mathematicians and the physicists show a rapid progress when they begin to learn computer programming.
Now let’s go back to the given task and think about how to find the simple subtasks, which are needed in order to meet the requirements to randomly shuffle the cards.
If we take one deck of cards in our hands or try to sketch something on paper (e.g. series of rectangular cells, each of them representing one card), some ideas instantly come up, for example we need to change or realign elements from the deck.
Thinking like this, we can easily reach the conclusion we need to make more than one swap of one or more cards. If we make only one swap, the deck of cards would not be completely random. Therefore we need many simpler operations for a single swap (exchange).
We reached the point where we do the first decomposition into smaller subtasks: we need series of swaps, which can be considered as smaller tasks, a part of the bigger problem.
First Subtask: a Single Swap
How do we make a single swap of cards in the deck? We can answer this question in many ways and take the first idea that come to our mind. If it is any good, we will use it. Otherwise we will think of something else.
Our first idea can be: if we have a deck of cards, we can split it at random card and then separate and swap the two parts. Now do we have an idea for a single swap? Yes, we have. The next thing to do is to check if our solution is working properly (we will demonstrate this after a while).
Now let’s go back to the base task: after applying our idea, we need the deck of cards to be randomly shuffled. Now we split and swap it many times and check the result. It seems that our algorithm works fine and the subtask "single swap" will do the work.
Second Subtask: Choosing a Random Number
How to generate a random number and use it to split the deck? If we have N cards, we need a random number between 1 and N-1, don’t we?
In order to solve this problem we might need an additional help. If we know that in .NET Framework this task is already solved, we can simply use the integrated random number generator.
Otherwise we have to think of a solution e.g. we can read one line from the keyboard and then measure the time span between the start of the program and the pressing of the button [Enter]. Since the time of every input is different (especially, if we report with accuracy to nanoseconds), we have a way to calculate a random number. The only problem now is to find a way to place this number in the interval [1…N-1] and probably most of us will remember that we can use the remainder of its division by (N-1).
We can see that even the simplest subtasks can be divided into smaller tasks, which sometimes can be already solved for us. When we find a suitable solution for the current subtask, we need to go back to the base problem and test everything and see if it is working correctly put together. Let’s do that now, shall we?
Third Subtask: Combining Swaps
Let’s go back to the main task. We have reached the conclusion we have to make as many "single swap" operations as needed to ensure the deck of cards will be correctly shuffled. This idea seems right and we should try it.
Now this raises the question how many operations "single swap" are enough? Are 100 enough? Aren’t they too many? And what about 5 times? In order to give a good answer to this question, we need to think for a while. How many cards do we have? If we have several cards in the deck, we need fewer swaps. And if we have many cards, we need much more swaps, right? Therefore the number of swaps depends on the number of cards in the deck.
To see how many swaps are enough, we can take one standard deck of cards. How many cards are there in one standard deck? Most of us know there are 52 cards in it. Well then try to figure out how many "single swap" operations are needed to randomly shuffle one deck of 52 cards. Are 52 enough? It seems enough because if we swap 52 times at random position it is likely that we will split the deck at every card (this conclusion is clear even if we do not know anything about Probability and Statistics). 52 "single swap" operations seem too much, isn’t it? Let’s think of even smaller number. What about the half of the number 52? It seems fine as well, but it would be more difficult to explain why.
Some of you probably think that the best way to find the correct number is to use complex formulas from the probability theory, but does it make any sense? The number 52 is small enough and there is no need to look for other number. One loop of 52 iterations is fast enough. The cards in the deck would not be billions, would they? Therefore we do not have to think in that direction. We assume that the correct number of "single swap" equals the number of the cards in the deck – neither too big nor too small. And this is the end of the current subtask.
Another Example: Sorting Numbers
Let’s think of another example. We are given an array of numbers and our task is to sort it in ascending order. There is an abundance of algorithms for this problem and some of them conceptually different from one another. Even you could think of some ideas to solve this problem, some of them would be right and others – not quite.
So we have to solve this task and we are not allowed to use built-in .NET Framework sorting methods. The first obvious thing to do is to take a pen and piece of paper and to think of one example and then to reflect on the task. Thus we can invent multiple and very different ideas like:
	First idea: we can find the smallest number, print it and then remove it from the array of numbers. The next thing to do is to repeat the same action until the array is empty. Thinking like this, we can decompose this task into simpler tasks: finding the smallest number in array; deleting a number from array; printing a number.
	Next idea: we can find the smallest number and put it at the first position of the array (swap operation). Then we can do the same action for the rest of the array. Since we have already placed number on the first position, we go to the next one. If we repeat this k times, we will have the first k smallest numbers from the array at the first k positions. This approach takes us naturally to a task, which can be very easily divided into smaller subtasks: finding the number with the smallest value in a part of the array and exchanging the positions of two numbers from the array. The second subtask can be divided one more time: removing an element from a given position and placing an element at a given position.
	Another idea, which uses a method, conceptually different from the previous two solutions: we split the array into two subarrays with approximately the same number of elements. Then we sort them individually and finally we merge them into one. We can do this action recursively with every subarray until every one of them holds exactly one element. Array with one element is a sorted one. Here, like in the previous two ideas, we can divide the complex problem into smaller more manageable problems: splitting one array into two parts with approximately equal number of elements; merging two arrays into one big array.
There is no need to continue, right? It is obvious that every one of you can think of several different solutions or you can read about the subject in a book about algorithms. We demonstrated that every complicated problem can be divided into smaller simpler problems. These is a correct approach to solving computer programming problems – to think of the big task like it is a collection of smaller easier subtasks. This technique may be hard to learn, but in time you will get used to it.
Verify Your Ideas!
It seems that we have figured out everything. We have an idea. It seems to work properly. The only thing for us to do is to check if our idea is correct or it is only correct in our minds. After that we can start with the implementation.
How to verify an idea? Usually this happens with the help of some examples. We should choose examples that fully cover all different cases, which our algorithm should be able to pass. The sample examples should not be too easy for your algorithm, but also they should not be so hard to be sketched. We call these certain types of examples "good representatives of the common case".
E.g. if our task is to sort an array in ascending order, then a suitable example would be an array with 5-6 elements. Two of the numbers in the array should be equal and the other – different. The numbers should be randomly placed in the array. This is a good example, because it covers most of the common cases, in which our algorithm should work.
There are many inappropriate examples for the sorting numbers problem that could not help you test your idea properly. For example if you use an array of only two elements. Your solution could work correctly with it, but your core idea could be completely wrong. Another inappropriate example is an array of equal numbers. Every sorting algorithm would work correctly with it. And another bad example – we can use an array that is already sorted. Algorithm could also work correctly and yet the idea could be wrong.
 	When verifying your ideas, choose your examples carefully. They should be simple and easy enough for you to be able to sketch them down by hand in a minute and at the same time they should represent most general case in which your idea should work. Your examples should be good representatives of the common case and cover as much cases as possible without being too big and complicated.
"Cards Shuffle" Problem: Verifying the Idea
Let’s think of one sample example for our "Cards Shuffle" task. Let’s say we have 6 cards. In order our example to be good, our deck of cards should not be too small (e.g. 2-3 cards), because in this way our example might become very easy. Also, if we want to easily check our idea with the deck, it should not be too big. Initially it is a good idea to get six cards and order them in the deck. In this way it would be easier for us to see if the cards are well shuffled or partially shuffled or not shuffled at all. So one of the smartest things to do is to choose 6 cards regardless of their suit and order them by value.
Now we already have one example, which is a good representative of the common case of our problem. Let’s now sketch it down on a piece of paper and check our algorithm on it. We should split the deck into two parts, at a random position 6 times and then swap them. Our cards are ordered by value. At the end we expect them to be randomly shuffled.
Let’s see what is going to happen:
 
There is no need to do 6 swaps. After only 3 swaps we came back to the starting position. This is probably not an accident. What happened? We have just found an error in our algorithm. When we reflect on the problem we can see that with every swap at a random position we rotate the deck to left and after N times it goes to the starting position. So it was a good thing that we tested our idea before even started writing some code, wasn’t it?
Sorting Numbers: Verifying the Idea
It is time to check our first idea considering the sorting numbers problem. We can easily see if it is right or wrong. We start with an array of N elements and we find the smallest number, print it and then delete it from the array N times. Even if we do not sketch the idea, it seems faultless. Still let’s think of one example and see what is going to happen. We take 5 numbers, two of them are equal: 3, 2, 6, 1, 2. We have 5 steps to do:
	3, 2, 6, 1, 2 > 1
	3, 2, 6, 2 > 2
	3, 6, 2 > 2
	3, 6 > 3
	6 > 6
Seems like our algorithm works properly. Our result is correct and we do not have a reason to think that our idea will not work with any other example.
If a Problem Occurs, Invent a New Idea!
When you find your idea is incorrect, the obvious thing to do is to invent a new, better idea. We can do this in two ways: we can either try to fix our old idea or create a completely new one. Let’s see how this works with our cards shuffle problem, shall we?
 	The creating of a solution for a computer programming problem is an iterative process, which consists of inventing ideas, verifying them and sometimes, when problem occurs, inventing new ones. Sometimes the first idea that comes to our mind is the right one, but most of the times we need to go through many different ideas until we reach the best one.
Let’s go back to our card shuffle problem. Firstly let’s see why our premier idea is wrong and is it possible to fix it? The problem here is easily recognized: the continuous splitting and card swapping does not shuffle them randomly; it simply rotates them to left.
How to fix this algorithm? We need to think of a new and better way to make a "single swap" operation, don’t we? Our new idea for one single swap is: randomly choose two cards from the deck and swap their places. If we do this N number of times, we would probably get randomly shuffled deck. This idea looks better than the previous one and maybe it would work correctly this time. We already know that before we even start thinking of implementing our new algorithm it is better to check it and see if it is working properly. We can verify our idea by using pen and paper and the example with the 6 cards that we used above.
In this moment we think of an even better idea, instead of choosing 2 random cards from the deck, why not just pick one random card and swap it with the first card from the deck? Isn’t this idea simpler and easier to implement? The result should be random too. Let’s start by choosing a random card at position k1 and swap it with the first card. Now we have a random card at the first position and the first card is at the k1 position. On the next step of the algorithm we pick another card at random position k2 and then swap it with the card from the first position (previously the card from the position k1). It is apparent that with only 2 steps we have changed the place of the first, the k1-st and the k2-nd cards from the deck with random cards. It seems that at every step one card changes its position with a random one. After N number of steps we can expect that every card from the deck has changed its position averagely one time. Hence our solution is working and the cards should be well shuffled.
Now we should test our new idea. Does it work properly? Let’s make sure that what has happened last time will not happen again, shall we? Let’s thoroughly check this idea as well. Again, we can take the 6 cards example, which represents most of the general cases of the card shuffle problem (good representative of the common case). Then use the new algorithm and shuffle them. We should do this 6 times in a row. This is the result:
 
From the example above we can see that the result is correct – we have randomly shuffled six cards. If our algorithm works well with 6 cards, it should work with decks with different number of cards as well. If we are not sure in that, we should think of another more complicated example and then test the algorithm again.
Otherwise we could avoid drawing new examples and continue with our task.
Let’s summarize what we have done so far and how with consecutive actions we have figured out a solution for our problem. As we have gone through every step, we have done so far the following steps:
	We have used a sheet of paper and pen to sketch a deck of cards. We have visually represented the deck of cards as an array of boxes.
	As we already have a visual feedback, we could easily think of some sample ideas: firstly we should make some kind of a single swap operation and secondly we do this N number of times.
	We had decided that our "single swap" operation was going to be splitting the deck at random position into left and right part and then swap them.
	We have decided that we should do this "single swap" as much times as the number of cards in the given deck.
	We have considered the problem of choosing a random number, but have finally decided to use a ready solution for the job.
	We have decomposed the main problem into three smaller subtasks: "single swap" operation; choosing a random split point; combining a sequence of "single swap" operations.
	We have checked our idea for mistakes and found one. It was a good thing to check it when we did, because it was not too late to fix it.
	We have thought of a new, more reliable solution of the single swap operation.
	We have checked our new idea with an appropriate example and we assured ourselves that this time the solution was right.
Now we finally have a working idea, backed up with good examples. This is the most important thing to do in order to solve a given problem – inventing of the algorithm. The easier part remains – the implementation of our idea. Let’s see how this can be done.
Choose Appropriate Data Structures!
If we already have a correct and working idea for the solution of the problem, the next thing to do is to write the program code. We have missed something, right? What have we missed? Have we done everything necessary to be able to write fast, easy and trouble-free implementation of our solution?
The thing that we have missed is the manner in which our idea (which we have checked on a sheet of paper) is going to be implemented as a computer program. The implementation is not always a simple task and sometimes it requires additional ideas. This is the next major step: to think of our ideas in terms of the computer programming. This means to think for specific data structures and not for abstract ones like "card" and "deck". We should choose the right data structures, which are going to help us build a correct solution.
 	Before you even start with the implementation of your idea, you should choose the proper data structures. It may turn out that your current idea is not as good as it seems. The solution could be inefficient or difficult to implement. It is better to figure this out before you write any programming code!
In our case we have spoken of swapping one card from the deck with another, but in terms of programming this means to swap two elements from specific data structure (i.e. array, list or something else). We have reached the moment where we have to choose one data structure and show you how it is done.
What Kind of Data Structure Should We Use?
The first question that comes to our mind is: What kind of data structure should we use? We may have all kinds of different ideas for data structures, but not all of them can do the work. Let’s reflect for a while, shall we? We have a collection of cards and the way in which the cards are ordered matters. That’s why we need a data structure that can hold a collection of elements and keep their order.
Can We Use an Array?
The first thing we can think of is using the structure "array". The array structure is the simplest data structure, which can hold a collection of elements. The array also keeps the order of the elements (first, second, third and so on) and we can reach each element by index. The array has a fixed number of elements and we cannot change its size during the execution of the program.
Is the array the correct data structure for us? To answer this question we have to know what kind of operations we are going to apply on the deck, represented as an array, and whether they are feasible and efficient.
What kind of operations are we going to apply in order to implement our algorithm? Let’s enumerate them:
	Choosing a random card. Since we can access every element from the array by index we can easily pick a random position k between the interval [1…N-1].
	Swapping the first card with the k-positioned one (single swap). After choosing the random card, we should swap it with the first one. Again this operation seems easy enough. We can do the swap with three simple steps and one temporary variable.
	More operations that we might use: initialization of the deck; traversing the deck; printing the deck. All these operations seem trivial when applied on array.
It seems that one simple data structure like the array can represent a deck of cards quite well.
Can We Use Another Data Structure?
It is normal to ask ourselves whether an array is the best data structure for our problem. It seems that every operation that we use in our algorithm can be applied efficiently to the array.
But still, let’s try and think of an even better data structure for the deck of cards than the array. What other options do we have?
	Linked list – we do not have an indexer and it will be difficult for us to access element at a random position.
	Array with a non-defined size (List<T>) – this structure seems to have all the benefits of the arrays and we can apply every operation to it as well. If we use List<T>, we increase our comfort – we can easily remove and add elements, which may help us to initialize the deck faster and do some other helpful operations.
	Stack / queue – the deck of cards does not have a behavior of FIFO or LIFO, so these structures are not appropriate for our algorithm.
	Sets (TreeSet<T> / HashSet<T>) – with the use of sets we lose the original order of the elements which is a major obstacle. The use of sets is inappropriate.
	Hash table – the structure card deck is not from the type key-value, so the structure hash table cannot store the deck efficiently. Also it does not allow us to keep the original order of the elements.
Generally speaking, we have just covered the basic data structures, which can hold a collection of elements. We have reached the conclusion that either array or List<T> will be suitable for the job. List<T> is more flexible than the ordinary array, so we decide to use List<T> to represent our deck of cards.
 	The choice of data structure begins with the consideration of all key operations that we are going to perform on it. Next we analyze all suitable structures and choose the one that will be the most efficient and easiest to use. And sometimes we should make a compromise between efficiency and the simplicity. 
How to Represent the Other Data Objects?
We have already decided how to represent our deck of cards and now we should do the same with the other objects that we are going to use in our algorithm. If we think about it, it seems that beside the two objects a "card" and "deck", which we use in our algorithm, we do not use other data objects.
The next question that arises is how to represent a single card? We can represent it as a string, number or class, which has two fields – face and suit. There are, of course, other variants, which have their advantages and disadvantages.
Before we even start considering which of these representations of one card is "the best", we should go back to the requirements of the task. It suggests that we are given a deck of cards (as an array or list) and our task is to shuffle it. How a card is represented is not of importance in the task. So it does not matter what we shuffle, we could shuffle cards, chess figures, boxes of tomatoes or other objects. We have an ordered collection of elements and we need to randomly shuffle it. The fact that we shuffle cards is not significant for our task, that’s why we do not need to waste time to choose the best way to represent one card. Let’s use the first thing that come to our mind, i.e. we will define a class Card with 2 fields – Face and Suit. Even if we use a number between 1 and 52 to represent one card, it still does not change anything. We shall not discuss this any further.
Sorting Numbers: Choosing a Data Structures
Let’s go back to the sorting numbers problem and choose an appropriate data structures for it too. We choose to use the simplest algorithm that we could think of: to pick the smallest number until we can, print it and after that delete it. This solution can be easily sketched on a piece of paper and checked for errors.
Again, in order to answer this question we need to figure out what kind of operations we are going to use in our algorithm. The operations are as follows:
	Searching for the smallest number in the structure.
	Removing of the previously found smallest number.
Obviously, the use of an array is not reasonable, because we need the operation "remove". The use of List<T> seems better, because both operations can be simply and easily implemented. Data structures like stack or queue have a little use for us, because we do not have a LIFO or FIFO behavior. There is not much sense to use a hash table, because the "search by value" operation is not fast, despite the fact that the removal of an element should be very efficient.
Let’s talk about the two sets – HashSet<T> and TreeSet<T>. The two sets have one major problem. They cannot contain elements with an equal value. Despite that let’s see what they can do. The HashSet<T> is not of any interest, because like the hash tables it does not support efficient way to find the element with the smallest value. The data structure TreeSet<T>, however, looks very promising. Let’s take a look, shall we?
The TreeSet<T> class is a balanced search tree by design, so it supports the operation "finding the smallest element". That’s interesting, isn’t it? Now we have a new solution for the task, we put all the input elements in a TreeSet<T> and then we get the smallest from the set until it remains empty. Easy, simple and very efficient. The two operations, which we want, are internally implemented (searching for the smallest number and deleting it).
While we skim through the documentation, we figure out something very interesting: the TreeSet<T> stores its elements ordered by value. And this is the solution of our problem, right? Therefore if we keep all the input elements in a TreeSet<T> and then traverse the ordered set (with the help of the built-in enumeration), we will have all the elements ordered by value. Problem solved!
We are now very happy, we found one very nice way to solve our task, but soon we discover one major problem: TreeSet<T> does not store two elements with the same value. I.e. if we add the number 5 several times, at the end there will be only one entry with a value 5. Eventually we will lose some of the input elements irreversibly.
Naturally we want this problem fixed. If there was a way to store how many times one number occurs in a set that would solve our problem. Then we think of the SortedDictionary<K,T>. This class can store ordered keys, which have a value. We can store the number of occurrences of a key in its corresponding value. We can traverse all the elements and then store the number of occurrences in the SortedDictionary<K,T>. Although it seems our problem is solved, it is not going to be implemented as elegant and simple as with List<T> or TreeSet<T>.
If we read the documentation of the SortedDictionary<K,T> carefully, we will find that this class internally uses a red–black tree and some day we can implement that this type of sorting is very famous and it is called a Binary Tree Sorting (http://en.wikipedia.org/wiki/Binary_tree_sort).
With this little demonstration we showed you how when you put some thoughts into the selection of the best data structures, you can come up with some new solutions for the problem. We start with an algorithm, which leads us to a new, better one. This is normal to happen during the process of consideration of our algorithm and not after we have written 300 lines of code, which we will then have to be redone. This is another proof it is better to firstly think of the best data structures and then to start writing the programming code.
Think about the Efficiency!
Again, it seems we should grab the keyboard and start writing a programming code. And again, it is better not to hurry. The thing is that we have not thought of something very important: the efficiency and performance of our algorithm.
 	You should think of efficiency before writing even a line of a programming code. Otherwise, you risk to waste time implementing an algorithm, which is inefficient and slow. 
Let’s return to our "card-shuffle" problem. We have a working idea for solving the problem (we have invented the algorithm). The idea appears to be correct (we have checked the algorithm with examples). We should not have any problems implementing our idea (we are going to use List<Card> for the deck and class Card for a single card). Everything seems fine, but let’s think about how many cards we are going to shuffle. Is our idea going to work fast enough when using the chosen data structures?
How to Estimate the Performance of Given Algorithm?
How fast is our algorithm? To answer this question we should estimate how many operations it performs when shuffling one deck of 52 cards.
For one deck of 52 cards our algorithm makes 52 "single swap" operations, do you agree? How many elementary operations cost one "single swap"? 4 operations: the choice of one random card; the placing of the first card in a temporary variable; the replacing of the first card with the random card; the replacing of the random card with the first card (from the temporary variable). How many operations does our algorithm do? They are approximately 52 * 4 = 208.
Are 208 operations too much? Let’s do a loop with 208 iterations. Are they too much? Give it a try! We can assure you that one loop with 1,000,000 iterations on a modern computer goes imperceptibly fast, and one with 208 – for an insignificant amount of time. Therefore we can easily conclude that our algorithm has a good performance. Our algorithm is extremely fast when working with 52 cards.
Despite the fact that in reality we rarely play cards with more than 1 – 2 decks, let’s assume that we have 50,000 cards in the deck. Let’s estimate the performance of our algorithm with a large number of cards. We have 50,000 single swap operations and each of them consists of 4 operations, which makes about 200,000 operations, which are going to be executed for a small amount of time as well.
The Efficiency Is a Matter of Compromise
Finally we can conclude that our algorithm is efficient and will work well even with decks with large amount of cards. Here we had luck. Usually the things are not so simple and we must make a compromise with the performance and the efforts, which we put, when we implement our algorithm. For example if we sort numbers, we can solve this problem in minutes when we use some of the simplest sorting algorithms. We can also do this much more efficiently when we use some of the more complex algorithms, but that will waste more of our time (in searching and reading books and Internet).
Is it worth it? We should consider that. If we have to sort 20 numbers, it does not matter which algorithm we are going to use. It will always be fast, even with the most naive algorithm. If we are going to sort 20,000 numbers, the algorithm matters, and if we need to sort 20,000,000, we should look at the task from a completely new angle. The efforts for solving efficiently the problem of sorting 20,000,000 numbers is far more than the efforts for writing a straightforward algorithm to sort 20 numbers. We should answer the question: is it worth it?
 	The efficiency is a matter of compromise – sometimes it does not worth to complicate your algorithm and put time and effort to make it work faster. But occasionally the performance is crucial and we should pay serious attention to it. 
Sorting Numbers: Estimating the Performance
It is obvious that the performance depends on whether a particular task requires it. And now let’s return to the sorting numbers problem, because we want to show you that the efficiency is directly related to the right choice of data structures.
Let’s go back to the point where we have decided what kind of data structures to use for keeping the input data. Which is better: List<T> or SortedDictionary<K,T>? Shouldn’t we use a data structure that we know well instead of some complex structure that we have never used? Do you know well red-black trees (the internal implementation of the SortedDictionary<K,T>)? With what are they better than List<T>? In fact it may turn out that you do not need to answer this question after all.
If we have to sort 20 numbers, does it matter what data structure are we going to use? We can choose the simplest algorithm and the first data structure that is actually suitable for the job and that’s it. It does not matter how fast is the algorithm and the data structure, because the numbers are not so many.
But if we have to sort 300,000 numbers, then everything is different. We should carefully study how exactly the class SortedDictionary<K,T> behaves. We should figure out how fast is the "search" operation. How fast does this data structure add elements? How fast can you traverse through every element of the collection? If we read the documentation of the class we will see that the adding of an element takes on average log2(N) steps, where N is the number of the elements in the structure. After few simple mathematical calculations (which require additional skills), we can roughly estimate that we need about 5-6 million steps to sort all numbers. For 300,000 numbers this number is reasonably small.
Similarly we can prove that the search and delete operations in List<T> with N elements take N steps. Therefore for 300,000 elements we will need roughly 2 * 300,000 * 300,000 steps. In fact this number is an approximate guess, because at the beginning we have one number in the list, not 300,000 elements. Nevertheless this estimation is approximately right, maybe a bit rough but right. We can see that the number of steps needed in this case is extremely large, that is why here the simple algorithm will not work properly (the program might "hang").
And again we reach a point where we need to choose between one simple and one complex algorithm. One of them can be very easily but slow when implemented. The other is more efficient, but very difficult to implement and we will probably need an additional reading of documentation and thick books in order to correctly estimate the performance. Everything is a matter of compromise.
Naturally, at this point we can think of some of the other algorithms that we have considered previously. And precisely, to split the array into two parts then to sort them separately (by a recursive call) and then merge the two parts into one sorted array. As we consider this algorithm we will find that this solution will work efficiently with such structures like the dynamic array (List<T>). This sorting algorithm has an average and worst-case perfor¬mance of n*log(n) steps, where n is the count of the elements in the array. This algorithm will work efficiently with 300,000 numbers. Let’s not go any further, if you want more details about the algorithm you should read more about MergeSort in Wikipedia (http://en.wikipedia.org/wiki/Merge_sort).
Implement Your Algorithm!
We have finally reached the time where we can start with the implementation of our solution. We already have a working idea, we have chosen the best data structure and now it is the time to start writing the programming code. If we have not done some of the previous steps, we should go back to them before start writing the code.
 	If you do not have an invented idea, do not start writing programming code! What are you going to write if you do not have a working idea? This is like to go to the train station and get on the first train that you can see, without even deciding where you are going. 
This is typical for novice programmers: once they see the requirements, they proceed with the writing of the programming code. After some time, that they waste in a pursuit of wrong ideas (that occur to them during the writing), they realize that it is better to stop and think a bit more about the solution. This whole concept is wrong and the main goal of this chapter is to protect you from this frivolous and very inefficient approach to problem-solving.
 	If you have not checked your ideas, there is no sense to start implementing them! Is it necessary to write 300 lines of code before implementing that your idea is totally wrong? Is it necessary for you to start over?
The implementation of already invented and checked idea is very easy and simple. But the implementation itself requires additional skills and mostly experience. The more experience you have the faster and easier it will be for you to write efficient programming code. With lots of practice, which will come with time, you will become very skilled in writing high-quality code and you will be able to write code faster. If you want to know more about high-quality programming code you should read the chapter "High-Quality Programming Code". But for now let’s focus on the implementation of our ideas.
We assume that you should already know the basic steps needed to write programming code: you know how to work with the development environment (Visual Studio), the compiler; how to understand the error messages and use the "auto complete" function; how to create methods, constructors and properties and fix errors and use the debugger. Therefore these next advices are not so much connected with the writing itself but with the overall approach when writing programming code.
Write the Code Step by Step!
Have you written 200-300 lines of code without even compiling or testing it? Do not do that! Do not write large lumps of code at one time, instead you should write small parts and then test them.
How to write code step by step? This depends on the given task and the way, in which it is decomposed into smaller tasks. For example if the main task consists of 3 independent parts, we should write one of them, compile and test it with a proper input data until we are sure that it works correctly. After that we move to the second part – write code, compile, test and then proceed with the third part with the same approach and finally integrate the parts and test everything as a whole.
Why to write code step by step? Because we reduce the amount of code that we have to concentrate on in any given moment. By treating the problem in parts, we decrease its complexity. Remember: the large and complicated task could always be divided into several smaller and simpler subtasks. And it is always easier to solve simple problems.
When writing large chunks of code, without compiling it, we accumulate a great amount of errors, which could easily be avoided by a simple compilation. The modern programming environments (like Visual Studio) try to recognize the syntactic errors automatically while we are writing the code. Use this function and fix the obvious coding errors as early as possible. Early troubleshooting takes less time and nerves. However if we delay the troubleshooting, it could cost us a lot of efforts, sometimes even rewriting the whole programming code.
When you write a huge amount of code, which is not tested, and decide to test it as a whole with some input data, you usually receive a lot of errors, which can be avoided if one just compiles. The larger the code is, more difficult it is to be fixed. These problems could be caused by a variety of reasons: incorrect use of data structures; wrong algorithm; badly structured code; bad condition in the if-statement; wrongly implemented loop; going out of bounds of the array and many other problems that could have been fixed earlier. Do not wait for the last moment. Eliminate the mistakes as soon as possible!
 	Write your program in parts, not at once! Take, write and compile one logically independent part, fix the errors, test it and if it works fine, move to the next part.
Writing Code Step by Step – Example
In order to demonstrate how to write code step by step, we should illustrate it with the "card-shuffle" algorithm that we invented previously.
Step 1 – Defining the Class "Card"
Our task is to shuffle the card deck, so let’s start with the definition of the class "card". If we do not have an idea of how to represent one single card, we could not have any idea how to represent a deck as well. Therefore it will not be possible to define a method for shuffling the cards. We have already agreed the representation of one card does not matter, so any kind of them might work.
We will define a class "card" with fields face and suit. We will use a string variable for the face of the card (with possible values: "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K" or "A") and enumerable variable for the suit of the card (possible values: "Club", "Diamond", "Heart", "Spade"). The class Card might look like the following code:
Card.cs
class Card
{
	public string Face { get; set; }
	public Suit Suit { get; set; }

	public override string ToString()
	{
		string card = "(" + this.Face + " " + this.Suit + ")";
		return card;
	}
}

enum Suit
{
	CLUB, DIAMOND, HEART, SPADE
}
For comfort we have overridden the method ToString() for the class Card. In this way we could easily print a single card on the console. We have defined enumerable type for the Suit.
Testing of the Class "Card"
Some of us would probably proceed with writing the code, but if we follow the principle "Writing Code Step by Step", we should firstly compile and test how the class Card works.
In order to do so, we can write a small simple program to initialize a single card (e.g. Ace of Clubs) and print it on the console. This will check whether our class Card, its constructor and its ToString() method work correctly:
static void Main()
{
	Card card = new Card() { Face="A", Suit=Suit.CLUB };
	Console.WriteLine(card);
}
We start the program and check if the card is printed correctly. We should see the following:
(A CLUB)
Step 2 – Creating and Printing a Deck of Cards
Before we proceed with the main task (randomly shuffling the deck of cards) we should try to initialize and print a whole deck of 52 cards. Thus we will be completely sure that the input data for the card-shuffle method is correct. Based on our previous analysis on the data structures, we should use List<Card> in order to represent the deck. Let’s create and print a deck of five cards, shall we? Later we can try with a full deck of 52 cards.
CardsShuffle.cs
class CardsShuffle
{
	static void Main()
	{
		List<Card> cards = new List<Card>();
		cards.Add(new Card() { Face = "7", Suit = Suit.HEART });
		cards.Add(new Card() { Face = "A", Suit = Suit.SPADE });
		cards.Add(new Card() { Face = "10", Suit = Suit.DIAMOND });
		cards.Add(new Card() { Face = "2", Suit = Suit.CLUB });
		cards.Add(new Card() { Face = "6", Suit = Suit.DIAMOND });
		cards.Add(new Card() { Face = "J", Suit = Suit.CLUB });
		PrintCards(cards);
	}

	static void PrintCards(List<Card> cards)
	{
		foreach (Card card in cards)
		{
			Console.Write(card);
		}
		Console.WriteLine();
	}
}
Printing the Deck – Testing the Code
Before we proceed forward, let’s start the program and verify the output result. It seems that there are no mistakes, the result is correct:
(7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
Step 3 – Single Swap
Let’s implement the next step to the task solution – the subtask "single swap". When we have a logically independent piece of code, the best thing to do is to extract it as a separate method. We should think of what is our input and output. Our input should be a single deck of cards (List<Card>). As a result of its work the method should change the input deck List<card>. The method should not return any result, because it does not create a new List<Card>, it just operates with the already created and submitted list.
What should be the name of the method? Following the recommendations for working with methods, we should give "descriptive" name (with 1-2 words) what the method is for. Suitable name for it is: PerformSingleSwap(…). The name clearly describes what the method does: executes a single swap.
Let’s firstly define the method and then write its body. This is a good practice, because before we proceed with the implementation of the method, we should be aware: what does it do; how does it work and what is its name. Here it is the definition of the method:
static void PerformSingleSwap(List<Card> cards)
{
	// TODO: Implement the method body
}
The next thing to do is to write the body itself. Firstly let’s recall the algorithm: we choose one random number k in the interval between 1 and the length of the array minus 1 and then swap the element at the position k with the first element. Everything seems easy, but how do we generate a random number in a given interval with the language C#?
Search in Google!
When we encounter a common problem, which we cannot solve, but we are sure that many people have faced it, the easiest way to cope with it is to search for information in Google. We should adequately structure our search. In our case we look for sample C# code, which returns as a result a random number in a given interval. We could try the following search:
C# random number example
Among the first results there is a C# program, which uses the class System.Random for generating a random number. Now we have a direction in which we look for a solution. We know that in .NET Framework there is a standard class called Random, which serves for generating random numbers.
After that we could try to guess how this class works (most of the times it takes less time to guess instead of reading the documentation). We are trying to find an appropriate static method for generating a random number, but it seems there is none. Then we make an instance and search for a method, which could return a number in given a diapason. We have luck, there is a method Next(minValue, maxValue), which returns what we need.
Let’s try to write the whole code for the method. We have the following:
static void PerformSingleSwap(List<Card> cards)
{
	Random rand = new Random();
	int randomIndex = rand.Next(1, cards.Count - 1);
	Card firstCard = cards[1];
	Card randomCard = cards[randomIndex];
	cards[1] = randomCard;
	cards[randomIndex] = firstCard;
}
Single Swap – Testing the Code
The next step is to test the code. Before proceeding forward, we have to be sure that the single swap (exchange) operation works properly. We do not want to find an eventual problem just when we test the "card-shuffle" method with the entire deck? It is better when there is a problem to be found immediately and when there is none, to continue forward with confidence. We act step by step – before going to the next step we should make sure that the current step is working fine. For this purpose we make a small test program, let’s say with 3 cards (2¦, 3¦ and 4¦):
static void Main()
{
	List<Card> cards = new List<Card>();
	cards.Add(new Card() { Face = "2", Suit = Suit.CLUB });
	cards.Add(new Card() { Face = "3", Suit = Suit.HEART });
	cards.Add(new Card() { Face = "4", Suit = Suit.SPADE });
	PerformSingleSwap(cards);
	PrintCards(cards);
}
Let’s perform several times a single swap operation with our 3 cards. The first card (card 2¦) is supposed to be with one of the other two cards (cards 3¦ or 4¦). We execute the program several times in a sequence. We should expect the half of the obtained results to contain (3¦, 2¦, 4¦) and the other half – (4¦, 3¦, 2¦), shouldn’t we? Let’s see what is going to happen. We start the program and see the following results:
(2 CLUB)(3 HEART)(4 SPADE)
We start it again and again and the result is the same – no swap is made. How is that possible? What has just happened? Did we miss to execute the single swap before printing the cards? There is something wrong here. It seems that the program did not make even one swap in the deck of cards. How did this happen?
Single Swap – Correcting the Mistakes
It is obvious that there is a mistake. Let’s put a breakpoint and follow what is happening via the debugger of Visual Studio:
 
It is clear that during the first execution the random position happens to be one. This is acceptable so we continue on. When we look the code we follow, we notice that we swap the random element at index 1 with the element at position 1 i.e. with itself. We apparently did something wrong. And then we remember that indexing in List<T> is zero-based i.e. the first element is at position 0. We immediately change the code:
static void PerformSingleSwap(List<Card> cards)
{
	Random rand = new Random();
	int randomIndex = rand.Next(1, cards.Count - 1);
	Card firstCard = cards[0];
	Card randomCard = cards[randomIndex];
	cards[0] = randomCard;
	cards[randomIndex] = firstCard;
}
We start the program several times and we get unexpected results, again:
(3 HEART)(2 CLUB)(4 SPADE)
(3 HEART)(2 CLUB)(4 SPADE)
(3 HEART)(2 CLUB)(4 SPADE)
It seems that the random number is not so random. What to do now? Do not rush to blame .NET Framework, CLR, Visual Studio and all other usual suspects! It is possible that the mistake is ours. Let’s look at the execution of the method Next(…). Since cards' count is 3, we always call Next(1, 2) and expect from it to return a number between one and two. It seems correct but if we read what the documentation says for the method Next(…), we will notice that the second parameter should be one unit bigger than the upper border we want to obtain.
We were wrong about the diapason of the random number that we selected. We correct the code and once again we test it to see how it works. After the second correction we get the following results:
static void PerformSingleSwap(List<Card> cards)
{
	Random rand = new Random();
	int randomIndex = rand.Next(1, cards.Count);
	Card firstCard = cards[0];
	Card randomCard = cards[randomIndex];
	cards[0] = randomCard;
	cards[randomIndex] = firstCard;
}
Here are the possible results after several executions of the previous method:
(3 HEART)(2 CLUB)(4 SPADE)
(4 SPADE)(3 HEART)(2 CLUB)
(4 SPADE)(3 HEART)(2 CLUB)
(3 HEART)(2 CLUB)(4 SPADE)
(4 SPADE)(3 HEART)(2 CLUB)
(3 HEART)(2 CLUB)(4 SPADE)
It seems that after enough executions the first card is replaced by each of the other two cards i.e. we have a random swap indeed and every card has the equal chance to be randomly chosen. We are finally ready with the method "single swap". It is better that we found these two mistakes now and not later when the whole program is supposed to start working, right?
Step 4 – Card Shuffling
The last step is simple: we use the single-swap method N times:
static void ShuffleCards(List<Card> cards)
{
	for (int i = 1; i <= cards.Count; i++)
	{
		PerformSingleSwap(cards);
	}
}
We now can put it all together. We combine all the pieces of code we already wrote, tested and we checked they work correctly. The entire code of our program looks like this:
CardsShuffle.cs
using System;
using System.Collections.Generic;

class CardsShuffle
{
	static void Main()
	{
		List<Card> cards = new List<Card>();
		cards.Add(new Card() { Face = "2", Suit = Suit.CLUB });
		cards.Add(new Card() { Face = "6", Suit = Suit.DIAMOND });
		cards.Add(new Card() { Face = "7", Suit = Suit.HEART });
		cards.Add(new Card() { Face = "A", Suit = Suit.SPADE });
		cards.Add(new Card() { Face = "J", Suit = Suit.CLUB });
		cards.Add(new Card() { Face = "10", Suit = Suit.DIAMOND });

		Console.Write("Initial deck: ");
		PrintCards(cards);

		ShuffleCards(cards);
		Console.Write("After shuffle: ");
		PrintCards(cards);
	}

	static void PerformSingleSwap(List<Card> cards)
	{
		Random rand = new Random();
		int randomIndex = rand.Next(1, cards.Count);
		Card firstCard = cards[0];
		Card randomCard = cards[randomIndex];
		cards[0] = randomCard;
		cards[randomIndex] = firstCard;
	}

	static void ShuffleCards(List<Card> cards)
	{
		for (int i = 1; i <= cards.Count; i++)
		{
			PerformSingleSwap(cards);
		}
	}

	static void PrintCards(List<Card> cards)
	{
		foreach (Card card in cards)
		{
			Console.Write(card);
		}
		Console.WriteLine();
	}
}
Card Shuffling – Testing
Now we only need to test whether the algorithm for shuffling a deck of cards works correctly. Here is the output of our program:
Initial deck: (7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
After shuffle: (7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
As we can see, we encounter a problem: after the shuffle the cards did not change their order. We run the program several times and the result is the same. Did we forget to call the card-shuffling method ShuffleCards?
We take a close look at our source code: everything looks fine. We decide to set a breakpoint after the call of the method PerformSingleSwap(…) in the body of the loop, responsible for the shuffling of the cards. We run our program in debugging mode by pressing the [F5] button. After the first stop of the debugger at our breakpoint everything seems good – the first card is exchanged with another one, as it supposed to. After the second stop of the debugger everything is still all right – a random card is swapped with the first one. We continue tracing the program execution with the debugger and everything seems to work just fine.
The card shuffling program works flawlessly when we run it step by step through the Visual Studio debugger:
 
But why is the final result wrong? We decide to set another breakpoint in the body of ShuffleCards(…) at the end. The debugger stops and at this point and the result is still correct – the cards are randomly shuffled. We continue debugging and we reach the place where we print the deck. We go pass it and the cards are printed to the console in random order. Strangely: still the correct result. What is the problem?
We start the program without debugging it with [Ctrl+F5]. The result is wrong – the cards are not shuffled. We run our program in debugging mode again with the press of [F5]. The debugger once more stops at the breakpoints and the program yet again is working without any problem. It looks like that, when we run our program in debug mode the result is correct, but when we start it normally, without the debugger, the answer is wrong. Strange indeed!
We decide to add a line of code, which is going to print the deck after every single swap:
static void ShuffleCards(List<Card> cards)
{
	for (int i = 1; i <= cards.Count; i++)
	{
		PerformSingleSwap(cards);
		PrintCards(cards);
	}
}
We run our program in debug mode (with [F5]), observe the execution step by step and we find that it works correctly:
Initial deck: (7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
(A SPADE)(7 HEART)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
(6 DIAMOND)(7 HEART)(10 DIAMOND)(2 CLUB)(A SPADE)(J CLUB)
(J CLUB)(7 HEART)(10 DIAMOND)(2 CLUB)(A SPADE)(6 DIAMOND)
(2 CLUB)(7 HEART)(10 DIAMOND)(J CLUB)(A SPADE)(6 DIAMOND)
(A SPADE)(7 HEART)(10 DIAMOND)(J CLUB)(2 CLUB)(6 DIAMOND)
(10 DIAMOND)(7 HEART)(A SPADE)(J CLUB)(2 CLUB)(6 DIAMOND)
After shuffle: (10 DIAMOND)(7 HEART)(A SPADE)(J CLUB)(2 CLUB)(6 DIAMOND)
We run again our program in normal mode (with [Ctrl+F5]) and the answer is still incorrect. Yet again we try to find out why it is happening:
Initial deck: (7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
(6 DIAMOND)(A SPADE)(10 DIAMOND)(2 CLUB)(7 HEART)(J CLUB)
(7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
(6 DIAMOND)(A SPADE)(10 DIAMOND)(2 CLUB)(7 HEART)(J CLUB)
(7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
(6 DIAMOND)(A SPADE)(10 DIAMOND)(2 CLUB)(7 HEART)(J CLUB)
(7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
After shuffle: (7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
We can clearly see that at every step, on which we expect to be done a single-swap, actually the same cards are swapped: 7¦ and 6¦. The only way this to happen is if every time the random number is the same. The conclusion is that we have a problem with the generation of random numbers. The random generator does not work correctly.
We instantly think about taking a look at the documentation of the class System.Random(). On MSDN we can read, that by creating a new instance of the generator of pseudo-random numbers with the constructor Random(), the generator is initialized with a value, equal to the current system time. In the documentation we can further read that by creating two or more instances of the class Random in a relatively short time span, there is a great chance the numbers to be the same. It turns that the problem consists in the misuse of the class Random.
Now being more familiar with the current problem, we could correct it by creating an instance of the class Random only once at the beginning of the program. After that, if we need a random number, we are going to use the already created generator of pseudo-random numbers. After the correction, the code looks like this:
class CardsShuffle
{
	…

	static Random rand = new Random();

	static void PerformSingleSwap(List<Card> cards)
	{
		int randomIndex = rand.Next(1, cards.Count);
		Card firstCard = cards[0];
		Card randomCard = cards[randomIndex];
		cards[0] = randomCard;
		cards[randomIndex] = firstCard;
	}
	…
}
It seems that the program finally works correctly. At every run the order of the cards is different and looks randomly:
Initial deck: (7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
After shuffle: (2 CLUB)(A SPADE)(J CLUB)(10 DIAMOND)(7 HEART)(6 DIAMOND)
--------------------------------------------------------
Initial deck: (7 HEART)(A SPADE)(10 DIAMOND)(2 CLUB)(6 DIAMOND)(J CLUB)
After shuffle: (6 DIAMOND)(10 DIAMOND)(J CLUB)(2 CLUB)(A SPADE)(7 HEART)
We try some other tests and the final result is still correct. Now we can say that we have a correct implementation of our algorithm, which we have designed earlier.
Step 5 – Console Input
Now we only need to be able to read the deck from the console so that the user can enter the cards, which need to be shuffled. Notice that we left this step as last. Why? The answer is pretty simple: we do not want to enter the same data at the start of our program just to check whether a piece of our code works correctly. By having the needed data hard-coded in the source code, we save a lot of time during the developing process.
 	If the problem involves entering data from the console, leave this as last step and be sure that everything else works flawlessly before implementing the reading of the input. While writing the source code, do your tests with hard-coded examples so that you don’t have to enter any data. This way you are going to save your time and your nerves.
Data entry is a low-priority task, which everyone can handle. You only need to think of the format the cards are entered – are they entered one by one or at once; are the face and the color entered at once or separately. There is nothing difficult so we leave this to our readers.
Sorting Numbers – Step by Step
Till this moment, we showed you how important it is to write your program step by step and before proceeding to the next step you must be sure that the previous one is working correctly.
Let’s take a look at the problem of ordering numbers in ascending order. The steps for solving this problem are the same. Once again the right approach for solving this task is to work step by step. Let’s see shortly which the steps are. We are not going to write any code, but we are going to consider the main parts of the solution. Suppose that we use List<int>, in which we successively find the lowest number, print it and erase it from the list of numbers. These are the steps:
	Think up a good test data (example). For example the numbers: 7, 2, 4, 1, 8 and 2. We create a List<int> and fill it with the numbers from the example. We create a method, which outputs the numbers.
We compile and test the piece of code we just wrote.
	We create a method to find the lowest number in the array and return its position.
We test the method, responsible for the search of the lowest number. We try different sets of numbers to be sure that the search works correctly (we set the lowest element at the beginning, at the end, at the middle; we also consider a case when the lowest number occurs more than once).
	We create a method to find the lowest number, print it and after that delete it.
We test with our example if the method works correctly. We must also try with other examples.
	We create a method to sort the numbers. This method executes N times the previous one (where N is the count of the numbers).
We must test whether everything works correctly.
	If data input is required we implement it after everything else.
You can see that the approach to break the main problem into smaller problems can work well for all tasks. Simply we just need to figure out which are the smaller problems, from the bigger one, and implement them. On every smaller problem implemented we need to test it. After every step we need to start our program to be sure that till this moment everything works flawlessly. In this way we are be able to find out errors quickly and debug them. It would be much faster than trying to debug them after we have written tons of code.
Test Your Solution!
Does the following sound familiar to you: "I am ready with the first task so I have to start the next one."? Everybody has thought of this on an exam. But in programming to be ready with a task means:
	I have understood well the description of the task.
	I have come up with an algorithm to solve the problem.
	I have tested my algorithm on a piece of paper and I am sure that is correct.
	I have thought up for the data structures we need and for the complexity of my algorithm.
	I have written a program, which implements my algorithm correctly.
	I have tested my program with suitable examples so that I can be sure that everything works flawlessly, even in unusual situations.
Inexperienced software developers often forget about the last step. They think that testing is not their job, which is their biggest mistake. It is like to think that Microsoft is not supposed to test Windows and let it crash every minute.
 	Testing is an important part of the programmer’s duties. Writing code without testing is like typing on the keyboard without looking at the screen – you think that the text, you have written, is correct, but most likely it is full of bugs.
Experienced programmers know that untested code is not finished. In most software companies it is completely unacceptable not to test your work.
In the software industry is widely spread the idea of unit testing – automatic testing of every unit of code (methods, classes and modules). Unit testing means, that for every program, we create another one, which to test our work. In some companies firstly they think up the testing scenario, build the tests and only then start working on the program. The things you should know about unit testing are quite many, but you will get more familiar with them as you get deeper in the "software engineering". For now we are going to focus on the manual testing every programmer must do. Unit testing frameworks and test automation can be used to simplify the process.
How to Test?
A program works correctly if it can handle every kind of input data. Testing is a process, which aims to find any type of bugs. It cannot detect whether a program works flawlessly, but it can help you to find most of the bugs, which cause incorrect results and other types of errors.
Sadly you can’t predict all cases and test them. Therefore you must think up examples, which cover most of the situations, which could happen. In this way you could with minimum efforts (i.e. with minimum count of simple tests) to check all common cases of usage of the program. If no bugs are found after testing, this doesn’t mean that the program works 100% correctly, but in this way we reduce the chance of the program to crash in a later phase.
 	Testing can only find the existence of bugs. It can’t prove that a program works flawlessly! Programs, which are carefully tested, have fewer bugs than untested or not carefully tested programs.
It is good to start testing with a typical case for our program. Often this is the same example we have tested on a piece of paper and which our algorithm can handle correctly.
Normally, after the code is written we only need to fix some minor bugs so that our program can pass the test correctly. After that we have to test our program with more difficult and bigger examples to see how our program behaves in more complicated situations. We now have to test with borderline cases and test for performance. Depending on the complexity of the current task, we do from 1-2 to dozens of tests to cover the main cases of usage.
With more complicated software, i.e. Microsoft Word, the number of tests can be thousands, even hundreds of thousands. If a program’s functionality is not carefully tested you can’t say that it works correctly. Testing during software development is as important as writing the code. In big software companies for every programmer there is a tester. For example in Microsoft for every programmer, who writes the code (software developer), there are two people hired to test the code (software quality assurance engineers). Although these people do not write the main software, they write testing software and therefore we call them software engineers.
Testing with Good Examples of the Common Cases
As we already mentioned, it is good to start testing with a good example of a common situation. This is a test, which is enough simple to be written down on a piece of paper and accurate enough to cover the usual usage of the program excluding special cases. The steps are as follows:
	Think up a test, which is a good example of a common situation.
	Test this example on a piece of paper.
	Expect the program to work correctly for that test.
	Be sure that the example works correctly after the program is written and the errors in the development process are fixed.
Sadly, many programmers end their testing at this moment. Some inexperienced programmers do something even worse: think up a stupid test case (which is a special case for the current program), don’t write it down, write some code and, after the program passes the example, they continue. Don’t do like this! This is like repairing a car and once you are finished, driving it downhill, thinking that the car is repaired (but the car has no power to drive uphill).
What Else to Test For?
Testing the case, drawn on a piece of paper, is only the first step. Next you need to do some additional tests to be sure that your program works correctly:
	A hard common-case test. The goal is to check whether your program can handle a bigger and harder to compute example. For our task that kind of a test is to shuffle a deck of 52 cards.
	Borderline tests. They check whether your program can handle an unusual case, which could happen. In our case this could be shuffling a deck, which contains only one card.
	Performance tests. These tests put our program in extreme conditions. Usually these tests consist of large data, which needs to be inputted and processed.
Let’s take a look at the groups of tests above one be one.
A Hard Common-Case Test
We have already tested our program for one case, which we have written down on a piece of paper. Our program works correctly. This case covers a typical scenario of usage of our program. What more do we have to test for? It is possible our program to be incorrect, but accidentally to work for our test.
How to think up a harder test? It depends on the task. It must consist of larger amounts of data and we must be able to see whether the output of our program is correct.
In our case we have to test with a full deck – 52 cards. We can easily produce such a test with two nested loops. After the execution of our program we could also easily check whether the answer is correct – the cards must be randomly shuffled. It is necessary to check whether the cards are again randomly shuffled after two consecutive executions of this test. The code for this test looks like this:
static void TestShuffle52Cards()
{
	List<Card> cards = new List<Card>();
	string[] allFaces = new string[] { "2", "3", "4", "5",
		"6", "7", "8", "9", "10", "J", "Q", "K", "A" };
	Suit[] allSuits = new Suit[] { Suit.CLUB, Suit.DIAMOND,
		Suit.HEART, Suit.SPADE };
	foreach (string face in allFaces)
	{
		foreach (Suit suit in allSuits)
		{
			Card card = new Card() { Face = face, Suit = suit };
			cards.Add(card);
		}
	}
	ShuffleCards(cards);
	PrintCards(cards);
}
If we execute it, the returned result is:
(4 DIAMOND)(2 DIAMOND)(6 HEART)(2 SPADE)(A SPADE)(7 SPADE)(3 DIAMOND)(3 SPADE)(4 SPADE)(4 HEART)(6 CLUB)(K HEART)(5 CLUB)(5 DIAMOND)(5 HEART)(A HEART)(9 CLUB)(10 CLUB)(A CLUB)(6 SPADE)(7 CLUB)(7 DIAMOND)(3 CLUB)(9 HEART)(8 CLUB)(3 HEART)(9 SPADE)(4 CLUB)(8 HEART)(9 DIAMOND)(5 SPADE)(8 DIAMOND)(J HEART)(10 DIAMOND)(10 HEART)(10 SPADE)(Q HEART)(2 CLUB)(J CLUB)(J SPADE)(Q CLUB)(7 HEART)(2 HEART)(Q SPADE)(K CLUB)(J DIAMOND)(6 DIAMOND)(K SPADE)(8 SPADE)(A DIAMOND)(Q DIAMOND)(K DIAMOND)
If we take a careful look we notice that most of the cards are at the same place. After the first 4 cards, the half of the cards didn’t change their place after the shuffle: 2¦ and 2¦.
It is never late to find a bug in our program and the only way we can do that is to test it with many tests, which cover practical situations. It was useful to test with a real deck of 52 cards, wasn’t it? We came upon a serious bug, which cannot be left unfixed.
How to fix the problem? The first idea, we come up with, is to do more single-swaps (obviously N times are not enough). Another idea is at the Nth single-swap to swap the Nth card from the deck with a random one instead of changing it with the first one. In this way we can guarantee that every card is going to be swapped. The second idea is better. Let’s implement it. We have the following changes in the code:
static void PerformSingleSwap(List<Card> cards, int index)
{
	int randomIndex = rand.Next(1, cards.Count);
	Card firstCard = cards[index];
	Card randomCard = cards[randomIndex];
	cards[index] = randomCard;
	cards[randomIndex] = firstCard;
}

static void ShuffleCards(List<Card> cards)
{
	for (int i = 0; i < cards.Count; i++)
	{
		PerformSingleSwap(cards, i);
	}
}
We execute the program and get a better shuffle of the deck of 52 cards:
(9 HEART)(5 CLUB)(3 CLUB)(7 SPADE)(6 CLUB)(5 SPADE)(6 HEART)(4 CLUB)(10 CLUB)(3 SPADE)(K DIAMOND)(10 HEART)(8 CLUB)(A CLUB)(J DIAMOND)(K SPADE)(9 SPADE)(7 CLUB)(10 DIAMOND)(9 DIAMOND)(8 HEART)(6 DIAMOND)(8 SPADE)(5 DIAMOND)(4 HEART)(10 SPADE)(J CLUB)(Q SPADE)(9 CLUB)(J HEART)(K CLUB)(2 HEART)(7 HEART)(A HEART)(3 DIAMOND)(K HEART)(A SPADE)(8 DIAMOND)(4 SPADE)(3 HEART)(5 HEART)(Q HEART)(4 DIAMOND)(2 SPADE)(A DIAMOND)(2 DIAMOND)(J SPADE)(7 DIAMOND)(Q DIAMOND)(2 CLUB)(6 SPADE)(Q
CLUB)
It looks like the cards are finally randomly ordered at every execution of our program. For now we don’t see any bugs (i.e. repeating or missing cards, or cards, which are at the same place). The program is fast and it doesn’t fall asleep. It looks like we have done well.
Let’s take a look at the other sample task: sorting numbers. What would be a serious common-case test? Easy for us would be to generate 100 or even 1000 random numbers and sort them. It is easy to check whether the final answer is correct: the numbers must be sorted by size. Another good test would be to enter the numbers from 1000 to 1 in descending order. The output must also consist of 1000 numbers, but sorted in ascending order. We could say that the hardest test is to check whether our program can handle many numbers – then we could say that our program probably works correctly.
Let’s take a look at some other types of tests, which we must consider when we solve programming problems.
Borderline Cases
The step, we often miss in problem solving, is testing for borderline cases. Borderline situations occur when the input data is on the border between a normal situation and a situation, which most likely will not happen. In this situation the program often crashes, because very large or very small amounts of data are not considered, although they are possible to be entered. This is clearly a programmer’s fault, because he has not thought that this could happen.
How to think up borderline cases? We analyze all of the data, which is being entered, to our program and think up such extreme values, which are possible to be entered. These values could be extremely small, extremely large or just strange. If it is said that the upper limit is 52 cards, the values around 52 are also borderlines and they could cause errors.
Borderline Case: Shuffling One Card
In our shuffling-cards problem a borderline case is to shuffle only one card. This case is absolutely valid (although it is quite unusual), but our program may not handle it correctly. Let’s take a look what could happen if we enter a deck of one card. We could write the following little test:
static void TestShuffleOneCard()
{
	List<Card> cards = new List<Card>();
	cards.Add(new Card() { Face = "A", Suit = Suit.CLUB });
	CardsShuffle.ShuffleCards(cards);
	CardsShuffle.PrintCards(cards);
}
We execute our program and get an unexpected result:
Unhandled Exception: System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection. Parameter name: index
	at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
	at System.ThrowHelper.ThrowArgumentOutOfRangeException()
	at System.Collections.Generic.List`1.get_Item(Int32 index)
	at CardsShuffle.PerformSingleSwap(List`1 cards, Int32 index) in D:\Projects\Cards\CardsShuffle.cs:line 61
…
The error occurred because the arguments passed to the method, which generates random numbers, were invalid. Our program can handle a normal deck of cards, but it can’t handle a deck of one card. We found an easy fix for this bug, which we could miss lightly, if we skipped checking the borderline cases. After we have established the nature of the problem, we can fix it:
static void ShuffleCards(List<Card> cards)
{
	if (cards.Count > 1)
	{
		for (int i = 0; i < cards.Count; i++)
		{
			PerformSingleSwap(cards, i);
		}
	}
}
We test again and we are sure that the bug is fixed.
Borderline Case: Shuffling Two Cards
After there is a problem with one card, there may be also a problem with two cards. It sounds logical, does it? It doesn’t bother us to test it. We run the program several times with only two cards to be shuffled and expect to get a different order on every run. Here is an example source code that will do the trick:
static void TestShuffleTwoCards()
{
	List<Card> cards = new List<Card>();
	cards.Add(new Card() { Face = "A", Suit = Suit.CLUB });
	cards.Add(new Card() { Face = "3", Suit = Suit.DIAMOND });
	CardsShuffle.ShuffleCards(cards);
	CardsShuffle.PrintCards(cards);
}
We run the program several times and the output is always the same:
(3 DIAMOND)(A CLUB)
It seems something is still not right. If we take a look at the source code or run the debugger we notice that two swaps are made: this first card with the second and immediately after that the second with the first one. The result is one and the same. How to solve this problem? Instantly we can think up a few solutions:
	We perform N+K single swaps, where K is a random number between 0 and 1.
	We assume that the random position can be also a zero position.
	We consider a deck of 2 cards as a special case and write a separate method to handle this case.
This second solution is the simplest to be implemented. Let’s try it. Here is the source code:
static void PerformSingleSwap(List<Card> cards, int index)
{
	int randomIndex = rand.Next(0, cards.Count);
	Card firstCard = cards[index];
	Card randomCard = cards[randomIndex];
	cards[index] = randomCard;
	cards[randomIndex] = firstCard;
}
We test again and it looks like the program works correctly: sometimes the cards are shuffled and sometimes not.
If there is a problem with 2 cards, there may be also a problem with 3 cards, right? If we do a test with 3 cards we see that it works flawlessly. After a few runs we get every possible order of the cards (all permutations of the cards). This time we did not find any bugs and we do not need to edit the code.
Borderline Case: Shuffling Zero Cards
What other tests do we need to do? Are there other unusual, borderline cases? Let’s think. What is going to happen if we shuffle an empty list of cards? This really is a bit strange, but a program must work correctly or it must properly alert for an error. Let’s look at result of our program. The result is an empty list. Is this correct? Yes, if we try to shuffle zero cards the answer should be again a deck of zero cards. Everything looks fine.
 	With the input of invalid data the program must not return an incorrect result. It must return a correct result or alert that the input data is wrong.
What do you think about the rule above? It is logical, right? Imagine a program, which displays images. What is going happen if we input an image, which is actually an empty file? This is an unusual situation, which should not happen, but it may happen. If with the input of an empty file the program crashes or throws an unprocessed exception, this would be annoying for the user. Normally, instead of an empty file, a special image should be displayed or an alert should pop-up, which contains that the image is invalid.
Think about how many borderline cases are there in Windows. What happens if we try to print an empty file? Does Windows crash or the "the blue screen of death" appears? What happens if in the Windows’ calculator we try divide by zero? What happens if we try to copy an empty file (with size of 0 bytes) using Windows Explorer? What happens if try to save a file without a name in Notepad (with an empty string as a name)? You see that there are many borderline cases. Our duty as programmers is to fix the bugs before the product is released on the market.
Let’s go back to the card-shuffling problem. Thinking about other borderline and unusual cases, we consider a case with -1 cards to be shuffled? Because we cannot initialize an array of -1 elements, we consider it as incorrect.
We don’t have an upper bound, so we don’t have any other special cases (similar to the case with 1 card). We stop searching for borderline cases having to do with the count of the cards. It looks like we considered all of the cases.
Now we only need to check whether there are such values of the input, which can cause errors – an invalid suit, a card with negative value (i.e. -1 club). Actually our algorithm does not care about what is being shuffled (cards or books), so this should not be a problem. If we have any doubts, we could do a test and be sure, that even with an invalid deck of cards, the answer is correct.
We look around for other borderline case in the input data, but we could not think up any. We only need to do a performance test, right? Actually we forgot to test our program again after the corrections.
Regression Testing
While fixing bugs, we often create new bugs without to notice. For example if we fix a bug for two cards with editing the method, responsible for the shuffling of the cards, a new bug with 3 cards may occur. On every edit of code, which concerns other cases, we must again do the same test, we have done earlier. That’s why it is a good idea to save the tests as methods (naming them with a prefix Test) and be able to run them again. Re-testing with the tests already passed in the past is called "regression testing". We may also use the unit testing framework that comes with Visual Studio (see Unit Testing section in the "High-Quality Code" chapter) to simplify re-running the tests after making changes in the code.
The idea of repeating the tests is implicit in the concept of unit testing. As we mentioned earlier, this concept is for more advanced programmers.
After the changes we need to try again shuffling 0 cards, 1 card, 2 cards, 3 cards and 52 cards.
 	When you have found and fixed in your code a bug, which concerns a specific test, make sure that no other bugs have been introduced after the code has been changed. It is a good idea to keep the tests saved for repeated execution.
Performance Tests
It is normal to have some performance requirements about a module or the program at all. No one likes his computer to be slow, right? That’s why you have to write software, which works slow only if there is a good reason.
How to check the speed (performance) of our program? We must firstly consider whether we have any performance requirements. Then what are they? If we don’t have any, we should use some conventional criteria.
Shuffling Cards – Performance Tests
Let’s take a look at our deck-shuffling program. What are the performance criteria? Do we have such? We don’t have any requirements like: "the program must compute the answer in less than a second with an upper bound of 500 cards on a modern computer". After we don’t have such explicit criteria, we should set our own.
Because the data is a set of cards, we consider testing with a normal deck of 52 cards. We already ran such a test and the answer was output immediately. It looks like our program works fast in normal conditions.
It is normal to test also with a deck of many more cards (i.e. 52,000). In a very particular situation someone might like to shuffle a deck of 52,000 cards and we could not allow our program to crash at this later phase. We can easily create such a test by adding 1000 times our 52 cards. Here is some example code:
static void TestShuffle52000Cards()
{
	List<Card> cards = new List<Card>();
	string[] allFaces = new string[] {"2", "3", "4", "5",
		"6", "7", "8", "9", "10", "J", "Q", "K", "A"};
	Suit[] allSuits = new Suit[] { Suit.CLUB, Suit.DIAMOND,
		Suit.HEART, Suit.SPADE};
	for (int i = 0; i < 1000; i++)
	{
		foreach (string face in allFaces)
		{
			foreach (Suit suit in allSuits)
			{
				Card card = new Card() { Face = face, Suit = suit };
				cards.Add(card);
			}
		}
	}
	ShuffleCards(cards);
	PrintCards(cards);
}
We start the program and notice that it works without stopping for 5-10 seconds. Of course with slower computers it is going to take more time. What is happening? The count of the operations with a deck of 52,000 cards is almost the same as with a deck of 52 cards for example. Why is the program so slow? Advanced programmers will immediately guess that the delay is because we output big amounts of data and printing to the console is a slow operation. If we comment the line, where the printing is done, as a comment, we will see how fast our program is, even with a deck of 52,000 cards. Here’s how we can count the time:
static void TestShuffle52000Cards()
{
	…
	DateTime oldTime = DateTime.Now;
	ShuffleCards(cards);
	DateTime newTime = DateTime.Now;
	Console.WriteLine("Execution time: {0}", newTime - oldTime);
	//PrintCards(cards);
}
We can check how long it takes for the method, responsible for the shuffling of the cards, to be executed:
Execution time: 00:00:00.0156250
One millisecond is absolutely acceptable. We don’t have any performance problems.
Sorting Numbers – Performance Tests
Let’s take a look at another one of our problems: sorting an array of numbers. Here performance might be a problem. We have thought up a simple solution: our algorithm finds the lowest number in the array and swaps it with the number at position 0. Then it finds the next lowest number and sets it at position 1. The algorithm continues until we reach the last position. We will not comment the correctness of the algorithm. It is well known as "Selection sort" (http://en.wikipedia.org/wiki/Selection_sort).
Let’s suppose that we have passed all the steps for solving a programming problem, except the last one. Therefore we will try to sort 10,000 random numbers:
Sort10000Numbers.cs
using System;

public class Sort10000Numbers
{
	static void Main()
	{
		int[] numbers = new int[10000];
		Random rnd = new Random();
		for (int i = 0; i < numbers.Length; i++)
		{
			numbers[i] = rnd.Next(2 * numbers.Length);
		}
		SortNumbers(numbers);
		PrintNumbers(numbers);
	}

	static void SortNumbers(int[] numbers)
	{
		for (int i = 0; i < numbers.Length - 1; i++)
		{
			int minIndex = i;
			for (int j = i + 1; j < numbers.Length; j++)
			{
				if (numbers[j] < numbers[minIndex])
				{
					minIndex = j;
				}
			}

			int oldNumber = numbers[i];
			numbers[i] = numbers[minIndex];
			numbers[minIndex] = oldNumber;
		}
	}

	static void PrintNumbers(int[] numbers)
	{
		Console.Write("[");
		for (int i = 0; i < numbers.Length; i++)
		{
			Console.Write(numbers[i]);
			if (i < numbers.Length - 1)
			{
				Console.Write(", ");
			}
		}
		Console.WriteLine("]");
	}
}
We run our program and it looks like it finishes in less than a second on a typical modern computer. The shortened result would be something like that:
[0, 14, 19, 20, 20, 22, …, 19990, 19993, 19995, 19996]
We do another test, this time with an array of 300,000 random numbers, and notice that our program falls asleep or it is just too slow. This is a serious performance problem.
Before we start fixing it, we must ask ourselves: is this a real situation. If we sort students’ marks, the elements will not be more than a couple of dozens. However if we sort the stocks’ currencies of a large software company for its being on the stock market, we have a lot of numbers to be sorted. This is because the price of the stocks can change every second. In about ten years the price can change hundreds of thousands times of times. In this case we should look for a better sorting algorithm.
We can easily find information about sorting algorithms in many websites and books. In our case, it is most appropriate to use the non-comparative integer sorting algorithm "radix sort" (en.wikipedia.org/wiki/Radix_sort) which runs in linear time, but this discussion is beyond the objectives of this book.
Let’s recall the efficiency rule:
 	You must always make a compromise between the time, spent on writing the program, and the performance, which we want to achieve. Otherwise you might lose your time for solving a problem, that doesn’t exist, or come up with a solution, which is inefficient.
We must consider that for some problems there aren’t any fast algorithms. For example there aren’t any fast solutions for finding all prime dividers of an integer (take a look at http://en.wikipedia.org/wiki/Integer_factorization).
In some situations the input data is too small and we don’t need a fast algorithm to process it. For example: sorting the students’ marks. It can be solved with every sorting algorithm, because the count of the students is small.
General Conclusions
Before you have started reading this chapter, you have probably thought that it is going to be boring. We believe that you think of this chapter in a different way now. Many people think that they can solve programming problems and that there is no recommended approach (you just have to do it). Unfortunately, there are lots of approaches for solving problems. We did not only tell you how, we showed you how! We convinced you that our approach can give good results, right?
Just think how many bugs we found while we were solving quite an easy problem: shuffling a deck of cards. Would we have written an efficient solution, if we had not considered the steps above? And what will happen if we try to solve a more difficult problem, i.e. finding the optimal path through the traffic jams in New York with a map and current statistics given? It’s absolutely insane to try the first idea you come up with without considering many more. The first step in acquiring programming-problem-solving techniques is to learn to approach the problem systematically and to acquire the recipe for problem solving, we demonstrated earlier. Of course, this is not enough, but it is a crucial step!
 	There is a recipe for programming-problem solving! Use a systematical approach for better results, instead of your sense. Even professionals, with more than 10 years of experience, use the approach described in this chapter. Use it yourself and you will be convinced that it works! Don’t forget to test your solution seriously and deeply.
Finally we want to take a note on the cards shuffle algorithm. The "cards shuffling" is well-known problem in computer science and there are classic algorithms for solving it like the "Fisher-Yates Shuffle". Read more in Wikipedia: http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle.
Exercises
	Using the described in this chapter methodology of solving programming problems, solve this problem: In a plane N points are given (N < 100,000). The coordinates of the points are integers (xi, yi). Write a program, which finds all horizontal and vertical lines, such that they split the plane into two parts, each containing an equal set of points (points lying on the line are note counted).
	Using the described in this chapter methodology of solving programming problems, solve this problem: A set S of n integers and a positive integer k (k ? n ? 10) are given. An alternating sequence is a sequence, which changes its behavior from ascending to descending and vice versa after every element. Write a program, which generates all possible sequences s1, s2, …, sk containing k different elements from S.
Example: S = { 2, 5, 3, 4 }, K = 3: {2, 4, 3}, {2, 5, 3}, {2, 5, 4}, {3, 2, 4}, {3, 2, 5}, {3, 4, 2}, {3, 5, 2}, {3, 5, 4}, {4, 2, 3}, {4, 2, 5}, {4, 3, 5}, {4, 5, 2}, {4, 5, 3}, {5, 2, 3}, {5, 2, 4}, {5, 3, 4}.
	Using the described methodology of creating solutions to programming problems, solve the following problem: a map of a city is given. At this map there are given roads and crossroads. For every road a length is given. One crossroad can connect a couple of roads. Your program must find the shortest path from one crossroad to another (the shortest path is measured as the sum of the lengths of all includes roads).
A sample map is given below. At this map the shortest path between the crossings A and D has length of 70 and it is shown on the figure with bold lines. As you can see, this is not the only path from A to D: there are more paths with different lengths. Note that not always the first shortest road considered as current next node leads to finding the shortest path, neither does the lowest count of roads. Between some crossings there may not even be a road. This creates a very interesting problem.
 
The input data is contained in the file map.txt. A list of the roads and their length are given first, followed by a blank line and the pairs of crossroads, between which we need to find the shortest path. At the end of the file a blank line is given. Crossroads are denoted by a single letter of sequence of letters. Here is a sample input file:
A B 20
A H 30
B H 5
…
L M 5
(blank line)
A D
H K
A E
(blank line)
The result from the execution of your program should be printed on the console in the following format: for every pair of crossroads from the input file, the shortest path length should be printed, followed by the path itself. For the map above the output will look like this:
70 ABJCFD
No path!
35 ABHE
	* In a plane N points are given with integer positive coordinates. These points represent trees in a field. The gardener wants to enclose all trees using a minimum amount of fence. Write a program, which finds the appropriate points, through which the fence goes. Use the methodology of solving programming problems!
For example the garden may look like this:
 
The input data is read from the text file garden.txt. On the first line we are given N – the number of points is given. Next we are given N pairs – the coordinates of the points. For our example garden the file contains the following data:
13
60 50
100 30
40 40
20 70
50 20
30 70
10 10
110 70
90 60
80 20
70 80
20 20
30 60
The output data must be printed to the console as a sequence of points, through which the fence goes. Here is an output example:
(10, 10) - (20, 70) - (70, 80) - (110, 70) - (100, 30) - (80, 20) - (10, 10)
Solutions and Guidelines
	First find a sheet of paper, on which you can draw the coordinate system and the points. In this way you can easily think up a solution and consider some tests. Consider different solutions and compare them in terms of quality, performance and time needed to be implemented. Hint: you may sort the points by X or Y and find the lines with a linear scan.
	Again take a pencil and a sheet. Write down many examples and consider them. What ideas do you come up with? Do you need more examples? Think over your ideas, write them down on a sheet of paper, if you are sure they are correct – implement them. Think for examples that your program may not handle. It is always a good idea to think up specific examples and then to implement them. Think how your solution will work with different values of K and different values and count of elements in S.
	Use the described methodology for creating solutions to programming problems! The problem is difficult and you will have to spend more time on it. First draw the map on a sheet of paper. Try to think up a correct algorithm for finding the shortest path yourself. Then search for "shortest path algorithm" in the Internet. Most likely you will be able to find some article about the problem quickly.
Check whether the algorithm is correct. Test with different cases.
In what data structure are you going to keep the map of the city? Think about which are the operations your algorithm is going to use. Probably you will come up with idea to keep a list of the roads for every crossroad and the crossroads in a hash table.
Think about the performance. Will your algorithm handle 1,000 crossings and 5,000 roads fast enough?
Write the code step by step. First write the method, which reads the input file. In this case the data is entered from a file and therefore you can consider it as your first step. If the data was entered from the console, we would have to leave it as our last step. Then implement the algorithm for finding the minimum path length. If you can, break up the implementation into smaller steps. For example you could firstly find the length of the minimal path without the path itself, because it is easier. Then implement the finding of the shortest path itself (as a list of crossroads). Think what could happen if there are several shortest paths. Finally implement the output of the result.
Test your solution! Test with an empty map. Test with a map with one crossroad. Test with an example, in which there are no roads between the crossroads. Test with a big map (1,000 crossings and 5,000 roads). You can generate such a case with a small program. For the names of the crossroads you have to use string instead of char, right? If you use char, it will not be possible to have 1,000 crossings? Is your solution fast? Does it work correctly?
Be careful with the input and output data formats. Comply with the described format requirements in the problem statement!
	If you are not very good with analytic geometry, you may not come up with a correct solution by yourself. Search in the Internet for "convex hull algorithm". Knowing that the fence is called a "convex hull" of a set of points in the plane, you will be able to find hundreds of articles – even some with source code in C#. Don’t copy others’ mistakes, especially the source code! Think! Study how the algorithm works.
Check whether the algorithm is correct. Test with different examples (firstly on a sheet of paper). What could happen if there are a couple of points, lying on a line in the plane? Do you need to include all of them? Think what could happen if there is a couple of convex hulls. From which point will the hull start? Will you move clockwise or counterclockwise? Is there a requirement in the description of the task how must the points be ordered? What if some of the points are the same? What should happen if we have no points or just one point in the field?
In what data structure will you keep the points? In what data structure will you keep the convex hull?
Think about the performance. Will your algorithm work for 1,000 points?
Write your program step by step. First implement the reading of the input data. Implement your convex hull finding algorithm. If it is possible, break your algorithm into smaller parts. Finally implement the output of the result in the described format.
Test your solution! What will happen if we have 0 points? Try with 1 point. Try with 2 points. Try with 5 point, which lie on a line. Does your algorithm work? What will happen if we have 10 points and another 10, which match the first 10? What will happen if we have 10 points, which lie one over another? What will happen if you have many points, i.e. 1,000? Does your algorithm work fast? What will happen if the coordinates of the points are large numbers (100,000,000; 200,000,000)? Does this affect your algorithm? Can you face precision errors in the calculations?
Be careful with the input and output data. Consider the format in the ďđîáëĺě description! Do not invent your own format of the input and output data. The formats are defined and they must be respected.
If you want, you could implement visualization of the points and the convex hull using Windows Forms or in WPF. You may implement a generator of random tests and test your solution many times by observing the visualization of the hull – does it really wrap the points.


Chapter 24. Sample Programming Exam – Topic #1

In This Chapter
In this chapter we will look at and offer solutions to three problems from a sample programming exam. While solving them we will put into practice the methodology described in the chapter "Methodology of Problem Solving".
Problem 1: Extract Text from HTML Document
We are given HTML file named Problem1.html. Write a program, which removes all HTML tags and retains only the text inside them. Output should be written into the file Problem1.txt.
Sample input file for Problem1.html:
<html>
<head><title>Welcome to our site!</title></head>
<body>
<center>
<img src="/en/img/logo.gif" width="130" height="70" alt="Logo">
<br><br><br>
<font size="-1"><a href="/index.html">Home</a>
<a href="/contacts.html">Contacts</a>
<a href="/about.html">About</a></font><p>
</center>
</body>
</html>
Sample output file for Problem1.txt:
Welcome to our site!
Home
Contacts
About
Inventing an Idea
The first thing that occurs to us as an idea for solving this problem is to read sequentially (e.g. line by line) the input file and to remove any tags. It is easily seen that all tags starting with the character "<" and end with the character ">". This also applies to opening and closing tags. This means that for each line in the file we should remove all substrings starting with "<" and ending with ">".
Checking the Idea
We have an idea for solving the problem. Whether the idea is correct? First we should check it. We can ensure it is correct for the sample input file, and then consider whether there are specific cases where the idea could be incorrect.
We take a pen and paper and check by manually whether the idea is correct. We do this by striking out all text substrings that start with the character "<" and end with the character ">". As we do so, we see that there is only pure text and any tags disappear:
<html>
<head><title>Welcome to our site!</title></head>
<body>
<center>
<img src="/en/img/logo.gif" width="130" height="70" alt="Logo">
<br><br><br>
<font size="-1"><a href="/index.html">Home</a>
<a href="/contacts.html">Contacts</a>
<a href="/about.html">About</a></font><p>
</center>
</body>
</html>
Now we have to think of some more special cases. We do not want to write 200 lines of code and only then think about special case, finding out we have to redesign the entire program. It is important to check the problematic situations now, before we begin writing the code of the solution. We can think of the following special example:
<html><body>
Click<a href="info.html">on this
link</a>for more info.<br />
This is<b>bold</b>text.
</body></html>
There are two things to consider:
	There are tags containing text that open and close at separate lines. Such tags in our example are <html>, <body> and <a>.
	There are tags that contain text and other tags in themselves (nested tags). For example <body> and <html>.
What should be the result of this example? If we directly remove all tags we will get something like this:
Clickon this
linkfor more info.
This isboldtext.
Or maybe we should follow the rules of the HTML language and get the following result:
Click on this link for more info.
This is bold text.
There are other options, such as putting each piece of text, which is not a tag, on a new line:
Click
on this
link
for more info.
This is
bold
text.
If we remove all the text in tags and snap the other text, we will get words that are stuck together. From the task’s description it is not clear if this is the requested result or it must be as in the HTML language. In the HTML language each series of separators (spaces, new lines, tabs, etc.) appear as a space. However, this was not mentioned in the task’s description it is not clear from the sample input and output.
It is not clear yet whether to print the words that are in a tag which holds other tags or to skip them. If we print only the contents of the tags, which consist of text only, we will get something like this:
on this
link
bold
It is yet not clear from the description, how to display the text that is located on a few lines inside a tag.
Clarification of the Statement of the Problem
The first thing to do when we find ambiguity in the description of the task is to read it carefully. In this case the problem statement is not really clear and does not give us the answers. Probably we should not follow the HTML rules, because they are not described in the problem statement, but it is not clear whether to connect the words in neighboring tags or separate them by a space or new line.
This leaves us only one thing – to ask. If we have an exam, we will ask the one who gives us the task. In real life, someone is an owner of the software we develop, and he could answer the questions. If nobody can give an answer, choose one option that seems most correct under the information we have and act on it. Assume that we need to print text, which remains after removing all opening and closing tags, using a blank line separator at the positions of the tags. If there are blank lines in the text, we keep them. For our example, we should obtain the following correct output:
Click
on this
link
for more info.
This is
bold
text.
A New Idea for Solving the Problem
So, after adapting these new requirements, the following idea comes: read file line by line and substitute each tag with a new line. To avoid duplication of new lines in the resulting file, replace every two consecutive lines of new results with a new line.
We check the new idea with the example from the original statement of the problem with our example to ensure it is correct. It remains to implement it.
Break a Task into Subtasks
The task can easily break into 3 subtasks:
	Read the input file.
	Processing of a line of input file: replace tags with a new line.
	Print results in the output file.
What Data Structures to Use?
In this task we must perform simple word processing and file management. The question of what data structures to use is not a problem – for word processing we use string and if necessary – StringBuilder.
Consider the Efficiency
If we read the lines one by one, it will not be a slow operation. Processing of one line can be done by replacing some characters with others – a quick operation. We should not have performance problems.
A possible problem could be the clearing of the empty lines. If we collect all lines in a buffer (StringBuilder) and then remove double blank lines, this buffer will occupy too much memory for large input files (for example 500 MB input file).
To save memory, we will try to clean the excess blank lines just after the replacement tags with the white space character.
Now we examined the idea of solving the task, we ensured that it is good and covers the special cases that may arise, and believe we will have no performance issues.
Now we can safely proceed to implementation of the algorithm. We will write the code step by step to find errors as early as possible.
Step 1 – Read the Input File
The first step solving the given task is reading the input file. In our case it is a HTML file. This should not bother us, because HTML is a text format. Therefore, to read it, we will use the StreamReader class. We will traverse the input file line by line and each line we will derive (for now it is not important how we will do it) all the information we need (if any) and save it into an object of type StringBuilder. Extraction we will implement in the next step (step 2). Let’s write the necessary code for the implementation of our first step:
string line = string.Empty;
StreamReader reader = new StreamReader("Problem1.html");

while ((line = reader.ReadLine()) != null)
{
	// Find what we need and save it in the result
}

reader.Close();
With this code we will read the input file line by line. Let’s think whether we have completed a good first step. Do you know what we have missed?
From the code written we will read the input file, but only if it exists. What if the input file does not exist or could not be opened for some reason? Our present decision does not deal with these problems. There is another problem in our code too: if an error occurs while reading or processing the data file, it will not be closed.
With File.Exists(…) we will check if the input file exists. If not – we will display an appropriate message and stop program execution. To avoid the second problem we will use the try-catch-finally statement (we may use the using statement in C# as well). Thus, if an exception arises, we will process it and will always close the file, which we worked with. We must not forget that the object of the StreamReader class must be declared outside the try block, otherwise it will be unavailable in the finally block. This is not a fatal error, but often made by novice programmers.
It is better to define the input file name as a constant, because we probably will use it in several places.
Another thing: when reading from a text file it is appropriate to specify explicitly the character encoding. Let’s see what we get:
using System;
using System.IO;
using System.Text;

class HtmlTagRemover
{
	private const string InputFileName = "Problem1.html";
	private const string Charset = "windows-1251";

	static void Main()
	{
		if (!File.Exists(InputFileName))
		{
			Console.WriteLine(
				"File " + InputFileName + " not found.");
			return;
		}

		StreamReader reader = null;
		try
		{
			Encoding encoding = Encoding.GetEncoding(Charset);
			reader = new StreamReader(InputFileName, encoding);
			string line;
			while ((line = reader.ReadLine()) != null)
			{
				// Find what we need and save it in the result
			}
		}
		catch (IOException)
		{
			Console.WriteLine(
				"Can not read file " + InputFileName + ".");
		}
		finally
		{
			if (reader != null)
			{
				reader.Close();
			}
		}
	}
}
Test the Input File Reading Code
We handled the described problems and it seems we have implemented the reading of the input file. We wrote a lot of code. To be convinced that it is correct, we can test our unfinished code. For example let’s print the content of the input file to the console, and then try processing nonexistent files. The writing will be done in a while loop using Console.WriteLine(…):
…
while ((line = reader.ReadLine()) != null)
{
	Console.WriteLine(line);
}
…
If we test the piece of code we have with the Problem1.html sample file from the problem description, the result is correct – the input file itself:
<html>
<head>
<title>Welcome to our site!</title>
</head>
<body>
<center>
<img src="/en/img/logo.gif" width="130" height="70" alt="Logo">
<br><br><br>
<font size="-1"><a href="/index.html">Home</a> -
<a href="/contenst.html">Contacts</a> -
<a href="/about.html">About</a></font><p>
</center>
</body>
</html>
Let’s try a nonexistent file. We change the file name Problem1.html with Problem2.html. The result is the following:
File Problem2.html not found
We are convinced that the code till now is correct. Let’s move to the next step of the implementation of our idea (algorithm).
Step 2 – Remove the Tags
Now we want to find a suitable way to remove all tags. How should we do this?
One possible way is to check the line character by character. For each character in the current row we will look for the character "<". On the right side of it we will know that we have a tag (opening or closing). The end tag character is ">". So we can find tags and remove them. To not get the words connected between adjacent tags, each tag will be replaced with the character for a blank line "\n".
The algorithm is simple to implement, but isn’t there a more clever way? Can we use regular expressions? They can easily look for tags and replace them with "\n", right? In the same time the code will be simple and in case of errors, they will be removed more easily. We will consider this option. What should we do? First we need to write a regular expression. Here is how it may look:
<[^>]*>
The idea is simple: any string, that starts with "<", continues with arbitrary sequence of characters, other than ">" and ends with ">" is an HTML tag. Here’s how we can replace the tags with a new line:
private static string RemoveAllTags(string str)
{
	string textWithoutTags = Regex.Replace(str, "<[^>]*>", "\n");
	return textWithoutTags;
}
After coding this step, we should test it. For this purpose again we print to the console the strings we found via Console.WriteLine(…). And test the code:
HtmlTagRemover.cs
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

class HtmlTagRemover
{
	private const string InputFileName = "Problem1.html";
	private const string Charset = "windows-1251";

	static void Main()
	{
		if (!File.Exists(InputFileName))
		{
			Console.WriteLine(
				"File " + InputFileName + " not found.");
			return;
		}

		StreamReader reader = null;
		try
		{
			Encoding encoding = Encoding.GetEncoding(Charset);
			reader = new StreamReader(InputFileName, encoding);
			string line;
			while ((line = reader.ReadLine()) != null)
			{
				line = RemoveAllTags(line);
				Console.WriteLine(line);
			}
		}
		catch (IOException)
		{
			Console.WriteLine(
				"Can not read file " + InputFileName + ".");
		}
		finally
		{
			if (reader != null)
			{
				reader.Close();
			}
		}
	}

	private static string RemoveAllTags(string str)
	{
		string strWithoutTags =
			Regex.Replace(str, "<[^>]*>", "\n");
		return strWithoutTags;
	}
}
Testing the Tag Removal Code
Let’s test the program with the following input file:
<html><body>
Click<a href="info.html">on this
link</a>for more info.<br />
This is<b>bold</b>text.
</body></html>
The result is as follows:
(empty rows)
Click
on this
link
for more info.
(empty row)
This is
bold
text.
(empty rows)
Everything works perfectly, only that we have extra blank lines. Can we remove them? This will be our next step.
Step 3 – Remove the Empty Lines
We can remove unnecessary blank lines, replacing a double blank line "\n\n" with a single blank line "\n". We should not have groups of more than one character for a new line "\n". Here is an example how we can perform the substitution:
private static string RemoveDoubleNewLines(string str)
{
	return str.Replace("\n\n", "\n");
}
Testing the Empty Lines Removal Code
As always, before we move forward, we test whether the method works correctly. We try a text, which has no blank rows, and then add 2, 3, 4 and 5 blank lines, including at the beginning and at the end of text.
We find that the above method does not work correctly, when there are 4 blank lines one after another. For example, if we submit as input "ab\n\n\n\ncd", we will get "ab\n\n\cd" instead of "ab\ncd". This defect occurs because the Replace(…) finds and replaces a single match, scanning the text from left to right. If in result of a substitution the searched string reappears, it is skipped.
See how useful it is when each method is tested on time. We do not end up wondering why the program does not work when we have 200 lines of code, full of errors. Early detection of defects is very useful and we should do it whenever possible. Here is the corrected code:
private static string RemoveDoubleNewLines(string str)
{
	string pattern = "[\n]+";
	return Regex.Replace(str, pattern, "\n");
}
The above code uses a regular expression to find any sequence of \n characters and replaces it with a single \n.
After a series of tests, we are convinced that the method works correctly. We are ready to test the program that removes all unnecessary newlines. For this purpose we make the following changes:
while ((line = reader.ReadLine()) != null)
{
	line = RemoveAllTags(line);
	line = RemoveDoubleNewLines(line);
	Console.WriteLine(line);
}
We test the code again. Still it seems there are blank lines. Where do they come from? Perhaps, if we have a line that contains only tags, it will cause a problem. Therefore we may prevent this case. We add the following checks:
if (!string.IsNullOrEmpty(line))
{
	Console.WriteLine(line);
}
This removes most of the blank lines, but not all.
Remove the Empty Lines: Second Attempt
If we think more, it could happen so, that a line begins or ends with a tag. Then this tag will be replaced with a single blank line and so at the beginning or at the end of the line we may get a blank line. This means that we should clean the empty rows at the beginning and at the end of each line. Here’s how we can make the cleaning:
private static string TrimNewLines(string str)
{
	int start = 0;
	while (start < str.Length && str[start] == '\n')
	{
		start++;
	}

	int end = str.Length - 1;
	while (end >= 0 && str[end] == '\n')
	{
		end--;
	}

	if (start > end)
	{
		return string.Empty;
	}

	string trimmed = str.Substring(start, end - start + 1);
	return trimmed;
}
The method works very simply: goes from left to right and skips all newline characters. Then passes from right to left and skips again all newline characters. If the left and right positions have passed each other, this means that the string is either empty or contains only newlines. Then the method returns an empty string. Otherwise it returns back everything to the right of the start position and to the left of the end position.
Remove the Empty Lines: Test Again
As always, we test whether the above method works correctly with several examples, including an empty string, no string breaks, string breaks left or right or both sides and a string with new lines. We make sure, that the method now works correctly.
Now we have to modify the logic of processing the input file:
while ((line = reader.ReadLine()) != null)
{
	line = RemoveAllTags(line);
	line = RemoveDoubleNewLines(line);
	line = TrimNewLines(line);
	if (!string.IsNullOrEmpty(line))
	{
		Console.WriteLine(line);
	}
}
Step 4 – Print Results in a File
It remains to print the results in the output file. To print the results in the output file we will use the StreamWriter. This step is trivial. We must only consider that writing to a file can cause an exception and that’s why we need to change the logic for error handling slightly, opening and closing the flow of input and output to the file.
Here is what we finally get as a complete source code of the program:
HtmlTagRemover.cs
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

class HtmlTagRemover
{
	private const string InputFileName = "Problem1.html";
	private const string OutputFileName = "Problem1.txt";
	private const string Charset = "windows-1251";

	static void Main()
	{
		if (!File.Exists(InputFileName))
		{
			Console.WriteLine(
				"File " + InputFileName + " not found.");
			return;
		}

		StreamReader reader = null;
		StreamWriter writer = null;
		try
		{
			Encoding encoding = Encoding.GetEncoding(Charset);
			reader = new StreamReader(InputFileName, encoding);
			writer = new StreamWriter(OutputFileName, false,
				encoding);

			string line;
			while ((line = reader.ReadLine()) != null)
			{
				line = RemoveAllTags(line);
				line = RemoveDoubleNewLines(line);
				line = TrimNewLines(line);
				if (!string.IsNullOrEmpty(line))
				{
					writer.WriteLine(line);
				}
			}
		}
		catch (IOException)
		{
			Console.WriteLine(
				"Can not read file " + InputFileName + ".");
		}
		finally
		{
			if (reader != null)
			{
				reader.Close();
			}

			if (writer != null)
			{
				writer.Close();
			}
		}
	}

	/// <summary>
	/// Replaces every tag with new line
	/// </summary>
	private static string RemoveAllTags(string str)
	{
		string strWithoutTags =
			Regex.Replace(str, "<[^>]*>", "\n");
		return strWithoutTags;
	}

	/// <summary>
	/// Replaces sequence of new lines with only one new line
	/// </summary>
	private static string RemoveDoubleNewLines(string str)
	{
		string pattern = "[\n]+";
		return Regex.Replace(str, pattern, "\n");
	}

	/// <summary>
	/// Removes new lines from start and end of string
	/// </summary>
	private static string TrimNewLines(string str)
	{
		int start = 0;
		while (start < str.Length && str[start] == '\n')
		{
			start++;
		}

		int end = str.Length - 1;
		while (end >= 0 && str[end] == '\n')
		{
			end--;
		}

		if (start > end)
		{
			return string.Empty;
		}

		string trimmed = str.Substring(start, end - start + 1);
		return trimmed;
	}
}
Testing the Solution
Until now, we were testing the individual steps for the solution of the task. Through the tests of individual steps we reduced the possibility of errors, but that does not mean that we should not test the whole solution. We may have missed something, right? Now let’s thoroughly test the code.
	Test with the sample input file from the problem statement. Everything works correctly.
	Test our "complex" example. Everything works fine.
	Test the border cases and run an output test.
	We test with a blank file. Output is correct – an empty file.
	Test with a file that contains only one word "Hello" and does not contain tags. The result is correct – the output contains only the word "Hello".
	Test with a file that contains only tags and no text. The result is again correct – an empty file.
	Try to put blank lines of at the most amazing places in the input file. These empty lines should all be removed. For example we can run the following test:
  Hello

<br><br>


<b>I<b> am here

I am not <b>here</b>
The result is as follows:
  Hello
I
 am here
I am not
Here
It seems we found a small defect. There is a space at the beginning of some of the lines.
Fixing the Leading Spaces Defect
Under the problem description it is not clear whether this is a defect but let’s try to fix it. We could add the following code when processing the next line of the input file:
line = line.Trim();
The defect is fixed, but only from the first line. We run the debugger and we notice why it is so. The reason is that we print into the output file a string of characters with value "I\n am here" and so we get a space after a blank line. We can correct the defect, by replacing all blank lines, followed by white space (blank lines, spaces, tabs, etc.) with a single blank line. Here is the correction:
private static string RemoveDoubleNewLines(string str)
{
	string pattern = "\n\\s+";
	return Regex.Replace(str, pattern, "\n");
}
We fixed that error too. Now we have only to change this name to a more appropriate one, for example RemoveNewLinesWithWhiteSpace(…).
Now we need to test again after the "fixes" in the code (regression test). We put new lines and spaces scattered randomly and make sure that everything works correctly now.
Performance Test
One last test remains: performance. We can create easily create a large input file. We open a site, for example http://www.microsoft.com, grab the source code and copy it 1000 times. We get a large enough input file. In our case, we get a 44 MB file with 947,000 lines. Processing it takes under 10 seconds, which is a perfectly acceptable speed. When we test the solution we should not forget that the processing of the file depends on our hardware (our test was performed in 2009 on an average fast laptop).
Taking a look at the result, however, we notice a very troublesome problem. There are parts of a tag. More precisely, we see the following:
<!--
var s_pageName="home page"
//-->
It quickly becomes clear that we missed a very interesting case. In an HTML tag can be closed few lines after its opening, e.g. a single tag may span several consecutive lines. That was exactly our case: we have a comment tag that contains JavaScript code. If the program worked correctly, it would have cut the entire tag rather than keep it in the source file.
Did you see how testing is useful and how testing is important? In some big companies (like Microsoft) having a solution without tests is considered as only 50% of the work. This means that if you write code for 2 hours, you should spend on testing (manual or automated) at least 2 more hours! This is the only way to create high-quality software.
What a pity that we discovered the problem just now, instead of at the beginning, when we were checking whether our idea for the task is correct, before we wrote the program. Sometimes it happens, unfortunately.
How to Fix the Problem with the Tag at Two Lines?
The first idea that occurs to us is to load in memory the entire input file and process it as one big string rather than row by row. This is an idea that seems to work but will run slow and consume large amounts of memory. Let’s look for another idea.
A New Idea: Processing the Text Char by Char
Obviously we cannot read the file line by line. Can we read it character by character? If yes, how we will treat tags? It occurs to us that if we read the file character by character, we can know at any moment, whether we are in or outside of a tag, and if we are outside the tag, we can print everything that we read (followed by a new line). We need to avoid adding new lines, as well as and trailing whitespace. We will get something like this:
bool inTag = false;
while (! <end of file is reached>)
{
	char ch = (read the next character);
	if (ch == '<')
	{
		inTag = true;
	}
	else if (ch == '>')
	{
		inTag = false;
	}
	else
	{
		if (!inTag)
		{
			PrintBuffer(ch);
		}
	}
}
Implementing the New Idea
The idea is very simple and easy to implement. If we implement it directly, we will have a problem with empty lines and the problem of merging text from adjacent tags. To solve this problem, we can accumulate the text in the StringBuilder and print it at the end of file or when switching from text to a tag. We will get something like this:
bool inTag = false;
StringBuilder buffer = new StringBuilder();
while (! <end of file is reached>)
{
	char ch = (read the next character);
	if (ch == '<')
	{
		if (!inTag)
		{
			PrintBuffer(buffer);
		}
		buffer.Clear();
		inTag = true;
	}
	else if (ch == '>')
	{
		inTag = false;
	}
	else
	{
		if (!inTag)
		{
			buffer.Append(ch);
		}
	}
}
PrintBuffer(buffer);
The missing PrintBuffer(…) method should clean the whitespace from the text in the buffer and print it in the output followed by a new line. Exception is when we have whitespace only in the buffer (it should not be printed).
We already have most of the code, so step-by-step implementation mat not be necessary. We can just replace the pieces of wrong old code with the new code implementing the new idea. If we add the logic for avoiding empty lines as well as reading input and writing the result we obtain is a complete solution to the task with the new algorithm:
SimpleHtmlTagRemover.cs
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

public class SimpleHtmlTagRemover
{
	private const string InputFileName = "Problem1.html";
	private const string OutputFileName = "Problem1.txt";
	private const string Charset = "windows-1251";
	private static Regex regexWhitespace = new Regex("\n\\s+");

	static void Main()
	{
		if (!File.Exists(InputFileName))
		{
			Console.WriteLine(
				"File " + InputFileName + " not found.");
			return;
		}

		StreamReader reader = null;
		StreamWriter writer = null;
		try
		{
			Encoding encoding = Encoding.GetEncoding(Charset);
			reader = new StreamReader(InputFileName, encoding);
			writer = new StreamWriter(OutputFileName, false,
				encoding);
			RemoveHtmlTags(reader, writer);
		}
		catch (IOException)
		{
			Console.WriteLine(
				"Cannot read file " + InputFileName + ".");
		}
		finally
		{
			if (reader != null)
			{
				reader.Close();
			}
			if (writer != null)
			{
				writer.Close();
			}
		}
	}

	/// <summary>Removes the tags from a HTML text</summary>
	/// <param name="reader">Input text</param>
	/// <param name="writer">Output text (result)</param>
	private static void RemoveHtmlTags(
		StreamReader reader, StreamWriter writer)
	{
		StringBuilder buffer = new StringBuilder();
		bool inTag = false;
		while (true)
		{
			int nextChar = reader.Read();
			if (nextChar == -1)
			{
				// End of file reached
				PrintBuffer(writer, buffer);
				break;
			}
			char ch = (char)nextChar;
			if (ch == '<')
			{
				if (!inTag)
				{
					PrintBuffer(writer, buffer);
				}
				buffer.Clear();
				inTag = true;
			}
			else if (ch == '>')
			{
				inTag = false;
			}
			else
			{
				// We have other character (not "<" or ">")
				if (!inTag)
				{
					buffer.Append(ch);
				}
			}
		}
	}

	/// <summary>Removes the whitespace and prints the buffer
	/// in a file</summary>
	/// <param name="writer">the result file</param>
	/// <param name="buffer">the input for processing</param>
	private static void PrintBuffer(
		StreamWriter writer, StringBuilder buffer)
	{
		string str = buffer.ToString();
		string trimmed = str.Trim();
		string textOnly = regexWhitespace.Replace(trimmed, "\n");
		if (!string.IsNullOrEmpty(textOnly))
		{
			writer.WriteLine(textOnly);
		}
	}
}
The input file is read character by character with the class StreamReader.
Originally the buffer for accumulating of text is empty. In the main loop we analyze each read character. We have the following cases:
	If we get to the end of file, we print whatever is in the buffer and the algorithm ends.
	When we encounter the character "<" (start tag) we first print the buffer (if we find that the transition is from text to tag). Then we clear the buffer and set inTag = true.
	When we encounter the character ">" (end tag) we set inTag = false. This will allow the next characters after the tag to accumulate in the buffer.
	When we encounter another character (text or blank space), it is added to the buffer, if we are outside tags. If we are in a tag the character is ignored.
Printing of the buffer takes care of removing empty lines in text and clearing the empty space at the beginning and end of text (trimming the leading and trailing whitespace). How exactly we do this, we already discussed in the previous solution of the problem.
In the second solution the processing of the buffer is much lighter and shorter, so the buffer is processed immediately before printing.
In the previous solution of the task we used regular expressions for replacing with the static methods of the class Regex. For improved performance now we create the regular expression object just once (as a static field). Thus the regular expression pattern is compiled just once to a state machine.
Testing the New Solution
It remains to test thoroughly the new solution. We have to perform all tests conducted on the previous solution. Add test with tags, which are spread over several lines. Again, test performance with the Microsoft website copied 1000 times. Assure that the program works correctly and is even faster.
Let’s try with another site, such as the official website of this book – http://www.introprogramming.info (as of April 2011). Again, take the source code of the site and run the solution of our task with it. After carefully reviewing the input data (source code on the website of the book) and the output file, we notice that there is a problem again. Some content of this tag is printed in the output file:
<!--
<br />
<br />
Read the free book by Svetlin Nakov and team for developing with Java.
…
…
-->
Where Is the Problem?
The problem seems to occur when one tag meets another tag, before the first tag is closed. This can happen in HTML comments. Here’s how to get to the error:
<!--
<br />
<br />
…
As we know, in the solution of the task we use Boolean variable (inTag), to know whether the current character is in the tag or not. On the figure above we have shown that in moment 1 we set inTag = true. So far so good. Then comes moment 2, where the current character read is ">". At this point we find inTag = false. The problem is that the tag, which is open from moment 1 is not yet closed, and the Boolean variable indicates that we are not in the tag anymore and the following characters are saved in the buffer. If between the two tags for a new line (<br />) we have text, it would also be saved in the buffer.
How to Fix the Problem?
It turned out that in the second solution there is a mistake. The program does not work correctly in the presence of nested tags in a comment tag. By Boolean variable can only know whether we are in a tag or not, but cannot remember if we are still in the preceding. This tells us that instead of using a Boolean variable, we can store the number of tags in which we are (in variable of type int – tag counter). We will modify the solution:
int openedTags = 0;
StringBuilder buffer = new StringBuilder();
while (! <end of file is reached>)
{
	char ch = (read the next character);
	if (ch == '<')
	{
		if (openedTags == 0)
		{
			PrintBuffer(buffer);
		}
		buffer.Remove(0, buffer.Length);
		openedTags++;
	}
	else if (ch == '>')
	{
		openedTags--;
	}
	else
	{
		if (openedTags == 0)
		{
			buffer.Append(ch);
		}
	}
}
PrintBuffer(buffer);
In the main loop we analyze each read character. We have the following cases:
	If we get to the end of the file, print whatever is in the buffer and the algorithm ends.
	When we encounter the character "<" (start tag) first we print the buffer (if we find that the transition from text to the tag). Then we clear the buffer and increase the counter by one.
	When we encounter the character ">" (end tag) we reduce the counter by one. Closing of a nested tag will not allow accumulation in the buffer. If after closing a tag we are out of all tags, the characters will begin to accumulate in the buffer.
	When we encounter another character (text or blank space), it is added to the buffer, if we are outside all tags. If we are inside a tag – the character is ignored.
It remains to write the whole solution again and then test it. The logic for reading the input file and printing the buffer remains the same:
SimpleHtmlTagRemover.cs
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

public class SimpleHtmlTagRemover
{
	private const string InputFileName = "Problem1.html";
	private const string OutputFileName = "Problem1.txt";
	private const string Charset = "windows-1251";
	private static Regex regexWhitespace = new Regex("\n\\s+");

	static void Main()
	{
		if (!File.Exists(InputFileName))
		{
			Console.WriteLine(
				"File " + InputFileName + " not found.");
			return;
		}

		StreamReader reader = null;
		StreamWriter writer = null;
		try
		{
			Encoding encoding = Encoding.GetEncoding(Charset);
			reader = new StreamReader(InputFileName, encoding);
			writer = new StreamWriter(OutputFileName, false,
				encoding);
			RemoveHtmlTags(reader, writer);
		}
		catch (IOException)
		{
			Console.WriteLine(
				"Cannot read file " + InputFileName + ".");
		}
		finally
		{
			if (reader != null)
			{
				reader.Close();
			}
			if (writer != null)
			{
				writer.Close();
			}
		}
	}

	/// <summary>Removes the tags from a HTML text</summary>
	/// <param name="reader">Input text</param>
	/// <param name="writer">Output text (result)</param>
	private static void RemoveHtmlTags(
		StreamReader reader, StreamWriter writer)
	{
		int openedTags = 0;
		StringBuilder buffer = new StringBuilder();
		while (true)
		{
			int nextChar = reader.Read();
			if (nextChar == -1)
			{
				// End of file reached
				PrintBuffer(writer, buffer);
				break;
			}
			char ch = (char)nextChar;
			if (ch == '<')
			{
				if (openedTags == 0)
				{
					PrintBuffer(writer, buffer);
					buffer.Length = 0;
				}
				openedTags++;
			}
			else if (ch == '>')
			{
				openedTags--;
			}
			else
			{
				// We aren't in tags (not "<" or ">")
				if (openedTags == 0)
				{
					buffer.Append(ch);
				}
			}
		}
	}

	/// <summary>Removes the whitespace and prints the buffer
	/// in a file</summary>
	/// <param name="writer">the result file</param>
	/// <param name="buffer">the input for processing</param>
	private static void PrintBuffer(
		StreamWriter writer, StringBuilder buffer)
	{
		string str = buffer.ToString();
		string trimmed = str.Trim();
		string textOnly = regexWhitespace.Replace(trimmed, "\n");
		if (!string.IsNullOrEmpty(textOnly))
		{
			writer.WriteLine(textOnly);
		}
	}
}
Testing the New Solution
Again we test the solution of the problem. We perform all tests made on the previous solution (see section "Testing the Solution"). We also try the site of MSDN (http://msdn.microsoft.com). Let’s carefully check the output file. We can see that at its end the file contains wrong characters (in April 2011). After carefully reviewing the source code of the MSDN site, we notice that there is an incorrect representation of the character ">" (to visualize this character in the HTML document "&gt;" should be used, not ">"). However, this is an error in the MSDN site, not in our program.
Now it remains to test the performance of our program with the site of this book (http://www.introprogramming.info) copied 1000 times. We assure that the program works fast enough for it too.
Finally we are ready for the next task.
Problem 2: Escape from Labyrinth
We are given a labyrinth, which consists of N x N squares and each of it can be passable (0) or not (x). Our hero Jack is in one of the squares (*):
x	x	x	x	x	x
0	x	0	0	0	x
x	*	0	x	0	x
x	x	x	x	0	x
0	0	0	0	0	x
0	x	x	x	0	x
Two of the squares are neighboring, if they have a common wall. In one step Jack can pass from one passable square to its neighboring passable square. If Jack steps in a cell, which is on the edge of the labyrinth, he can go out from the labyrinth with one step.
Write a program, which by a given labyrinth prints the minimal number of steps, which Jack needs, to go out from the labyrinth or -1 if there is no way out.
The input data is read from a text file named Problem2.in. On the first line of the file is the number N (2 < N < 100). On the each of next N lines there are N characters, each of them is either "0" or "x" or "*". The output is one number and must be in the file Problem2.out.
Sample input – Problem2.in:
6
xxxxxx
0x000x
x*0x0x
xxxx0x
00000x
0xxx0x
Sample output – Problem2.out:
9
Figure Out an Idea for a Solution
We have a labyrinth and we should find the shortest path in it. This is not an easy task and we should think a lot or we should read somewhere how to solve such kinds of tasks.
Our algorithm will begin its movement from the initial point we are given. We know we can move to a neighboring cell horizontally or vertically, but not diagonally. Our algorithm must traverse the labyrinth in some way, to find the shortest path in it. How to traverse the cells in the labyrinth?
One possible decision is the following: we start from the initial cell. Move to one of its neighboring cells, after this in a neighboring cell of the current (which is passable and still unvisited), after this in a neighboring cell of the last visited (which is passable and still unvisited) and we go on forward recursively until we reach an exit of the labyrinth, or we reach a place where we can’t continue (there is no neighboring cell which is free or unvisited). In this moment we go back from the recursion (to the previous cell) and visit another neighboring cell for the previous cell. If we can’t continue, we go back again. The described recursive process is the process of traversing the labyrinth in depth (remember the chapter "Recursion" and DFS traversal).
The question "Is it needed to walk through one cell more than once" occurs to us? If we walk through one cell at most once, we can walk through the whole labyrinth faster and if there is an exit, we will find it. But will this be the minimal path? If we draw the whole process on a paper, we will find out quickly the path will not be the minimal.
If we mark the cell we leave on the way back of the recursion as free, this will allow us to reach each cell repeatedly, coming from a different path. The full recursive walk of the labyrinth will find all possible paths from the initial cell to any other cell. From all the found paths we can choose the shortest path to a cell on the bound of the labyrinth (exit) and that’s how we will find a solution for the problem.
Verification of the Idea
It seems we have an idea for solving the problem: with recursive walk we find all the possible paths in the labyrinth from the initial cell to a cell on the bounds of the labyrinth and from all these paths we choose the shortest one. Let’s check the idea.
We take a sheet of paper and make one example of the labyrinth. We try the algorithm. It’s obvious it finds all the paths from the initial cell to the one of the exits and it travels a lot forwards-backwards. As a result it finds all exits and among all paths it can be chosen the shortest one.
Does the idea work if there is no exit? We create a second labyrinth, which is without exit. We try out the algorithm on it, again on a sheet of paper. We see after long circulation forwards-backwards that the algorithm does not find an exit and finishes.
It looks we have a correct idea for solving the problem. Let’s move forward and think for the data structures.
What Data Structures to Use?
First, we have to decide how to store the labyrinth. It’s natural to use a matrix of characters, just as the one on the figure. We will consider that one cell is passable and we can enter it, if it has a character, different from the character 'x'. We can store the labyrinth in a matrix of numbers and Boolean values, but the difference is not significant. The matrix of characters is comfortable for printing, and this will help us while debugging. There are not many options. We will store the labyrinth in a matrix of characters.
After this, we have to decide in what structure to keep the visited through the recursion (current path) cells. We always need the last visited cell. This leads us to a structure, which is "last in, first out", i.e. stack. We can use Stack<Cell>, where Cell is a class, containing the coordinates of one cell (number of row and number of column). It remains to think where to keep the found paths, to find the shortest of them. If we think of it, it is not necessary to keep all the paths. It is enough to keep the current path and the shortest till this moment. It’s not even necessary to keep the shortest path till this moment but only its length. Every time we find a path to an exit of the labyrinth we can take its length and if it is shorter than the shortest path to this moment to keep it.
It seems we found efficient data structures. According to our recommen¬dations for problem solving, it is early to write the code of the program, because we have to think of the efficiency of the algorithm.
Think About the Efficiency
Let’s check our idea against efficiency. What are we doing? We find all the possible paths and we take the shortest. There’s no argument the algorithm will not work, but if the labyrinth is way bigger, will it work fast?
To answer this question, we should think how much paths there are. If we take an empty labyrinth, on the each step of the recursion we will have an average number of 3 free cells to go (without the cell we are coming from).
If we have for example a labyrinth 10x10, the path could be 100 cells and while we travel on each step we will have 3 neighboring cells. It seems the numbers of paths are sort of 3 to the power of 100. It’s obvious the algorithm will slow down the computer very much and very fast.
We found a serious problem with the algorithm. It will work very slowly, even with small labyrinths, and with bigger ones it will not work at all! The good news is that we haven’t written a single line of code and the general change of our approach to the problem will not cost us much time.
Think of Another Idea
We found that walking through all the paths in the labyrinth is wrong approach, so we have to think of another.
Let’s start with the initial cell and walk through all its neighboring cells and mark them as visited. For each visited cell we can keep a number equal to the number of cells, which we have travelled to reach it (the length of the minimal path from the initial cell to the current cell).
For the initial cell the length of the path is 0. For its neighboring cells it should be 1, because we can reach them from the initial cell with one move. For the neighboring cells for the neighbors of the initial cell the length of the path is 2. We can continue this way and we will get to the following algorithm:
	Write the length of the path 0 for the initial cell. Mark it as visited.
	For each neighboring cell to the initial we mark the length of the path is 1. Mark these cells as visited.
	For each cell, which is, neighboring to a cell with length of the path 1 and it is not visited, write the length of the path is 2. Mark the cells as visited.
	Continuing analogous, on the N step we find all the still unvisited cells, which are on a distance of N moves from the initial cell and mark them as visited.
Check the New Idea
To check whether the new idea for solving the "Escape from the Labyrinth" problem is correct we can visualize the process. We take another labyrinth to test our idea in a better way. At each step k our goal is to fill with the number k all cells that can be reached in k steps. If at step 0 we fill the initial cell with 0, at step 1 we fill all cells reachable in 1 step from the initial cell, at step 2 we fill all cells reachable in 2 steps, etc. we will be sure that when we fill a cell with a number, this number reflects the minimal number of steps to reach this cell starting from the initial cell, right?
Step 0 – mark the distance from the initial cell to itself with 0 (mark the free cells with "-"):
x	x	x	x	x	x
-	x	-	-	-	x
x	0	-	x	-	x
x	-	-	x	-	x
x	-	-	-	-	x
-	x	x	x	-	x
Step 1– mark with 1 all the neighbors to cells with a value of 0:
x	x	x	x	x	x
-	x	-	-	-	x
x	0	1	x	-	x
x	1	-	x	-	x
x	-	-	-	-	x
-	x	x	x	-	x
Step 2 – mark with 2 all the passable neighbors to cells with value 1:
x	x	x	x	x	x
-	x	2	-	-	x
x	0	1	x	-	x
x	1	2	x	-	x
x	2	-	-	-	x
-	x	x	x	-	x
Step 3 – mark with 3 all passable neighbors to cells with value of 2:
x
x	x	x	x	x
-	x	2	3	-	x
x	0	1	x	-	x
x	1	2	x	-	x
x	2	3	-	-	x
-	x	x	x	-	x
Continuing this way, in a moment either we will reach a cell at the edge of the labyrinth (an exit) or we will find such a cell is unreachable. It seems like our algorithm works correctly. It will either find an exit or will find that there is no reachable exit. If at some step an exit is found, the path to it will be guaranteed to be the shortest possible (otherwise the exit should already be found at some of the earlier steps).
Breaking the Problem into Subproblems
Having invented the idea for solving the labyrinth escaping problem, it will be easy to break it into subproblems. The main subproblems could be: reading the input labyrinth, finding the shortest path to some of its exits and printing the results. The path finding subproblem could be further divided into subproblems (steps) which we discussed in the previous section.
Checking the Performance of the New Algorithm
Because we never visit a cell more than once, the number of steps, which this algorithm does, should not be big. For example, if we have a labyrinth with size 100 x 100, it will have 10,000 cells, we will visit each of the cells at most once and for each of them we will check every neighbor if it is free, i.e. we will check 4 times each cell. At the end we will do at most 40,000 checks and we will visit at most 10,000 cells. We will do a total amount of 50,000 operations. This means the algorithm will work instantly.
Check If the New Algorithm Is Correct
It seems this time we don’t have a problem with the performance. We have a fast algorithm.
Let’s check if it is correct. For this purpose we draw a bigger and more complex example on a sheet of paper, which has many exits and a lot of paths, and we begin to perform the algorithm. After this we try with a labyrinth with no exit. It seems the algorithm ends, but does not find an exit so it’s working. We try another 2-3 examples and convince ourselves this algorithm always finds the shortest path to an exit and always works fast, because it visits each of the cells of the labyrinth at most once.
What Data Structures to Use?
With the new algorithm we walk consequently through all neighboring cells to the initial cell. We can put them into a data structure, for example in an array or better a list (or list of lists), because we can’t add in the array.
Then we take the list of the reached cells on the last step and we add their neighbors in another list.
That’s how if we index the lists we have list0, which contains the initial cell, list1, which contains passable neighboring cells to the initial, after this list2, which contains passable neighbors to list1 and so on. At the N step we have the listn, which contains all the cells, which we can reach in exactly N steps, i.e. which are at a distance of n from the initial cell.
It seems we can use a list of lists, to keep the cells on each step. If we think about it, to get the n list, we need the (n-1)-list. So it seems we don’t need list of lists but only the list from the last step.
We can make general conclusion: cells are processed in the order of entry: when the cells of step k are finished, then we process the cells from step k+1, and just after them – the cells from step k+2, and so on. The process seems like a queue: earlier accessed cells are processed earlier. If we dig a bit inside, we will conclude, that we have just re-invented the Breadth-First-Search algorithm (read about BFS in Wikipedia).
To implement the BFS algorithm we can use a queue of cells. For this purpose we have to define class Cell, which contains the coordinates of given cell (row and column). We can keep the distance from each cell to the initial cell in a matrix. If the distance is not calculated yet, we store -1.
If we think a little more, the distance from the initial cell can be kept in the cell itself (in the class Cell) instead of creating a special matrix for the distances. That way we will save memory.
Now we are clear about the data structures. Now we have to implement the algorithm step by step.
Step 1 – The Class Cell
We can begin with the definition of the Cell class. We need it to save the initial cell, from which begins the searching of the path. We will use auto-implemented properties to make the code shorter and more readable. Here is the Cell class:
public class Cell
{
	public int Row { get; set; }
	public int Column { get; set; }
	public int Distance { get; set; }
}
We can add a constructor to simplify the way we use this class:
public Cell(int row, int column, int distance)
{
	this.Row = row;
	this.Column = column;
	this.Distance = distance;
}
Generally it is a good idea to test the code after each step, but the above code is too simple to be tested. We will test is later as part of some more complex piece of code.
Step 2 – Reading the Input File
We will read the input file line by line using the well-known class StreamReader. On the each of the lines we will analyze the characters and we will write them in a matrix of characters. When we reach the character "*" we will keep its coordinates in an instance of class Cell to know where to start the searching of the shortest path for getting out of the labyrinth.
We can define a class Maze and keep the matrix of the labyrinth and the initial cell in it:
Maze.cs
public class Maze
{
	private char[,] maze;
	private int size;
	private Cell startCell = null;

	public void ReadFromFile(string fileName)
	{
		using (StreamReader reader = new StreamReader(fileName))
		{
			// Read the maze size and create the maze
			this.size = int.Parse(reader.ReadLine());
			this.maze = new char[this.size, this.size];

			// Read the maze cells from the file
			for (int row = 0; row < this.size; row++)
			{
				string line = reader.ReadLine();
				for (int col = 0; col < this.size; col++)
				{
					this.maze[row, col] = line[col];
					if (line[col] == '*')
					{
						this.startCell = new Cell(row, col, 0);
					}
				}
			}
		}
	}
}
For simplicity we will skip processing the errors while reading and writing in a file. When an exception occurs we will skip to catch it in the main method and thus we will leave the CLR to print it on the console.
Testing the Input File Reading Code
We already have the class Maze and appropriate representation of data of the input file. To be sure the written so far is correct we should test. We can check if the matrix is truly filled as we print it on the console. The other possibility is to view the values of the fields in the class Maze through the debugger of Visual Studio. We add a Main() method which invokes the maze reading method and we test it:
static void Main()
{
	Maze maze = new Maze();
	maze.ReadFromFile("Problem2.in");
}
Through the Visual Studio debugger we get convinced that the input file is correctly read from the input file:
 
Step 3 – Finding the Shortest Path
We can implement the algorithm directly from what we already discussed. We must define a queue and put in its beginning the initial cell. Afterwards we must take the cell in turn from the queue and add all of its passable unvisited neighbors in a loop. At each step there is a chance to enter in a cell, which is at the border of the labyrinth, and we see we have found an exit and the searching ends. We repeat the loop until the queue is empty. At each visitation of a given cell we check if it is free and if it is, we mark it as impassable. This way we avoid repeatedly visiting the same cell.
Here is how the implementation of the algorithm looks like:
public int FindShortestPath()
{
	// Queue for traversing the cells in the maze
	Queue<Cell> visitedCells = new Queue<Cell>();
	VisitCell(visitedCells, this.startCell.Row,
		this.startCell.Column, 0);

	// Perform Breath-First-Search (BFS)
	while (visitedCells.Count > 0)
	{
		Cell currentCell = visitedCells.Dequeue();
		int row = currentCell.Row;
		int column = currentCell.Column;
		int distance = currentCell.Distance;
		if ((row == 0) || (row == size - 1)
			|| (column == 0) || (column == size - 1))
		{
			// We are at the maze border
			return distance + 1;
		}
		VisitCell(visitedCells, row, column + 1, distance + 1);
		VisitCell(visitedCells, row, column - 1, distance + 1);
		VisitCell(visitedCells, row + 1, column, distance + 1);
		VisitCell(visitedCells, row - 1, column, distance + 1);
	}

	// We didn't reach any cell at the maze border -> no path
	return -1;
}

private void VisitCell(Queue<Cell> visitedCells,
	int row, int column, int distance)
{
	if (this.maze[row, column] != 'x')
	{
		// The cell is free --> visit it
		maze[row, column] = 'x';
		Cell cell = new Cell(row, column, distance);
		visitedCells.Enqueue(cell);
	}
}
Checking after Step 3
Before the next step, we must test, to check our algorithm. We must try the normal case and the border cases, when there is no exit, when we step on an exit, when the input file doesn’t exist or the square matrix is with size of 0. Only then can we start doing the next step. Let’s start with testing the normal (typical) case. We create the following code to quickly test it:
static void Main()
{
	Maze maze = new Maze();
	maze.ReadFromFile("Problem2.in");
	Console.WriteLine(maze.FindShortestPath());
}
We run the above code over the sample input file from the problem description and it works. The code correctly returns the length of the shortest path to the nearest exit:
9
Now let’s test the border cases, e.g. a labyrinth of size 0. Unfortunately we get the following result:
Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.
 at Maze.FindShortestPath()
We’ve made a mistake. The problem is when the variable, in which we keep the initial cell, is initialized with null. This can happen in many scenarios. If the labyrinth has no cells (e.g. size of 0) or the initial cell is missing, the result that the program should return is -1, but not an exception.
To fix the bug we just found we can add a check in the beginning of the FindShortestPath() method:
public int FindShortestPath()
{
	if (this.startCell == null)
	{
		// Start cell is missing -> no path
		return -1;
	}
	…
We retest the code with the typical and the border cases. After the fix it seems the algorithm works correctly now.
Step 4 – Writing the Result to a File
It remains to write the result of the FindShortestPath() to the output file. This is a trivial problem:
public void SaveResult(String fileName, int result)
{
	using (StreamWriter writer = new StreamWriter(fileName))
	{
		writer.WriteLine("The shortest way is: " + result);
	}
}
Here is how the complete source code of the solution looks:
Maze.cs
using System;
using System.IO;
using System.Collections.Generic;

public class Maze
{
	private const string InputFileName = "Problem2.in";
	private const string OutputFileName = "Problem2.out";

	public class Cell
	{
		public int Row { get; set; }
		public int Column { get; set; }
		public int Distance { get; set; }

		public Cell(int row, int column, int distance)
		{
			this.Row = row;
			this.Column = column;
			this.Distance = distance;
		}
	}

	private char[,] maze;
	private int size;
	private Cell startCell = null;

	public void ReadFromFile(string fileName)
	{
		using (StreamReader reader = new StreamReader(fileName))
		{
			// Read maze size and create maze
			this.size = int.Parse(reader.ReadLine());
			this.maze = new char[this.size, this.size];

			// Read the maze cells from the file
			for (int row = 0; row < this.size; row++)
			{
				string line = reader.ReadLine();
				for (int col = 0; col < this.size; col++)
				{
					this.maze[row, col] = line[col];
					if (line[col] == '*')
					{
						this.startCell = new Cell(row, col, 0);
					}
				}
			}
		}
	}

	public int FindShortestPath()
	{
		if (this.startCell == null)
		{
			// Start cell is missing -> no path
			return -1;
		}

		// Queue for traversing the cells in the maze
		Queue<Cell> visitedCells = new Queue<Cell>();
		VisitCell(visitedCells, this.startCell.Row,
			this.startCell.Column, 0);

		// Perform Breath-First-Search (BFS)
		while (visitedCells.Count > 0)
		{
			Cell currentCell = visitedCells.Dequeue();
			int row = currentCell.Row;
			int column = currentCell.Column;
			int distance = currentCell.Distance;
			if ((row == 0) || (row == size - 1)
				|| (column == 0) || (column == size - 1))
			{
				// We are at the maze border
				return distance + 1;
			}

			VisitCell(visitedCells, row, column + 1, distance + 1);
			VisitCell(visitedCells, row, column - 1, distance + 1);
			VisitCell(visitedCells, row + 1, column, distance + 1);
			VisitCell(visitedCells, row - 1, column, distance + 1);
		}

		// We didn't reach any cell at the maze border -> no path
		return -1;
	}

	private void VisitCell(Queue<Cell> visitedCells,
		int row, int column, int distance)
	{
		if (this.maze[row, column] != 'x')
		{
			// The cell is free --> visit it
			maze[row, column] = 'x';
			Cell cell = new Cell(row, column, distance);
			visitedCells.Enqueue(cell);
		}
	}

	public void SaveResult(string fileName, int result)
	{
		using (StreamWriter writer = new StreamWriter(fileName))
		{
			writer.WriteLine(result);
		}
	}

	static void Main()
	{
		Maze maze = new Maze();
		maze.ReadFromFile(InputFileName);
		int pathLength = maze.FindShortestPath();
		maze.SaveResult(OutputFileName, pathLength);
	}
}
Testing the Complete Solution of the Problem
After we have a solution of the problem we must test it. We have already tested the typical case and the border cases (like missing exit or when the initial position stays at the labyrinth edge). We will execute these tests again to get convinced that the algorithm behaves correctly:
Input	Output	Input	Output	Input	Output	Input	Output
0	-1	2
00
xx	-1	3
0x0
x*x
0x0	-1	3
000
000
00*	1
The algorithm works correctly. The output for each of the test is correct.
It remains to test with a large labyrinth (performance test), for example 1000 x 1000. We can make such a labyrinth very easy – with copy / paste. We perform the test and we convince ourselves the program is working correctly for the big test and works extremely fast – there is no delay.
While testing we should try every way to break our solution. We run a few more difficult examples (for example a labyrinth with passable cells in the form of spiral). We can put large labyrinth with a lot of paths, but without exit. We can try whatever else we wish.
At the end we make sure, that we have a correct solution and we pass to the next problem from the exam.
Problem 3: Store for Car Parts
A company is planning to create a system for managing a store for auto parts. A single part can be used for different car models and it has following characteristics: code, name, category (e.g. suspension, tires and wheels, engine, accessories and etc.), purchase price, sale price, list of car models, with which it is compatible (each car is described with brand, model and year of manufacture, e. g. Mercedes C320, 2008) and manufacturing company. Manufacturing companies are described with name, country, address, phone and fax.
Design a set of classes with relationships between them, which model the data for the store. Write a demonstration program, which demonstrates the classes and their all functionality work correctly with some sample data.
Inventing an Idea for Solution
We have a non-algorithmic problem which is intended to check whether the students at the exam know how to use object-oriented programming (OOP), how to design classes and relationships between them to model real-world objects (object-oriented analysis and design) and how to use appropriate data structures to hold collections of objects.
We are required to create an aggregation of classes and relationships between them, which have to describe the data of the store. We have to find which nouns are important for solving the problem. They are objects from the real world, which correspond to classes.
Which are these nouns that interest us? We have a store, car parts, cars and manufacturing companies. We have to create a class defining a store. It could be named Shop. Other classes are Part, Car and Manufacturer. In the requirements of the problem there are other nouns too, like code for one part or year of manufacturing of given car. For these nouns we are not creating individual classes, but instead these will be fields in the already created classes. For example in the Part class there will be let’s say a field code of string type.
We already know which will be our classes, and fields to describe them. We have to identify the relationships between the objects.
Checking the Idea
We will not check the idea because there is nothing to be proven with examples and counterexamples or checked whether it will work. We need to write few classes to model a real-world situation: a store for car parts.
What Data Structures to Use to Describe the Relationship between Two Classes?
The data structures, needed for this problem, are of two main groups: classes and relationships between the classes. The interesting part is how to describe relationships.
To describe a relationship (link) between two classes we can use an array. With an array we have access of its elements by index, but once it is created we can’t change its length. This makes it uncomfortable for our problem, because we don’t know how many parts we will have in the store and more parts can be delivered or somebody can buy parts so we have to delete or change the data. List<T> is more comfortable. It has the advantages of an array and also is with variable length and it is easy to add or delete elements.
So far it seems List<T> is the most appropriate for holding aggregations of objects inside another object. To be convinced we will analyze a few more data structures. For example hash-table – it is not appropriate in this case, because the structure "parts" is not of the key-value type. It would be appropriate if each of the parts in the store has unique number (e.g. barcode) and we needed to search them by this unique number. Structures like stack and queue are inappropriate.
The structure "set" and its implementation HashSet<T> is used when we have uniqueness for given key. It would be good sometimes to use this structure to avoid duplicates. We must recall that HashSet<T> requires the methods GetHashCode() and Equals(…) to be correctly defined by the T type.
Our final decision is to use List<T> for the aggregations and HashSet<T> for the aggregations which require uniqueness.
Dividing the Task into Subtasks
Now we have to think from where to start writing the code. If we start to write the Shop class, we will need the Part class. This reminds us we will have to start with a class, which does not depend on others. We will divide the writing of each class to ŕ subtask, and we will start from the independent classes:
	Class describing a car – Car
	Class describing manufacturer of parts – Manufacturer
	Class or enumeration for the categories of the parts – PartCategory
	Class describing part for a car – Part
	Class for the store – Shop
	Class for testing rest of the classes with sample data – TestShop
Implementation: Step by Step
We start writing classes, which we described in our idea. We will create them in the same sequence as in the list above.
Step 1: The Class Car
We start solving the problem by defining the class Car. In the definition we have three fields, which keep the manufacturer, the model and the year of manufacturing of the car and the standard method ToString(), which returns a human-readable string holding the information about the car. We define the class Car in the following way:
Car.cs
public class Car
{
	private string brand;
	private string model;
	private int productionYear;

	public Car(string brand, string model, int productionYear)
	{
		this.brand = brand;
		this.model = model;
		this.productionYear = productionYear;
	}

	public override string ToString()
	{
		return "<" + this.brand + "," + this.model + ","
			+ this.productionYear + ">";
	}
}
Note that the class Car is designed to be immutable. This means that once created, the car’s properties cannot be later modified. This design is not always the best choice. Sometimes we want the class properties to be freely modifiable; sometimes. For our case the immutable design will work well.
Testing the Class Car
Once we have the class Car, we could test it by the following code:
Car bmw316i = new Car("BMW", "316i", 1994);
Console.WriteLine(bmw316i);
The result is as expected:
<BMW,316i,1994>
We are convinced the class Car is correct so far and we can continue with the other classes.
Step 2: The Class Manufacturer
We have to implement the definition of the class Manufacturer, which describes the manufacturer for given part. It will have five fields – name, country, address, phone number and fax. The class will be immutable, because we will not need to change its members after creation. We also define the standard method ToString() for representing the object as human-readable string.
Manufacturer.cs
public class Manufacturer
{
	private string name;
	private string country;
	private string address;
	private string phoneNumber;
	private string fax;

	public Manufacturer(string name, string country,
		string address, string phoneNumber, string fax)
	{
		this.name = name;
		this.country = country;
		this.address = address;
		this.phoneNumber = phoneNumber;
		this.fax = fax;
	}

	public override string ToString()
	{
		return this.name + " <" + this.country + "," + this.address
			+ "," + this.phoneNumber + "," + this.fax + ">";
	}
}
Testing the Class Manufacturer
We test the class Manufacturer just like we tested the class Car. It works.
Step 3: The Part Category Enumeration
Part categories are fixes set of values and do not have additional details (like name, code and description). This makes them perfect to be modeled as enumeration:
PartCategory.cs
public enum PartCategory
{
	Engine,
	Tires,
	Exhaust,
	Suspention,
	Brakes
}
Step 4: The Class Part
Now we have to define the class Part. Its definition will include the following fields: name, code, category, list with cars, where we can use the given part, starting and closing price and manufacturer. Here we will use the data structure HashSet<Car> to hold all compatible cars.
The field that keeps the manufacturer of the part will be of Manufacturer class, because the task requires us to keep additional information about the manufacturer. If it was required to keep only the name of the manufacturer (as in the case with class Car) this class should not be necessary. We would have a field of string type.
We need a method for adding a car (object of type Car) to the list of cars (in HashSet<Car>). It will be named AddSupportedCar(Car car).
Below is the code of the class Part which is also designed as set of immutable fields (except that it accepts adding cars):
Part.cs
public class Part
{
	private string name;
	private string code;
	private PartCategory category;
	private HashSet<Car> supportedCars;
	private decimal buyPrice;
	private decimal sellPrice;
	private Manufacturer manufacturer;

	public Part(string name, decimal buyPrice, decimal sellPrice,
		Manufacturer manufacturer, string code,
		PartCategory category)
	{
		this.name = name;
		this.buyPrice = buyPrice;
		this.sellPrice = sellPrice;
		this.manufacturer = manufacturer;
		this.code = code;
		this.category = category;
		this.supportedCars = new HashSet<Car>();
	}

	public void AddSupportedCar(Car car)
	{
		this.supportedCars.Add(car);
	}

	public override string ToString()
	{
		StringBuilder result = new StringBuilder();
		result.Append("Part: " + this.name + "\n");
		result.Append("-code: " + this.code + "\n");
		result.Append("-category: " + this.category + "\n");
		result.Append("-buyPrice: " + this.buyPrice + "\n");
		result.Append("-sellPrice: " + this.sellPrice + "\n");
		result.Append("-manufacturer: " + this.manufacturer +"\n");
		result.Append("---Supported cars---" + "\n");
		foreach (Car car in this.supportedCars)
		{
			result.Append(car);
			result.Append("\n");
		}
		result.Append("----------------------\n");
		return result.ToString();
	}
}
In the class Part we use HashSet<Car> so it is necessary to redefine the methods Equals(…) and GetHashCode() for the class Car:
// The Equals(…) and GetHashCode() methods for the class Car

public override bool Equals(object obj)
{
	Car otherCar = obj as Car;
	if (otherCar == null)
	{
		return false;
	}
	bool equals =
		object.Equals(this.brand, otherCar.brand) &&
		object.Equals(this.model, otherCar.model) &&
		object.Equals(this.productionYear,otherCar.productionYear);
	return equals;
}

public override int GetHashCode()
{
	const int prime = 31;
	int result = 1;
	result = prime * result + ((this.brand == null) ? 0 :
		this.brand.GetHashCode());
	result = prime * result + ((this.model == null) ? 0 :
		this.model.GetHashCode());
	result = prime * result + this.productionYear;
	return result;
}
Testing the Class Part
We test the class Part. It is a bit more complicated than when testing the classes Car and Manufacturer, because Part it is more complex class. We can create a part, assign all its properties and print it:
Manufacturer bmw = new Manufacturer("BWM",
	"Germany", "Bavaria", "665544", "876666");
Part partEngineOil = new Part("BMW Engine Oil",
	633.17m, 670.0m, bmw, "Oil431", PartCategory.Engine);
Car bmw316i = new Car("BMW", "316i", 1994);
partEngineOil.AddSupportedCar(bmw316i);
Car mazdaMX5 = new Car("Mazda", "MX5", 1999);
partEngineOil.AddSupportedCar(mazdaMX5);
Console.WriteLine(partEngineOil);
Seems like the result is correct:
Part: BMW Engine Oil
-code: Oil431
-category: Engine
-buyPrice: 633.17
-sellPrice: 670.0
-manufacturer: BWM <Germany,Bavaria,665544,876666>
---Supported cars---
<BMW,316i,1994>
<Mazda,MX5,1999>
----------------------
Before we can continue with the next class, we could test for duplicated cars in the set of supported cars for certain part. Duplicates are not allowed by design and we should check whether this is enforced:
Manufacturer bmw = new Manufacturer("BWM",
	"Germany", "Bavaria", "665544", "876666");
Part partEngineOil = new Part("BMW Engine Oil",
	633.17m, 670.0m, bmw, "Oil431", PartCategory.Engine);
partEngineOil.AddSupportedCar(new Car("BMW", "316i", 1994));
partEngineOil.AddSupportedCar(new Car("BMW", "X5", 2006));
partEngineOil.AddSupportedCar(new Car("BMW", "X5", 2007));
partEngineOil.AddSupportedCar(new Car("BMW", "X5", 2006));
partEngineOil.AddSupportedCar(new Car("BMW", "316i", 1994));
Console.WriteLine(partEngineOil);
The result is correct. The duplicated cars are taken into account only once:
Part: BMW Engine Oil
-code: Oil431
-category: Engine
-buyPrice: 633.17
-sellPrice: 670.0
-manufacturer: BWM <Germany,Bavaria,665544,876666>
---Supported cars---
<BMW,316i,1994>
<BMW,X5,2006>
<BMW,X5,2007>
----------------------
Step 5: The Class Shop
We already have all needed classes for creating the class Shop. It will have two fields: name and list of parts, which are for sale. The list will be List<Part>. We will add the method AddPart(Part part), with which we will add new parts. With a redefined ToString() we will print the name of the shop and the parts in it.
Here is an example of implementation of our class Shop holding the catalog of auto parts (its name is immutable but it can add parts):
Shop.cs
public class Shop
{
	private string name;
	private List<Part> parts;

	public Shop(string name)
	{
		this.name = name;
		this.parts = new List<Part>();
	}

	public void AddPart(Part part)
	{
		this.parts.Add(part);
	}

	public override string ToString()
	{
		StringBuilder result = new StringBuilder();
		result.Append("Shop: " + this.name + "\n\n");
		foreach (Part part in this.parts)
		{
			result.Append(part);
			result.Append("\n");
		}
		return result.ToString();
	}
}
It might be a subject of discussion whether we should use List<Part> or Set<Part> for the parts in the car shop. The set data structure has an advantage that it avoids any duplicates. Thus if we have for example few tires of certain model, they will be found only once in the set. To use set we need to be sure the parts are uniquely identified by their code or by some other unique identifier. In our case we assume we could have parts with exactly the same code, name, etc. which come at different buy and sell prices (e.g. if the prices change over the time). So we need to allow duplicated parts and thus using a set will not be appropriate. Parts in the shop will be kept in List<Part>.
We will test the class Shop though the especially written class TestShop.
Step 6: The Class TestShop
We created all classes we need. We have to create one more, with which we will have to demonstrate the usage of the rest of the classes. It will be named TestShop. In the Main() method we will create two manufacturers and a few cars. We will add them to two parts. We will add the parts to the Shop. At the end we will print everything on the console.
TestShop.cs
public class TestShop
{
	static void Main()
	{
		Manufacturer bmw = new Manufacturer("BWM",
			"Germany", "Bavaria", "665544", "876666");
		Manufacturer lada = new Manufacturer("Lada",
			"Russia", "Moscow", "653443", "893321");

		Car bmw316i = new Car("BMW", "316i", 1994);
		Car ladaSamara = new Car("Lada", "Samara", 1987);
		Car mazdaMX5 = new Car("Mazda", "MX5", 1999);
		Car mercedesC500 = new Car("Mercedes", "C500", 2008);
		Car trabant = new Car("Trabant", "super", 1966);
		Car opelAstra = new Car("Opel", "Astra", 1997);

		Part cheapPart = new Part("Tires 165/50/R13", 302.36m,
			345.58m, lada, "T332", PartCategory.Tires);
		cheapPart.AddSupportedCar(ladaSamara);
		cheapPart.AddSupportedCar(trabant);

		Part expensivePart = new Part("Universal Car Engine",
			6733.17m, 6800.0m, bmw, "EU33",	PartCategory.Engine);
		expensivePart.AddSupportedCar(bmw316i);
		expensivePart.AddSupportedCar(mazdaMX5);
		expensivePart.AddSupportedCar(mercedesC500);
		expensivePart.AddSupportedCar(opelAstra);

		Shop newShop = new Shop("Tuning Pro Shop");
		newShop.AddPart(cheapPart);
		newShop.AddPart(expensivePart);

		Console.WriteLine(newShop);
	}
}
This is the result of the execution of the above code:
Shop: Tuning Pro Shop

Part: Tires 165/50/R13
-code: T332
-category: Tires
-buyPrice: 302.36
-sellPrice: 345.58
-manufacturer: Lada <Russia,Moscow,653443,893321>
---Supported cars---
<Lada,Samara,1987>
<Trabant,super,1966>
----------------------

Part: Universal Car Engine
-code: EU33
-category: Engine
-buyPrice: 6733.17
-sellPrice: 6800.0
-manufacturer: BWM <Germany,Bavaria,665544,876666>
---Supported cars---
<BMW,316i,1994>
<Mazda,MX5,1999>
<Mercedes,C500,2008>
<Opel,Astra,1997>
----------------------
Testing the Solution
At the end we need to test our code. In fact we have done this in the class TestShop. This doesn’t mean that we have tested entirely our problem. We have to check the border cases, for example when some of the lists are empty. Let’s make a little change of the code in Main() method, to start the program with an empty list:
static void Main()
{
	Shop emptyShop = new Shop("Empty Shop");
	Console.WriteLine(emptyShop);

	Manufacturer lada = new Manufacturer("Lada",
		"Russia", "Moscow", "653443", "893321");
	Part tires = new Part("Tires 165/50/R13", 302.36m,
		345.58m, lada, "T332", PartCategory.Tires);

	Manufacturer bmw = new Manufacturer("BWM",
		"Germany", "Bavaria", "665544", "876666");
	Part engineOil = new Part("BMW Engine Oil",
		633.17m, 670.0m, bmw, "Oil431", PartCategory.Engine);
	engineOil.AddSupportedCar(new Car("BMW", "316i", 1994));
		
	Shop ultraTuningShop = new Shop("Ultra Tuning Shop");
	ultraTuningShop.AddPart(tires);
	ultraTuningShop.AddPart(engineOil);

	Console.WriteLine(ultraTuningShop);
}
The result of this test is:
Shop: Empty Shop


Shop: Ultra Tuning Shop

Part: Tires 165/50/R13
-code: T332
-category: Tires
-buyPrice: 302.36
-sellPrice: 345.58
-manufacturer: Lada <Russia,Moscow,653443,893321>
---Supported cars---
----------------------

Part: BMW Engine Oil
-code: Oil431
-category: Engine
-buyPrice: 633.17
-sellPrice: 670.0
-manufacturer: BWM <Germany,Bavaria,665544,876666>
---Supported cars---
<BMW,316i,1994>
----------------------
From the result it seems the first shop is empty and in the second shop the list of cars for the first part is empty. This is the correct output. Therefore our program works correctly with the border case of empty lists.
We can continue testing with other border cases (e.g. missing part name, missing price, missing manufacturer, etc.), as well as with some kind of performance test (e.g. shop with 300,000 parts for 5,000 cars and 200 manufacturers). We will leave this for the readers.
Exercises
	You are given an input file mails.txt, which contains names of users and their email addresses. Each line of the file looks like this:
<first name> <last name> <username>@<host>.<domain>
There is a requirement for email addresses – <username> can be a sequence of Latin letters (a-z, A-Z) and underscore (_), <host> is a sequence of lower Latin letters (a-z), and <domain> has a limit of 2 to 4 lower Latin letters (a-z). Following the guidelines for problem solving write a program, which finds the valid email addresses and writes them together with the names of the users (in the same format as in the input) to an output file valid-mails.txt.
Sample input file (mails.txt):
Steve Smith steven_smith@yahoo.com
Peter Miller pm<5.gmail.com
Svetlana Green svetlana_green@hotmail.com
Mike Johnson mike*j@888.com
Larry Cutts larry.cutts@gmail.com
Angela Hurd angel&7@freemail.hut.fi
Output file (valid-mails.txt):
Steve Smith steven_smith@yahoo.com
Svetlana Green svetlana_green@hotmail.com
Larry Cutts larry.cutts@gmail.com
	You are given a labyrinth, which consists of N x N squares, and each of them can be passable (0) or not (x).
In one of the squares our hero Jack (*) is positioned. Two squares are neighbors, if they have a common wall. At one step Jack can pass from one passable square to its neighboring passable square. Write a program, which prints the number of possible exits from given labyrinth. At the figure below we have 7 possible exits, reachable from the start position.
x	x	x	0	x	x
0	x	0	0	0	
0	*	0	x	0	0
x	x	x	x	0	x
0	0	0	0	0	x
0	x	0	x	x	0
The input data is read from a text file named Labyrinth.in. At the first line in the file is the number N (2 < N < 1000). At the next N lines there are N characters, each either "0" or "x" or "*". The output is a single number and should be printed in the file Labyrinth.out.
	You are given a labyrinth, which consists of N x N squares, each of it can be passable or not. Passable cells consist of lower Latin letter between "a" and "z", and the non-passable – '#'. In one of the squares is Jack. It is marked with "*".
Two squares are neighbors, if they have common wall. At one step Jack can pass from one passable square to its neighboring passable square. When Jack passes through passable squares, he writes down the letters from each square. At each exit he gets a word. Write a program, which from a given labyrinth prints the words, which Jack gets from all the possible exits. At the example below Jack can get 10 different words corresponding to its 10 possible paths he could find to some of the exits: a, az, aza, madk, madkm, madam, madamk, dir, did, difid.
a	#	#	k	m	#
z	#	a	d	a	#
a	*	m	#	#	#
#	d	#	#	#	#
r	i	f	i	d	#
#	d	#	d	#	t
The input data is read from a text file named Labyrinth.in. At the first line in the file there is the number N (2 < N < 10). At each of the next N lines there are N characters, each of them is either Latin letter between "a" and "z" or "#" (impassable wall) or "*" (Jack). The output must be printed in the file Labyrinth.out.
	A company plans to create a system for managing of a sound recording company. The sound recording company has a name, address, owner and performers. Each performer has name, nickname and created albums. Albums are described with name, genre, year of creation, number of sold copies and list of songs. The songs are described with name and duration. Design a set of classes with relationships between each other, which models the data of the record company. Implement a test class, which demonstrates the work of rest of the classes.
	A company plans on creating of a system for managing a company for real estates. The company has name, owner, tax ID, employees and has a list of estates for sale. Employees are described with name, work position and experience. The company sells several types of estates: apartments, houses, undeveloped areas and shops. All of them are characterized with area, price of square meters and location. For some of them there is additional information. For the apartments there is data about the number of the floor, whether there is an elevator in the block, and if it is furnished. For the houses the data is – square meters for the undeveloped area and for the developed (yard), how many floors it has and whether it is furnished. Design a set of classes with relationships between them, which model the data for the company. Implement a test class, which demonstrates the work of the rest of the classes.
Solutions and Guidelines
	The problem is similar to the first problem from our sample exam. Again we can read line by line the input file and with appropriate regular expression to check the email addresses. Test the solution carefully before you go to the next problem.
	Possible exits from the labyrinth are all the cells, which are positioned at the border of the labyrinth and are reachable from the initial cell. The problem could be solved using BFS with just little modification of the solution of the "Escape from Labyrinth". Test your solution carefully!
	The problem is similar to the previous one, but all possible paths to the exit are required. You can do recursive search with backtracking (DFS) and keep in a StringBuilder the letters to the exit, to create the words, which you have to print. With bigger labyrinths the problem has no optimal solution (there is no way to print all the paths, without generating all of them, but they grow exponentially to the labyrinth size). Test carefully your solution and think of special cases that need special care.
	You must write the required classes: MusicCompany, Artist, Album, Song. Think of the links between classes and what data structures to use for them. For the printing redefine the method ToString() from System.Object. Test all methods and the border cases.
	The classes you must write are EstateCompany, Employee, Apartment, House, Shop and UndevelopedArea. Export all shared characteristics in separate abstract base class Estate. Encapsulate all fields with properties. Override the method ToString(), which to collect the data of the corresponding class and print it to the console. Test all methods and special border cases (like missing property values).


Chapter 25. Sample Programming Exam – Topic #2

In This Chapter
In this chapter, we will take a look at the specifications of a few practical algorithmic problems from a sample programming exam, and we will offer solutions. While solving the problems, we will follow the guidelines from the chapter "Problem Solving Methodology", and we are going to illustrate their implementation.
Problem 1: Counting the Uppercase / Lowercase Words in a Text
Write a program that counts the words in a text entered from the console. The program must output the total number of words, the number of words written in uppercase and the number of words written in lowercase. If a word appears more than once in the text, each repetition counts as a new occurrence. Every character that is not a letter counts as a word separator.
Sample input:
Welcome to your first programming exam! Can you think of a solution to this problem and write it down? GOOD LUCK!
Sample output:
Word count: 21
Upper case words: 2
Lower case words: 17
Coming Up with an Appropriate Idea for a Solution
Intuitively, it comes to mind, that the problem may be solved by splitting the text up into separate words and counting those that meet the specified conditions.
Obviously, this approach is correct, but far too general, and it doesn’t lead to a particular method for solving the problem. Let’s try to be more specific, and see if by doing so, we could implement an algorithm that will lead to a solution. It might turn out that the implementation is difficult, or that the complexity of the solution is too great for the program to complete its execution even with today’s powerful computers. If that is the case, we would have to find another solution to the problem.
Breaking Down the Problem into Subproblems
A useful approach for solving algorithmic problems is to try breaking them down into smaller problems that are easier and quicker to solve. Let’s try defining the necessary steps for solving this problem.
First of all, we have to split the text up into separate words. This, in and of itself, is not a simple task, but it is the first step towards breaking down the problem into smaller, although still complicated, subproblems.
Then we need to count the words that concern us. This is the second major problem we have to solve. Let’s take a look at both problems separately and try breaking them down even further.
How Do We Split the Text Up into Separate Words?
In order to split the text up into separate words, we need to find a way to identify them first. According to the problem specifications every non-letter character functions as a word separator. Therefore, we must first identify these separators and use them to split the text in tokens.
So far, we have formulated two subproblems – finding the separators and partitioning (splitting) the text in accordance with the characters found. We can implement their solutions right away. This was in fact our goal from the start – breaking down complicated problems into smaller and easier subproblems.
In order to find the separators, all we need to do is iterate through all characters and extract those that aren’t letters.
Once we have identified the separators, we can implement the text partitioning by invoking the Split(…) method of the String class.
How Do We Count the Words?
Let’s assume we already have a list of all words from the text. We want to find the total word count, the number of words in uppercase and the number of words in lowercase.
To do this, we can go through each and every word from the list and check if it meets either of the necessary conditions. At each step we increment the total word count. We check if the current word is in uppercase and, if so, we increment the number of words in uppercase. Likewise, we check if the word consists only of lowercase letters and increment the lowercase word counter.
Thus, we have defined another two subproblems – recognizing uppercase and lowercase words. These appear to be very easy. It might even turn out that the string class provides such functionality. After we check, it turns out this is not the case. Yet we notice that there are methods that allow us to convert a string to an uppercase or a lowercase string. This might be of use.
To check if a word consists only of uppercase letters, all we have to do is compare it to the string resulting after converting the word to uppercase. If the two are equal, then the comparison returns true. Performing the check for lowercase words is done likewise.
Verifying the Idea
It seems our idea is a good one. We’ve broken down the problem into subproblems and we know how to solve each of them. Should we continue towards the implementation? Haven’t we overlooked something?
Shouldn’t we have verified the idea by writing down a few examples on paper? Perhaps we would come across something we have missed. We could start with the example given in the problem statement:
Welcome to your first programming exam! Can you think of a solution to this problem and write it down? GOOD LUCK!
The separators would be: spaces, ? and !. The words that have come up are the following: Welcome, to, your, first, programming, exam, Can, you, think, of, a, solution, to, this, problem, and, write, it, down, GOOD, LUCK.
Counting the words we acquire the correct result. It seems the idea is adequate, and it works. Now we can proceed towards implementing it. We will do this step by step and at each step we will implement one subproblem.
Let’s Consider the Data Structures
The problem is simple and doesn’t need complex data structures.
We can use the char data type for storing each separator. During the process of finding the separator characters we add each of them to a list. We can use either char[] or List<char>. In this case, we will choose the latter.
As for the words in the text, we can use an array of strings string[] or List<string>.
Let’s Consider the Efficiency
Are there any performance requirements? How long can the text be?
Since the text will be entered from the console, it’s unlikely to be very long. No one is going to type 1MB of text into the console. We can assume that the solution’s performance is not critical.
Let’s Write Down the Solution
It’s very good practice to write the solution down on a piece of paper before typing it on the computer. This helps uncover drawbacks in our idea or implementation beforehand. In addition, implementing the solution will be considerably quicker, because of the outlines we can provide and because we would then have a better grasp of both the problem and the solution.
Step 1: Finding the Separators in the Text
We will define a method that extracts all non-letter characters from the text and return them as an array of characters. Then we will use that array for splitting the text up into separate words. We will use List<char> to keep the separators we find when passing through the text:
private static char[] ExtractSeparators(string text)
{
	List<char> separators = new List<char>();
	foreach (char character in text)
	{
		// If the character is not a letter,
		// then by definition it is a separator
		if (!char.IsLetter(character))
		{
			separators.Add(character);
		}
	}
	return separators.ToArray();
}
We use a loop to iterate through all of the characters in the text. We check if the current character is a letter by invoking the IsLetter() method of the primitive data type char. If it’s not, we add the character to the separators. Finally, our method returns an array containing the separators.
Testing the ExtractSeparators(…) Method
Before we go any further, it’s advisable to test if extracting the separators is working correctly. For this purpose, we will write two additional methods. The first of these is TestExtractSeparators() which will test the execution of ExtractSeparators(…) and the second – GetTestData() – will return different texts, which will allow us to test our solution:
private static void TestExtractSeparators()
{
	List<string> testData = GetTestData();
	foreach (string testCase in testData)
	{
		Console.WriteLine(
			"Test Case:{0}{1}", Environment.NewLine, testCase);
		Console.WriteLine("Result:");
		foreach (char separator in ExtractSeparators(testCase))
		{
			Console.Write("{0} ", separator);
		}
		Console.WriteLine();
	}
}

private static List<string> GetTestData()
{
	List<string> testData = new List<string>();
	testData.Add("This is wonderful!!! All separators like " +
		"these ,.(? and these /* are recognized. It works.");
	testData.Add("SingleWord");
	testData.Add(string.Empty);
	testData.Add(">?!>?#@?");
	return testData;
}

static void Main()
{
	TestExtractSeparators();
}
We start the program and check if the separators have been correctly identified. The first test’s result is as follows:
Test Case:
This is wonderful!!! All separators like these ,.(? and these /* are recognized.
 It works.
Result:
    ! ! !           , . ( ?       / *     .     .
Test Case:
SingleWord
Result:

Test Case:

Result:

Test Case:
>?!>?#@?
Result:
> ? ! > ? # @ ?
We might think of the above output as partially correct. In fact it does extract correctly the separators between the words but most of them are duplicated several times. We need all the separators without duplications, right?
Correcting the ExtractSeparators(…) Method
To correct the method for extracting the separators between the words in the text, we can use a different data structure to keep them. We know that sets keep elements without duplications. So we could use HashSet<char> instead of List<char> to hold the separator characters we find in the text:
private static char[] ExtractSeparators(string text)
{
	HashSet<char> separators = new HashSet<char>();
	foreach (char character in text)
	{
		// If the character is not a letter,
		// then by definition it is a separator
		if (!char.IsLetter(character))
		{
			separators.Add(character);
		}
	}
	return separators.ToArray();
}
The code is almost the same, but we use a set instead of list to avoid duplicated separators. We might need to include the System.Linq namespace in the start of the program to use the ToArray() extension method for converting a hash set to an array.
Testing Again after the Fix
We test the above method with the same testing code and we find it now works correctly. The separators are extracted correctly with no duplicates:
Test Case:
This is wonderful!!! All separators like these ,.(? and these /* are recognized.
 It works.
Result:
  ! , . ( ? / *
Test Case:
SingleWord
Result:

Test Case:

Result:

Test Case:
>?!>?#@?
Result:
> ? ! # @
We test also with some borderline cases – text consisting of a single word without separators; text consisting of separators only; an empty string. We’ve already included such tests in our GetTestData() method. It seems that the method works fine and we can proceed to the next step.
Step 2: Splitting Up the Text in Separate Words
We will use string’s Split(…) method with the specified separators for splitting up the text by the separators and extracting the words from it. This is how our method looks like:
private static string[] ExtractWords(string text)
{
	char[] separators = ExtractSeparators(text);
	string[] words = text.Split(separators,
		StringSplitOptions.RemoveEmptyEntries);
	return words;
}
Testing the Word Extracting Method
Before we carry on to the next step, we have to see if the method works correctly. To do this, we will reuse the GetTestData() for the input test data and we will test the new ExtractWords(…) method:
private static void TestExtractWords()
{
	List<string> testData = GetTestData();
	foreach (string testCase in testData)
	{
		Console.WriteLine("\nTest Case: {0}", testCase);
		string[] words = ExtractWords(testCase);
		Console.WriteLine("Result: {0}", string.Join(" ", words));
	}
}

static void Main()
{
	TestExtractWords();
}
The result from the above test looks correct:
Test Case: This is wonderful!!! All separators like these ,.(? and these /* are
recognized. It works.
Result: This is wonderful All separators like these and these are recognized It
works

Test Case: SingleWord
Result: SingleWord

Test Case:
Result:

Test Case: >?!>?#@?
Result:
We check the results from the other test cases. We verify that they are correct and that our algorithm is accurate (till this stop).
Step 3: Determining Whether a Word Is in Uppercase or Lowercase
We already have an idea how to implement the uppercase / lowercase checks, and we can write the corresponding methods directly:
private static bool IsUpperCase(string word)
{
	bool result = word.Equals(word.ToUpper());
	return result;
}

private static bool IsLowerCase(string word)
{
	bool result = word.Equals(word.ToLower());
	return result;
}
We test the above methods by passing words in uppercase, lowercase and mixed case. The results are correct.
Step 4: Counting the Words
Now we can proceed to solving the problem itself – counting the words. All we have to do is iterate through the list of words and depending on the word’s type to increment the corresponding counters. Then we print the result:
private static void CountWords(string[] words)
{
	int allUpperCaseWordsCount = 0;
	int allLowerCaseWordsCount = 0;
	foreach (string word in words)
	{
		if (IsUpperCase(word))
		{
			allUpperCaseWordsCount++;
		}
		else if (IsLowerCase(word))
		{
			allLowerCaseWordsCount++;
		}
	}

	Console.WriteLine("Total words count: {0}", words.Length);
	Console.WriteLine("Upper case words count: {0}",
		allUpperCaseWordsCount);
	Console.WriteLine("Lower case words count: {0}",
		allLowerCaseWordsCount);
}
Testing the Word Counting Method
Let’s check if we count the words correctly. We will write another test method using the data from the GetTestData() method and the previously written and tested ExtractWords(…) method:
private static void TestCountWords()
{
	List<string> testData = GetTestData();
	foreach (string testCase in testData)
	{
		Console.WriteLine("Test Case: {0}", testCase);
		Console.WriteLine("Result: ");
		CountWords(ExtractWords(testCase));
		Console.WriteLine();
	}
}

static void Main()
{
	TestCountWords();
}
Executing the application, we obtain the correct result:
Test Case: This is wonderful!!! All separators like these ,.(? and these /* are recognized. It works.
Result:
Total words count: 13
Upper case words count: 0
Lower case words count: 10

Test Case: SingleWord
Result:
Total words count: 1
Upper case words count: 0
Lower case words count: 0

Test Case:
Result:
Total words count: 0
Upper case words count: 0
Lower case words count: 0

Test Case: >?!>?#@?
Result:
Total words count: 0
Upper case words count: 0
Lower case words count: 0
The above results are correct (the typical case and a few borderline cases). We perform few other borderline tests, e.g. when the list contains words in uppercase or lowercase only, or when the list is empty. All of them work correctly.
Note that it is a good idea to use unit testing instead of these semi-automated tests. Recall how we write unit tests in Visual Studio (in the chapter "High-Quality Code") and try to convert our test methods to unit tests for the Visual Studio Team Test (VSTT) framework.
Step 5: Console Input
All that’s left to implement is the final step – allowing the user to input text:
private static string ReadText()
{
	Console.WriteLine("Enter text:");
	return Console.ReadLine();
}
Note that as a rule unless the input comes from a text file or is very short (e.g. just one number or few characters) it should be read as a final step. Otherwise we will need to enter the input data each time when we start the program and this will waste a lot of time and can lead to errors.
Step 6: Putting All Together
Now after all subproblems have been solved, we can proceed to the complete solution to the problem. We need to add a Main(…) method, which will combine together the different parts of the solution:
static void Main()
{
	string text = ReadText();
	string[] words = ExtractWords(text);
	CountWords(words);
}
Testing the Solution
While implementing the solution, we wrote test methods for every method, integrating them with each other gradually. For the moment, we are certain they interact correctly; there’s nothing we have overlooked and there is no method that does unnecessary work or that returns incorrect results.
If we would like to test the solution with more data, we would only need to add it to the GetTestData(…) method. If we want, we may even rewrite the GetTestData(…) method so that it reads the test data from an external source, e.g. from a text file.
Here’s how the final solution looks like at the end:
WordsCounter.cs

using System;
using System.Collections.Generic;
using System.Linq;

public class WordsCounter
{
	static void Main()
	{
		string text = ReadText();
		string[] words = ExtractWords(text);
		CountWords(words);
	}

	private static string ReadText()
	{
		Console.WriteLine("Enter text:");
		return Console.ReadLine();
	}

	private static char[] ExtractSeparators(string text)
	{
		HashSet<char> separators = new HashSet<char>();
		foreach (char character in text)
		{
			// If the character is not a letter,
			// then by definition it is a separator
			if (!char.IsLetter(character))
			{
				separators.Add(character);
			}
		}
		return separators.ToArray();
	}

	private static string[] ExtractWords(string text)
	{
		char[] separators = ExtractSeparators(text);
		string[] words = text.Split(separators,
			StringSplitOptions.RemoveEmptyEntries);
		return words;
	}

	private static bool IsUpperCase(string word)
	{
		bool result = word.Equals(word.ToUpper());
		return result;
	}

	private static bool IsLowerCase(string word)
	{
		bool result = word.Equals(word.ToLower());
		return result;
	}

	private static void CountWords(string[] words)
	{
		int allUpperCaseWordsCount = 0;
		int allLowerCaseWordsCount = 0;

		foreach (string word in words)
		{
			if (IsUpperCase(word))
			{
				allUpperCaseWordsCount++;
			}
			else if (IsLowerCase(word))
			{
				allLowerCaseWordsCount++;
			}
		}

		Console.WriteLine("Total words count: {0}", words.Length);
		Console.WriteLine("Upper case words count: {0}",
			allUpperCaseWordsCount);
		Console.WriteLine("Lower case words count: {0}",
			allLowerCaseWordsCount);
	}
}
We removed the testing methods from our code to simplify it. The best practice is instead of removing the tests to create a separate testing project and put all the tests in a testing class. This is best achieved though the Visual Studio’s unit testing framework, as it was shown in the chapter "High-Quality Code".
A Word on Performance
Since there are no explicit performance requirements, we will only make a suggestion for dealing with the situation when the algorithm turns out to be slow. Splitting the text with separators assumes that the entire text will be loaded into memory. The list of words, after partitioning the text, will also be written to memory. Therefore, if the input text is large, the program will also consume a large amount of memory. For example, if the input text is 200MB long, then the program will consume at least 800MB of memory, because each word is stored as 2 bytes for every character (.NET uses UTF-16 character encoding for the strings in memory).
If we want to avoid high memory consumption then the words must not be stored in memory all at once. We can come up with another algorithm: scanning the text char by char and storing the letters into a buffer (such as StringBuilder). If at a certain moment a separator is encountered, then the buffer contains the most recent word. We can analyze its casing and then empty the buffer. We can repeat this until the end of the file is reached. This appears to be more efficient, doesn’t it?
A more efficient lower / upper case checker would be to iterate through all letters using a loop and to examine them char by char. That way we can skip a lower / upper case conversion, which allocates extra memory for every word. After the word has been processed, the memory will be freed, which would eventually lead to extra CPU utilization (for the .NET garbage collector).
Obviously, the latter solution is more efficient. The question is if we should scrap the original solution and write a completely different one. It all depends on the performance requirements. The problem description doesn’t hint at an input text measuring in the hundreds of megabytes. Therefore the current solution, although not optimal, is still correct and will suffice. We suggest the reader to implement the proposed fast solution and to compare how faster it is, e.g. by processing an input of 100 MB.
Problem 2: A Matrix of Prime Numbers
Write a program that reads a positive integer N from the standard input and prints the first N2 prime numbers as a square matrix of size N x N. The matrix must be filled with numbers starting from the first row and ending at the last one. Each row must be filled with prime numbers from left to right.
Note: A prime number is a number that has no divisors other than 1 and itself. The number 1 is not a prime number.
Sample input:
2									3									4
Sample output:
2 3								2 3 5							2 3 5 7
5 7								7 11 13							11 13 17 19
									17 19 23						23 29 31 37
																		41 43 47 53
Coming Up with an Appropriate Idea for a Solution
We can solve the problem by printing the rows and columns of the resulting matrix using two nested loops. For each of its elements we will extract and print the corresponding prime number.
Breaking Down the Problem into Subproblems
We must solve at least two subproblems – finding each successive prime number and printing the prime numbers into a matrix. We can print the matrix right away, but the process of finding each successive prime number will require additional thinking. Perhaps the most intuitive way to accomplish this is to start testing the primality of each number starting from the last prime number that we found. When a new prime is encountered, it is returned as a result. Thus, a new subproblem has come up – checking whether or not a number is a prime.
Verifying the Idea
Our idea for a solution leads directly to the required result. We write down a couple of examples on a piece of paper and make sure that it works.
Consider the Data Structures
The problem makes use of one data structure only – a matrix. It’s only natural to use a two-dimensional array (matrix).
Consider the Efficiency
Displaying at the console large matrices (for example of size 1000 x 1000) cannot be properly handled. This means our solution should work for reasonably large matrices, e.g. on the order of N ? 200. We don’t need to consider cases where the matrix is too large. When N = 200, our algorithm will find the first 40,000 prime numbers and should not run slowly.
Now we are ready for the implementation of the algorithm we invented.
Step 1: Check to Find If a Number Is a Prime
To test a number for primality, we can define a method called IsPrime(…). The test will verify that dividing the number by any of its predecessors always yields a division remainder. To be more precise, it is sufficient to check the integers between 2 and the square root of the number. This holds true, because if the number p has a divisor x, then p = x.y, and at least one or both of the numbers x and y will be less than or equal to the square root of p. What follows is an implementation of the method:
private static bool IsPrime(int number)
{
	int maxDivider = (int)Math.Sqrt(number);
	for (int divider = 2; divider <= maxDivider; divider++)
	{
		if (number % divider == 0)
		{
			return false;
		}
	}
	return true;
}
The algorithm complexity of the above example is O(sqrt(number)), because the amount of checks that will be made is not greater than the square root of the number. This complexity will suffice for the problem at hand, but is it possible to optimize this method even further?
Come to think about it, every second number is even and all even numbers are divisible by 2. In that case, if the number we are testing is odd, the above method will needlessly check all odd numbers from 2 to the square root of the number. How can we omit these unnecessary checks? We could find out if the number is even at the very beginning of the method. If it’s not, it will be processed in a modified version of the main loop that skips even numbers. Using this new approach, we have achieved the same computational complexity of O(sqrt(number)), but with a better constant 1/2.
This example illustrates how to optimize a bit the existing method:
private static bool IsPrime(int number)
{
	if (number == 2)
	{
		return true;
	}
	if (number % 2 == 0)
	{
		return false;
	}

	int maxDivider = (int)Math.Sqrt(number);
	for (int divider = 3; divider <= maxDivider; divider += 2)
	{
		if (number % divider == 0)
		{
			return false;
		}
	}
	return true;
}
As we can see, there was a minimal amount of changes compared to the non-optimized version.
Testing the Prime Checking Method
We can make sure both methods work correctly by consecutively passing to them different numbers, some of which will be primes, and verifying the results.
 	Always test a method to make sure it works before optimizing it.
The reason to test your methods is that after optimization, the code usually gets longer, more difficult to read and therefore more difficult to debug, if it is incorrect.
 	Be careful when optimizing a piece of code. Do not go to extremes by making unnecessary optimizations that will make your program marginally faster at the expense of readability and maintenance.
To check the prime checking method we could write a piece of code like this:
static void Main()
{
	Console.WriteLine(IsPrime(2));
	Console.WriteLine(IsPrime(3));
	Console.WriteLine(IsPrime(4));
	Console.WriteLine(IsPrime(5));
	Console.WriteLine(IsPrime(121));
}
It runs as expected and the produced results are correct:
True
True
False
True
False
Step 2: Finding the Next Prime Number
In order to find the next prime number, we can define a method that takes an integer as a parameter and returns the first prime number equal or larger than it. To check if the number is prime, we will use the method from the previous step. Below is an implementation of the method:
private static int FindNextPrime(int startNumber)
{
	int number = startNumber;
	while (!IsPrime(number))
	{
		number++;
	}
	return number;
}
Testing the Next Prime Number Finder
Once again we have to test the method by passing a few numbers and verifying that the result is correct:
static void Main()
{
	Console.WriteLine(FindNextPrime(2));
	Console.WriteLine(FindNextPrime(3));
	Console.WriteLine(FindNextPrime(4));
	Console.WriteLine(FindNextPrime(5));
	Console.WriteLine(FindNextPrime(121));
}
The result is correct, as expected:
2
3
5
5
127
Step 3: Printing the Matrix
Now that we have defined the previous methods, we are all set to print the entire matrix of prime numbers:
private static void PrintMatrixOfPrimes(int dimension)
{
	int lastPrime = 1;
	for (int row = 0; row < dimension; row++)
	{
		for (int col = 0; col < dimension; col++)
		{
			int nextPrime = FindNextPrime(lastPrime + 1);
			Console.Write("{0,4}", nextPrime);
			lastPrime = nextPrime;
		}
		Console.WriteLine();
	}
}
We will test this method as part of testing the entire program.
Step 4: Console Input
All that’s left is to add functionality allowing us to read N from the console.
static void Main()
{
	int n = ReadInput();
	PrintMatrixOfPrimes(n);
}

private static int ReadInput()
{
	Console.Write("N = ");
	string input = Console.ReadLine();
	int n = int.Parse(input);
	return n;
}
Testing the Entire Solution
After we have completed all other steps, we can proceed with testing the entire solution. To do this, we could look up the first 25 prime numbers (at a sheet of paper) and test the program’s output for values of N between 1 and 5. We should include special border cases like N=0 and N=1. We know that at border cases the likelihood of making a mistake is significantly higher.
In our case, we can confine ourselves with the examples from the problem description, provided that the methods have been thoroughly tested at each step. This is the output of the program for N = 1, 2, 3 and 4 respectively:
2				2 3						2 3 5							2 3 5 7
				5 7						7 11 13							11 13 17 19
											17 19 23						23 29 31 37
																				41 43 47 53
The result is correct and after few more tests we get convinced that we have solved correctly the problem "Matrix of Prime Numbers".
We can make sure the solution works relatively fast even for larger values of N. For example, there is no perceived lag for N = 200.
A Word on Performance
We should point out, that our solution does not find prime numbers in the most efficient way. Despite of this drawback, due to the solution’s clarity and the reasonably small size of the matrix, we can utilize this algorithm without performance issues.
Improved Performance: Sieve of Eratosthenes
If we have to improve the performance, we can find the first N2 prime numbers using the Sieve of Eratosthenes. That way we will not need to check if every number is prime until we find N2 prime numbers. You might ask yourself how large Eratosthenes’s Sieve will be needed if we want to find the first N2 prime numbers. You might use the following approximation (without any mathematical proof):
long sieveSize =
	 (long)Math.Truncate(2.4 * n * n * Math.Log(n, Math.E)) + 2;
If the Eratosthenes’s Sieve is at least sieveSize elements large, it will be enough to produce the first N2 prime numbers and not too much above them. You could check this manually or you might invite a better formula using complex mathematical calculations (see http://en.wikipedia.org/wiki/Prime-counting_function). For example if N=10, the estimated sieveSize will be 554 and it will find the first 101 prime numbers (we need 102 = 100 prime numbers to fill the matrix, so these 101 prime numbers are enough). If N=1,000, the sieveSize will be 16,578,614 and it will find the first 1,065,855 prime numbers. For N=5,000 the sieveSize will be 511,031,593 and it will find the first 26,905,486 prime numbers. For significantly bigger sizes Eratosthenes’s Sieve will not fit in the memory. You might try to implement this algorithm and check how faster it is. When comparing the speed, you may redirect the output to a file to save some time which is spent in printing the matrix.
Problem 3: Evaluate an Arithmetic Expression
Write a program that evaluates a simple arithmetic expression consisting of unsigned integers and the arithmetic operations "+" and "-". There will be no blank spaces between the integers.
The expression will have the following format:
<number><operation>…<number>
Sample input:
1+2-7+2-1+28+2+3-37+22
Sample output:
15
Coming Up with an Appropriate Idea for a Solution
To solve this problem, we can take advantage of the strict expression format, which guarantees we have a sequence of a number, operation, another number and so on.
That way, we can first extract all numbers from the expression, and then we can extract all operators and finally evaluate the result by combining the numbers with the operators.
Verifying the Idea
Sure enough, if we test this approach with a few expressions using pen and paper, we acquire a correct result. Initially, the result is equal to the first number and at each step we either add or subtract the next number depending on the current operator.
Data Structures and Efficiency
The problem is too simple for us to use complex data structures. The numbers and characters can be stored in arrays. Performance issues are out of the question, because the characters and numbers are processed exactly once, i.e. the complexity of the algorithm is linear. Even with millions of integers and operators, the algorithm is expected to work fast.
Breaking Down the Problem into Subproblems
Now that we have made sure the idea works, we can move on to breaking down the problem into subproblems. The first subproblem we will have to solve is extracting the numbers from the expression. The second – extracting the operators. Finally, we will evaluate the entire expression using the extracted numbers and operators.
Step 1: Extracting the Numbers
In order to extract the numbers, we need to split the expression using the operators (+ and -) as separators. This is easily done using the Split(…) method of the string class. Afterwards, we have to convert the resulting array of strings to an array of integers:
private static int[] ExtractNumbers(string expression)
{
	string[] splitResult = expression.Split('+', '-');
	int[] resultNumbers = new int[splitResult.Length];
	for (int i = 0; i < splitResult.Length; i++)
	{
		resultNumbers[i] = int.Parse(splitResult[i]);
	}
	return resultNumbers;
}
We use the Parse(…) method of the Int32 class to convert strings to integers. It takes a string as a parameter and returns the integer value that the string represents.
Why do we use an array to store the numbers? Can’t we use a linked list or a dynamic array? Of course we can, but in our case we only need to store the integers and iterate through them when evaluating the result. Therefore, an array is sufficient and is the simplest collection that will work.
Testing the Extraction of Numbers
Before we move on to the next step we should check if the numbers are extracted correctly. We may use the following example:
static void Main()
{
	int[] numbers = ExtractNumbers("1+2-7+2-1+28");
	foreach (int x in numbers)
	{
		Console.Write("{0} ", x);
	}
}
The result is exactly as it should be:
1 2 7 2 1 28
We examine the border case when the expression consists only of one number and no operators, and we make sure it is handled properly.
Step 2: Extracting the Operators
We can extract the operators by iterating through each consecutive character from the string and check if it is one of the specified operators:
private static char[] ExtractOperators(string expression)
{
	string operatorCharacters = "+-";
	List<char> operators = new List<char>();
	foreach (char c in expression)
	{
		if(operatorCharacters.Contains(c))
		{
			operators.Add(c);
		}
	}
	return operators.ToArray();
}
Testing the Extraction of Operators
Here’s how we test whether or not the method works correctly:
static void Main()
{
	char[] operators = ExtractOperators("1+2-7+2-1+28+3+1");
	foreach (char oper in operators)
	{
		Console.Write("{0} ", oper);
	}
}
The output after the program’s execution is correct:
+ - + - + + +
We create a test for the border case when the expression consists of only one number and no operators. Just as expected, we get an empty array and the output of the above testing program is and empty string.
Step 3: Evaluating the Expression
When evaluating the expression, we can make use of the fact that the numbers’ count is always greater than the operators’ count by one. Using a single loop we can evaluate the expression, provided we have the lists of numbers and operators:
private static int CalculateExpression(int[] numbers,
	char[] operators)
{
	int result = numbers[0];
	for (int i = 1; i < numbers.Length; i++)
	{
		char operation = operators[i - 1];
		int nextNumber = numbers[i];
		if (operation == '+')
		{
			result += nextNumber;
		}
		else if (operation == '-')
		{
			result -= nextNumber;
		}
	}
	return result;
}
Test the Evaluation of Expression
We test the method’s execution:
static void Main()
{
	// Expression: 1 + 2 - 3 + 4
	int[] numbers = new int[] { 1, 2, 3, 4 };
	char[] operators = new char[] { '+', '-', '+' };
	int result = CalculateExpression(numbers, operators);
	// Expected result is 4
	Console.WriteLine(result);
}
The result seems to be correct:
4
We perform few other tests (e.g. a 1, 1+2, 1-1) and it still works correctly.
Step 4: Console Input
We have to provide the user with the means to enter an expression:
private static string ReadExpression()
{
	Console.Write("Enter expression: ");
	string expression = Console.ReadLine();
	return expression;
}
This could be left untested, because it is too simple and it will be tested later when the entire program is finished and gets tested.
Step 5: Putting All Together
All that’s left is to integrate all methods so that they can function together.
static void Main()
{
	string expression = ReadExpression();

	int[] numbers = ExtractNumbers(expression);
	char[] operators = ExtractOperators(expression);

	int result = CalculateExpression(numbers, operators);
	Console.WriteLine("{0} = {1}", expression, result);
}
Testing the Solution
We can use the example from the problem description when testing the solution. We get a correct result:
Enter expression: 1+2-7+2-1+28+2+3-37+22
1+2-7+2-1+28+2+3-37+22 = 15 
In order to make sure the solution runs correctly, we must create a few more tests with different parameters, which will include the case when the expression consists of one number only.
We can even test with an empty string. It’s not clear if such input is valid, but we can take it into account just to be on the safe side. It’s also ambiguous what would happen, if "2 + 3" (with spaces) is entered, instead of "2+3". It’s a good idea to cope with these situations.
One test case we neglected occurs when a number doesn’t fit in an int variable. What do you think would happen, if the user enters the expression "11111111111111111111111111111+222222222222222222222222222222"?
Small Corrections and Repeated Testing
The program will raise an exception (of type System.FormatException or System.OverflowException in all likelihood) when the expression is invalid. It’s sufficient to catch the exceptions, and when they are thrown, to report that an invalid expression has been entered. Below is the solution’s full implementation after this correction:
SimpleExpressionEvaluator.cs
using System;
using System.Collections.Generic;
using System.Linq;

public class SimpleExpressionEvaluator
{
	private static int[] ExtractNumbers(string expression)
	{
		string[] splitResult = expression.Split('+', '-');
		int[] resultNumbers = new int[splitResult.Length];
		for (int i = 0; i < splitResult.Length; i++)
		{
			resultNumbers[i] = int.Parse(splitResult[i]);
		}
		return resultNumbers;
	}

	private static char[] ExtractOperators(string expression)
	{
		string operationsCharacters = "+-";
		List<char> operators = new List<char>();
		foreach (char c in expression)
		{
			if (operationsCharacters.Contains(c))
			{
				operators.Add(c);
			}
		}
		return operators.ToArray();
	}

	private static int CalculateExpression(
		int[] numbers, char[] operators)
	{
		int result = numbers[0];
		for (int i = 1; i < numbers.Length; i++)
		{
			char operation = operators[i - 1];
			int nextNumber = numbers[i];
			if (operation == '+')
			{
				result += nextNumber;
			}
			else if (operation == '-')
			{
				result -= nextNumber;
			}
		}
		return result;
	}

	private static string ReadExpression()
	{
		Console.WriteLine("Enter expression:");
		string expression = Console.ReadLine();
		return expression;
	}

	static void Main()
	{
		try
		{
			string expression = ReadExpression();

			int[] numbers = ExtractNumbers(expression);
			char[] operators = ExtractOperators(expression);

			int result = CalculateExpression(numbers, operators);
			Console.WriteLine("{0} = {1}", expression, result);
		}
		catch (Exception ex)
		{
			Console.WriteLine("Invalid expression!");
		}
	}
}
To ensure everything works correctly after the fix we need to test the above code again with: single number, two numbers, typical expression (like the sample input from the problem description), expression with spaces (e.g. "1 + 2 -3"), expression with large numbers, invalid expression (e.g. -1).
Performance Test
Finally we could test with very long expression (performance test), e.g. sum of 1,000,000 ones. We could generate a test of 1,000,000 numbers with the following sample code:
static void Main()
{
	StringBuilder expression = new StringBuilder();
	expression.Append("0");
	for (int i = 0; i < 1000000; i++)
	{
		expression.Append("+");
		expression.Append("1");
	}
	string expr = expression.ToString();
	int[] numbers = ExtractNumbers(expr);
	char[] operators = ExtractOperators(expr);
	int result = CalculateExpression(numbers, operators);
	Console.WriteLine(result);
}
The running time seems acceptable and the result is correct.
But what will happen if we sum 1,000,000 times the value of 5,000,000? We will get an integer overflow. We might fix this by using long for the sum instead of int:
private static long CalculateExpression(
	int[] numbers, char[] operators)
{
	long result = numbers[0];
	for (int i = 1; i < numbers.Length; i++)
	{
		char operation = operators[i - 1];
		int nextNumber = numbers[i];
		if (operation == '+')
		{
			result += nextNumber;
		}
		else if (operation == '-')
		{
			result -= nextNumber;
		}
	}
	return result;
}
After this small fix we sum 1,000,000 times the value of 5,000,000 and we get the correct result: 5,000,000,000,000. The problem is solved.
Exercises
	Solve the problem "Counting the Number of Words in a Text" by using a buffer (StringBuilder) to read the text. Was there a change in the complexity of your algorithm?
	Implement a more efficient solution to the problem "A Matrix of Prime Numbers" by using the "Sieve of Eratosthenes":
http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.
	Add support for integer multiplication and division to the solution of "Arithmetic Expression". Bear in mind that these operations have priority over addition and multiplication!
	Add support for floating point numbers in the solution of the "Arithmetic Expression" problem.
	* Add parentheses support to the solution of "Arithmetic Expression". Try to process correctly the unary minus (e.g. in the expression -2 + 3).
	* Write a program that validates an arithmetic expression. For example, "2*(2.25+5.25)-17/3" is a valid expression, but "*232*-25+(33+a" is not.
Solutions and Guidelines
	Your program can read from the input file character by character. If the current character is a letter, append it to the buffer, and if it is a separator, analyze the buffer (since it holds the current word) and clear it. When the end of the input file is reached and the file does not end with a separator, analyze the last word in the buffer. Test the solution!
	First, estimate the count of prime numbers you will need. Then consider what the upper limit of the iterations for the Sieve of Eratosthenes should be, so that there are enough numbers to fill the matrix. You can come up with a formula by experimenting or you may use the formula from the section "Improved Performance: Sieve of Eratosthenes".
	Taking into account that in math multiplication and division has a priority over addition and subtraction you can calculate all multiplications and divisions first, replace them with their result and then all the additions and subtractions. For example, let’s the expression is "2*5-8/2+11". You may first calculate all multiplications and divisions and replace them with the results of their execution: "2*5-8/2+11" ? "10-4+11". Then you may use the algorithm from the "Evaluate an Arithmetic Expression" section. Did you consider division by zero? Test your code. Think of special cases.
	Floating point arithmetic can be implemented by allowing the use of the character "." and replacing int with double or decimal. Test your code!
	You can do the following: locate the first closing parenthesis and match it with its corresponding opening parenthesis. What remains between them is an arithmetic expression that can be evaluated with the same algorithm recursively. You can substitute the expression with its value and repeat the process until there aren’t any more parentheses. Eventually, you will end up with an expression without parentheses.
For example, if the expression "2*((3+5)*(4-7*2))" is entered, you will substitute "(3+5)" with 8, and "(4-7*2)" with -10. Finally, you will replace "(8*-10)" with -80 and calculate 2*-80, thus getting the result -160. You will have to consider the arithmetic operations with negative numbers, i.e. adding negative numbers support when parsing the numbers.
There is one more algorithm. It utilizes a stack and converts the expression to reverse Polish notation (RPN). Look up the terms "postfix notation" and "shunting yard algorithm" on the Internet.
To handle correctly the unary minus, you may consider two situations. The first is a leading unary minus (e.g. -3 + 5). The second is a minus after another operator or after a bracket, e.g. "3 * -2 + 4". The minus can be applied to a number of to an expression in brackets. In both cases you may insert "0-" and put the number or expression on the right in brackets. Examples:
	"-3 + 5" ? "(0-3) + 5"
	"3 * -2 + 5" ? "3 * (0-2) + 5"
	"-(3+2)" ? "(0-(3+2))"
	"-(-1) * 3 - -1" ? "(0-((0-1))) * 3 – (0-1)"
	If you evaluate the expression using reverse polish notation, you can expand your algorithm to check the expression for validity. Follow these rules: when you expect a digit, but the next token is not a digit, then the expression is invalid; when an arithmetic operation is expected, but the next token is not a valid operator, then the expression is invalid; when the parentheses do not match, the stack will either underflow or remain non-empty at the end. Don’t forget the special cases "-1", "-(2+4)", etc. Test thoroughly your code! There are many special cases to consider. 


Chapter 26. Sample Programming Exam – Topic #3

In This Chapter
In the present chapter we will review some sample exam problems and suggest solutions for them. While solving the problems we will stick to the advices given in the chapter "Methodology of Problem Solving".
Problem 1: Spiral Matrix
With a given number N (input from the keyboard) generate and print a square matrix containing the numbers from 0 to N2-1, located as a spiral beginning from the center of the matrix and moving clockwise starting downwards (look at the examples).
Sample output for N=3 and N=4:
 
Start Thinking on the Problem
It’s obvious from the requirement that we are given an algorithmic problem. Contriving the appropriate algorithm for filling up the square matrix cells in the required way is the main part of the solution to the problem. We will demonstrate to the reader the typical reasoning needed for solving this particular problem.
Inventing an Idea for the Solution
The next step is to think up the idea for the algorithm, which we will implement. We must fill the matrix with the numbers from 0 to N2-1 and we may immediately notice that this could be made by a loop, which puts one of the numbers in the supposed cell of the matrix at each iteration. We first put 0 at its place, then put 1 at its place, then put 2, and so on until we finish with putting N2-1 at its place.
Let’s suppose we know the starting position – the one we have to put the first number on (the zero). That’s how the problem is reduced to finding a method for determining each of the next positions, which we must put a number at – this is our primary subtask.
We try to find an approach for determining the next to the current position: we search a strict regularity for changing the indices during the traversal of the cells. It looks like the directions of the numbers are changed from time to time, right? First the direction if down, then the direction is changed to left, later to up, then to right then again to down. Changing of the directions is always clockwise and the initial direction is always downwards.
If we define an integer variable direction that holds the current moving direction, it will take sequentially the values 0 (down), 1 (left), 2 (up), 3 (right) and then again 0, 1, 2, … Looking at the problem examples (for N=3 and N=4) we can conclude that the direction stays down for some time, then changes to left, stays some time, then changes to up, stays some time, etc. We can assume that with changing the moving direction we can increase the value of direction by one and take its remainder of division by 4. Thus the next direction after 3 (right) will be 0 (down).
The next step is to determine when the moving direction changes: what is the number of moves in each direction. This may take some time. We can take a sheet of paper and test few hypotheses we might have.
From the two examples we can see that the number of moves in the consequent directions does form special sequences: for N=3 ? 1, 1, 2, 2, 2 and for N=4 ? 1, 1, 2, 2, 3, 3, 3. This means that for N=3 we move 1 cell down, then 1 cell left, then 2 cells up, then 2 cells right and finally 2 down. For N=4, the process is the same. We found an interesting dependency which can evolve into an algorithm for filling the spiral matrix.
If we write down a bigger matrix of the same type on a sheet of paper, we will see that the sequence of the changes of direction follows the same pattern: the numbers increases by 1 at an interval of two and the last number does not increase.
Seems like we have an idea to solve the problem: start from the middle of the matrix and move 1 cell down, 1 cell left, 2 cells up, 2 cells right, 3 cells down, 3 cells left, etc. During the moving we can fill the numbers from 0 to N2-1 consequently at the cells we visit.
Checking the Idea
Let’s check the idea. First we need to find the starting cell and check we have a correct algorithm for it. If N is odd, the starting cell seems to be the absolute center cell of the matrix. We can check this for N=1, N=3 and N=5 on a sheet of paper and this confirms to be correct. If N is even number, it seems like the starting cell is located upper-right from the central point of the matrix. At the figure below the central point is shown for a matrix of size 4 x 4 and the starting point located at the upper-right direction:
 
Now let’s check the matrix filling algorithm. We take for example N=4. Let’s start from the starting cell. The first direction is down. We go down 1 cell, then left 1 cell, then up 2 cells, then right 2 cells, then down 3 cells, then left 3 cells and finally up 3 cells. For simplicity we can assume the last step is 4 cells up but we stop at the first moment when the entire matrix if filled. The figure below shows what we could draw on a sheet of paper to trace how the algorithm works. See the small sketch of our algorithm, done by hand during the idea checking process:
 
After sketching the algorithm paper for N = 1, 2 and 3 on a sheet of paper we see that it works correctly. Seems like the idea is correct and we can thinks about how to implement it.
Data Structures and Efficiency
Let’s start with choosing the data structure for implementing the matrix. It’s appropriate to have direct access to each element of the matrix so we will choose a two-dimensional array matrix of integer type. When starting the program we read from the standard input the dimensionality n of the matrix and initialize it as it follows:
int[,] matrix = new int[n,n];
In this case the choice of a data structure is unambiguous. We will keep the matrix in a two-dimensional array. We have no other data. We will not have problems with the performance because the program will make as much steps as the elements in the matrix are.
Implementation of the Idea: Step by Step
We may split the implementation into few steps. A loop runs from 0 to N2-1 and at each iteration it does the following steps:
	Fill the current cell of the matrix with the next number (this is a single move in the current direction).
	Check whether the current direction should be changed and if yes, change it and calculate the number of moves in the new direction.
	Move the current position to the next cell in the current direction (e.g. one position down / left / up / right).
Implementing the First Few Steps
We can represent the current position with integer variables positionX and positionY – the two coordinates for the position. At each iteration we will move to the next cell in the current direction and positionX and positionX will change accordingly.
For modeling the behavior of filling the spiral matrix we will use the variables stepsCount (total number of moves in the current direction), stepPosition (the move number in the current direction) and stepChange (flag showing if we have to change the value of stepCount – increments after every 2 direction changes).
Let’s see how we can implement this idea as a code:
for (int i = 0; i < count; i++)
{
	// Fill the current cell with the current value
	matrix[positionY, positionX] = i;

	// Check for direction / step changes
	if (stepPosition < stepsCount)
	{
		stepPosition++;
	}
	else
	{
		stepPosition = 1;
		if (stepChange == 1)
		{
			stepsCount++;
		}
		stepChange = (stepChange + 1) % 2;
		direction = (direction + 1) % 4;
	}

	// Move to the next cell in the current direction
	switch (direction)
	{
		case 0:
			positionY++;
			break;
		case 1:
			positionX--;
			break;
		case 2:
			positionY--;
			break;
		case 3:
			positionX++;
			break;
	}
}
Performing a Partial Check after the First Few Steps
This is the moment to point out the unlikelihood of creating the body of such a loop from the first time, without making any mistakes. We already know the rule for writing the code step by step and testing after each piece of code is written but for the body of this loop the rule is hard to be applied – we have no independent subproblems, which can be tested separately of each other. To test the above code we need first to finish it: to assign initial values for all the variables used.
Assigning the Initial Values
After we have a well thought-out idea for the algorithm (even if we are not completely sure that the written code will work correctly), it remains to set initial values of the already defined variables and to print the matrix, obtained after the implementation of the loop.
It is clear that the number of loop iterations is exactly N2 and that’s why we replace the variable count with this value. From the two given examples and our own additional examples (written on a paper) we determine the initial position in the matrix depending on the parity (odd / even) of its size:
int positionX = n / 2; // The middle of the matrix
int positionY = n % 2 == 0 ? (n / 2) - 1 : (n / 2); // middle
To the rest of the variables we give the following initial values (we have already explained their semantics):
int direction = 0; // The initial direction is "down"
int stepsCount = 1; // Perform 1 step in the current direction
int stepPosition = 0; // 0 steps already performed
int stepChange = 0; // Steps count will change after 2 steps
Putting All Together
The last subproblem we have to solve for creating a working program is printing the matrix on the standard output. Let’s write it, then put all code together and start testing.
The fully implemented solution is shown below. It includes reading the input data (matrix size), filling the matrix in a spiral (calculating the matrix center and filling it cell by cell) and output the result:
MatrixSpiral.cs
using System;

public class MatrixSpiral
{
	static void Main()
	{
		Console.Write("N = ");
		int n = int.Parse(Console.ReadLine());
		int[,] matrix = new int[n, n];

		FillMatrix(matrix, n);

		PrintMatrix(matrix, n);
	}

	private static void FillMatrix(int[,] matrix, int n)
	{
		int positionX = n / 2; // The middle of the matrix
		int positionY = n % 2 == 0 ? (n / 2) - 1 : (n / 2);

		int direction = 0; // The initial direction is "down"
		int stepsCount = 1; // Perform 1 step in current direction
		int stepPosition = 0; // 0 steps already performed
		int stepChange = 0; // Steps count changes after 2 steps

		for (int i = 0; i < n * n; i++)
		{
			// Fill the current cell with the current value
			matrix[positionY, positionX] = i;

			// Check for direction / step changes
			if (stepPosition < stepsCount)
			{
				stepPosition++;
			}
			else
			{
				stepPosition = 1;
				if (stepChange == 1)
				{
					stepsCount++;
				}
				stepChange = (stepChange + 1) % 2;
				direction = (direction + 1) % 4;
			}

			// Move to the next cell in the current direction
			switch (direction)
			{
				case 0:
					positionY++;
					break;
				case 1:
					positionX--;
					break;
				case 2:
					positionY--;
					break;
				case 3:
					positionX++;
					break;
			}
		}
	}

	private static void PrintMatrix(int[,] matrix, int n)
	{
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < n; j++)
			{
				Console.Write("{0,3}", matrix[i, j]);
			}
			Console.WriteLine();
		}
	}
}
Testing the Solution
After we have implemented the solution it is appropriate to test it with enough values of N to ensure it works properly. We start with the sample values 3 and 4 and then we check for 5, 6, 7, 8, 9, … It works well.
It is important to check the border cases: 0 and 1. They work correctly as well. We do few more tests and we make sure all cases work correctly. We might notice that when N is large (e.g. 50) the output looks ugly, but this cannot be improved much. We can add more spaces between the numbers but the console is limited to 80 characters and the result is still ugly. We will not try to improve this further.
It is not necessary to test the program for speed (performance test, for example with N=1,000) because with a very big N the output will be extremely large and the task will be pointless.
We cannot find any non-working cases so we assume the algorithm and its implementation are both correct and the problem is successfully solved.
Now we are ready for the next problem from the exam.
Problem 2: Counting Words in a Text File
We are given a text file words.txt, which contains several words, one per each line. Each word consists of Latin letters only. Write a program, which retrieves the number of matches of each of the given words as a substring in the file text.txt. The counting is case insensitive. The result should be written into a text file named result.txt in the following format (the words should appear in the same order as given in the input file words.txt):
<word1> --> <number of matches>
<word2> --> <number of matches>
…
Sample input file words.txt:
for
academy
student
Java
develop
CAD
Sample input file text.txt:
The Telerik Academy for software development engineers is a famous center for free professional training of .NET experts. Telerik Academy offers courses designed to develop practical computer programming skills. Students graduated the Academy are guaranteed to have a job as a software developers in Telerik.
Sample result file result.txt:
for --> 2
academy --> 3
student --> 1
Java --> 0
develop --> 3
CAD --> 3
Below are the locations of the matched words from the above example:
The Telerik Academy for software development engineers is a famous center for free professional training of .NET experts. Telerik Academy offers courses designed to develop practical computer programming skills. Students graduated the Academy are guaranteed to have a job as a software developers in Telerik.
Start Thinking on the Problem
The emphasis of the given problem seems not so much on the algorithm, but on its technical implementation. In order to write the solution we must be familiar with working with files in C# and with the basic data structures, as well as string processing in .NET Framework.
Inventing an Idea for a Solution
We get a piece of paper, write few examples and we come up with the following idea: we read the words file, scan through the text and check each word from the text for matches with the preliminary given list of words and increase the counter for each matched word.
Checking the Idea
The above idea for solving the task is trivial but we can still check it by writing down on a piece of paper the sample input (words and text) and the expected result. We just scan through the text word by word in our paper example and when we find a match with some of the preliminary given words (as a substring) we increment the counter for the matched word. The idea works in our example.
Now let’s think of counterexamples. In the same time we might also come with few questions regarding the implementation:
	How do we scan the text and search for matches? We can scan the text character by character or line by line or we can read the entire text in the memory and then scan it in the memory (by string matching or by a regular expression). All of these approaches might work correctly but the performance could vary, right? We will think about the performance a bit later.
	How do we extract the words from the text? Maybe we can read the text and split it by all any non-letter characters? Where shall we take these non-letter characters from? Or we can read the text char by char and once we find a non-letter character we will have the next word from the text? The second idea seems faster and will require less memory because we don’t need to read all the text at once. We should think about this, right?
	How do we match two words? This is a good question. Very good question. Suppose we have a word from the text and we want to match it with the words from the file words.txt. For example, we have "Academy" in the text and we should find whether it matches as substring the "CAD" word from the list of words. This will require searching each word from the list as a substring in each word from the text. Also can we have some word appearing several times inside another? This is possible, right?
From all the above questions we can conclude that we don’t need to read the text word by word. We need to match substrings, not words! The title of the problem is misleading. It says "Counting Words in a Text File" but it should be "Counting Substrings in a Text File".
It is really good that we found we have to match substrings (instead of words), before we have implemented the code for the above idea, right?
Inventing a Better Idea
Now, considering the requirement for substring matching, we come with few new and probably better ideas about solving the problem:
	Scan the text line by line and for each line from the text and each word check how many times the word appears as substring in the line. The last can be counted with String.IndexOf(…) method in a loop. We already have solved this subproblem in the chapter "Strings and Text Processing" (see the section "Finding All Occurrences of a Substring").
	Read the entire text and count the occurrences of each word in it (as a substring). This idea is very similar to the previous idea but it will require much memory to read the entire text. Maybe this will not be efficient. We gain nothing, but potentially we will run "out of memory".
	Scan the text char by char and store the read characters in a buffer. After each character read we check if the text in the buffer ends with some of the words from the list. We will not need to search the words in the buffer because we check for each word after each character is read. We could also clear the buffer when we read any non-letter character (because the list of words for matching should contain letters only). Thus the memory consumption will be very low.
The first and the last idea seem to be good. Which of them to implement? Maybe we could implement both of them and choose the faster one. Having two solutions will also improve the testing because we should get identical results with both of the solutions on all test cases.
Checking the New Ideas
We have two good ideas and we need to check them for correctness before thinking about implementation. How to check the ideas? We can invent a good test case on a piece of paper and try the ideas on it.
Let’s have the following list of words:
Word
S
MissingWord
DS
aa
We might be interested to find the number of occurrences of the above words in the following text:
Word? We have few words: first word, second word, third word.
Some passwords: PASSWORD123, @PaSsWoRd!456, AAaA, !PASSWORD
The expected result is as follows:
Word --> 9
S --> 13
MissingWord --> 0
DS --> 2
aa --> 3
In the above example we have many different special cases: whole-word matching, matching as a substring, matching in different casing, matches in the start / end of the text, several matches inside the same word, overlapping matches, etc. This example is a very good representative of the common case for this problem. It is important to have such short but comprehensive test case when solving programming problems. It is important to have it early, when checking the ideas, before any code is written. This avoids mistakes, catches incorrect algorithms and saves time!
Checking the Line by Line Algorithm
Now let’s check the first algorithm: read the two lines of text and check how many times each of the words from the given list occurs in each line ignoring the character casing. At the first line we find as substrings (ignoring the case) "word" 5 times, "s" 3 times, "MissingWord" 0 times, "aa" 0 times and "ds" – 1 time. At the second line we find as substrings (ignoring the case) "word" 4 times, "s" 10 times, "MissingWord" 0 times, "aa" 3 times and "ds" – 1 time. We sum the occurrences and we find that the result is correct.
We try to find counterexamples, but we can’t. The algorithm may not work with words spanning multiple lines. This is not possible by definition. It may also have issues with the overlapping matches like finding "aa" in "AAaA". This will be definitely checked after the algorithm is implemented.
Checking the Char by Char Algorithm
Let’s check the other algorithm: scan through the text char by char, holding the characters in a buffer. After each character if the buffer ends with some of the words (ignoring the character casing), the occurrences of the matched word are increased. If a non-letter is occurred, the buffer is cleaned.
We start from empty buffer and append the first char from the text "W" to the buffer. None of the words match the end of the buffer. We append "o" and the buffer holds "Wo". No matches. Then we append "r". The buffer holds "Wor". Again no matches are found with any of the words. We append the next char "d" and the buffer holds "Word". We have found a match with the word form a list: "word". We increase the number of occurrences of the matched word from zero to one. The next char is "?" and we clean the buffer, because it is not a letter. The next char is " " (space). We again clean the buffer. The next char is "W". We append it to the buffer. No matches with any of the words. We continue further and further… After the last character is processed, the algorithm finishes and the results are correct.
We try to find counterexamples, but we can’t. The algorithm may not work with words spanning multiple lines, but this is not possible by definition.
Decompose the Problem into Subproblems
Now let’s try to divide the problem into subproblems. This should be done separately for the both algorithms we want to try because they differ significantly.
Line by Line Algorithm Decomposed into Subproblems
Let’s decompose the line by line algorithm into subproblems (sub-steps):
	Read the input words. We can read the file words.txt by using File.ReadAllLines(…). It reads a text file in a string[] array of lines.
	Process the lines of the text one by one to count the occurrences of each word in it. Initially assign zero occurrences for each word. Read the input file text.txt line by line. For each line from the text and for each word check the number of its occurrences (this is a separate subproblem) and increase the counters for each match. The occurrences counting should be case-insensitive.
	Count the number of occurrences of certain substring in certain text. This is a separate subproblem. We find the leftmost occurrence of the substring in the text though string.IndexOf(…). If the returned index > -1 (the substring exists), we increase the counter and find the next occurrence of the substring on the right from the last found index. We perform this in a loop until we find -1 as a result which means that there are no more matches. To perform case-insensitive searching we can pass a special parameter StringComparison.OrdinalIgnoreCase to the IndexOf() method.
	Print the results. Process all words and for each word print it along with its counter holding its occurrences in the output file result.txt.
Char by Char Algorithm Decomposed into Subproblems
Let’s decompose the char by char algorithm into subproblems (sub-steps):
	Read the input words. We can read the file words.txt by using File.ReadAllLines(…). It reads a text file in a string[] array of lines. The original words can be saved and a copy of them in lowercase can be made to simplify the matching with ignoring the character casing.
	Process the text char by char. Read the input file text.txt and append the letters into a buffer (StringBuilder). After each letter appended check whether the text in the buffer ends with some of the words in the input list of words (this check is a separate subproblem). If so, increase the number occurrences of the matched word. If a non-letter character is found, clean the buffer. Letters are converted to lowercase before added in the buffer.
	Check whether a certain text (StringBuilder) ends by a certain string. In case the string has length n lower than the length of the text, the result is false. Otherwise the n letters of the string should be compared one by one with the last n letters of the text. If a mismatch is found, the result is false. If all checks pass, the result is true.
	Print the results. Process all words and for each word print it along with its counter holding its occurrences in the output file result.txt.
Think about the Data Structures
In the line by line algorithm we don’t have any need of special data structures. We can keep the words in an array or list of strings. We can keep the number of occurrences for each word in array of integer values. The text lines we can keep in strings.
In the char by char algorithm the situation is similar. We don’t need any special data structures. We can keep the words in an array or list of strings. We can keep the number of occurrences for each word in array of integer values. The buffer for the characters we can implement by StringBuilder (because we need to append chars many times).
Think about the Performance
Following the guidelines for problem solving from the chapter "Methodology of Problem Solving" we should think about the efficiency and performance before writing any code.
The line by line algorithm will process the entire text line by line and for each text line it will search for all of the words. Thus if the text has a total size of t characters and the number of words are w, the algorithm will totally perform w string searches in t characters. Each search for a word in the text will pass through the entire text (at least once, but maybe not always). If we assume that searching for a word in a text is a linear time operation, we will have w scans through the entire text, so the excepted running time in quadratic: O(w*t). If we search in MSDN or in Internet, we will be unable to find any information about how exactly String.IndexOf(…) works internally and whether it runs in linear time or it is slower. This method calls a Win32 API function so it cannot be decompiled. Thus the best way to check its performance is by measuring.
The char by char algorithm will process the entire text char by char and for each character it will perform a string matching for each of the words. Suppose the text has t characters and the number of the words is w. In the average case the string matching will run in constant time (it will require just one check if the first letter is not matching, two checks if the first letter matches, etc.). In the worst case the string matching will require n comparisons where n is the length of the word being matched. Thus in the average case the expected running time of the algorithm will be quadratic: O(w*t). In the worst case it will be significantly slower.
It seems like the line by line algorithm is expected to run faster but we are uncertain about how fast is string.IndexOf(…), so this cannot be definitely stated. If we are at an exam, we will probably choose to implement the line by line algorithm. Just for the experiment, let’s implement both of them and compare their performance.
Implementation: Step by Step
If we directly follow the steps, which we have already identified we can write the code with ease. Of course it is better to implement the algorithms step-by-step, to find and fix the bugs early.
Line by Line Algorithm: Step by Step Implementation
We can start implementing the line by line algorithm for word counting in a text file from the method that counts how many times a substring appears in a text. It should look like the following:
static int CountOccurrences(	string substring, string text)
{
	int count = 0;
	int index = 0;
	while (true)
	{
		index = text.IndexOf(substring, index);
		if (index == -1)
		{
			// No more matches
			break;
		}
		count++;
	}
	return count;
}
Let’s test it before going further:
Console.WriteLine(
	CountOccurrences("hello", "Hello World Hello"));
The result is 0 – wrong! It seems like we have forgotten to ignore the character casing. Let’s fix this. We need to change the name of the method as well and add the StringComparison.OrdinalIgnoreCase option when searching for the given substring:
static int CountOccurrencesIgnoreCase(
	string substring, string text)
{
	int count = 0;
	int index = 0;
	while (true)
	{
		index = text.IndexOf(substring, index,
			StringComparison.OrdinalIgnoreCase);
		if (index == -1)
		{
			// No more matches
			break;
		}
		count++;
	}
	return count;
}
Let’s test again with the same example. The program hangs! What happens? We step through the code using the debugger and we find that the variable index takes the first occurrence at position 0 and at the next iteration it takes the same occurrence again at position 0 and the program enters into an endless loop. This is easy to fix. Just start searching from position index+1 (the next position on the right), not from index:
static int CountOccurrencesIgnoreCase(
	string substring, string text)
{
	int count = 0;
	int index = 0;
	while (true)
	{
		index = text.IndexOf(substring, index + 1,
			StringComparison.OrdinalIgnoreCase);
		if (index == -1)
		{
			// No more matches
			break;
		}
		count++;
	}
	return count;
}
We run the fixed code with the same test. Now the result is incorrect (1 occurrence instead of 2). We again trace the program with the debugger and we find that the first match is at position 12. Immediately we find out why this happens: initially we start from position 1 (index + 1 when index is 0) and we skip the start of the text (position 0).
This is easy to fix:
static int CountOccurrencesIgnoreCase(
	string substring, string text)
{
	int count = 0;
	int index = -1;
	while (true)
	{
		index = text.IndexOf(substring, index + 1,
			StringComparison.OrdinalIgnoreCase);
		if (index == -1)
		{
			// No more matches
			break;
		}
		count++;
	}
	return count;
}
We test again with the same example and finally the result is correct. We take another, more complex test:
Console.WriteLine(CountOccurrencesIgnoreCase(
	"Word", "Word? We have few words: first word, second word," +
	"third word. Passwords: PASSWORD123, @PaSsWoRd, !PASSWORD"));
The result is again correct (9 matches). We test with missing word and the result is again correct (0 matches). This is enough. We assume the method works correctly. Now let’s continue with the next step: read the words.
string[] words = File.ReadAllLines("words.txt");
There is no need to test this code. It is too simple to have bugs. We will test it when we test the entire solution. Let’s not write the main logic of the program which reads the text line by line and counts the occurrences of each of the input words in each of the lines:
int[] occurrences = new int[words.Length];
using (StreamReader text = File.OpenText("text.txt"))
{
	string line;
	while ((line = text.ReadLine()) != null)
	{
		for (int i = 0; i < words.Length; i++)
		{
			string word = words[i];
			int wordOccurrences =
				CountOccurrencesIgnoreCase(word, line);
			occurrences[i] += wordOccurrences;
		}
	}
}
This code definitely should be tested but it will be easier to write the code which prints the results to simplify testing. Let’s do this:
using (StreamWriter result = File.CreateText("result.txt"))
{
	for (int i = 0; i < words.Length; i++)
	{
		result.WriteLine("{0} --> {1}", words[i], occurrences[i]);
	}
}
The complete implementation of the line by line string occurrences counting algorithms looks as follows:
CountSubstringsLineByLine.cs
using System;
using System.IO;

public class CountSubstringsLineByLine
{
	static void Main()
	{
		// Read the input list of words
		string[] words = File.ReadAllLines("words.txt");

		// Process the file line by line
		int[] occurrences = new int[words.Length];
		using (StreamReader text = File.OpenText("text.txt"))
		{
			string line;
			while ((line = text.ReadLine()) != null)
			{
				for (int i = 0; i < words.Length; i++)
				{
					string word = words[i];
					int wordOccurrences =
						CountOccurrencesIgnoreCase(word, line);
					occurrences[i] += wordOccurrences;
				}
			}
		}

		// Print the result
		using (StreamWriter result = File.CreateText("result.txt"))
		{
			for (int i = 0; i < words.Length; i++)
			{
				result.WriteLine("{0} --> {1}",
					words[i], occurrences[i]);
			}
		}
	}

	static int CountOccurrencesIgnoreCase(
		string substring, string text)
	{
		int count = 0;
		int index = -1;
		while (true)
		{
			index = text.IndexOf(substring, index + 1,
				StringComparison.OrdinalIgnoreCase);
			if (index == -1)
			{
				// No more matches
				break;
			}
			count++;
		}
		return count;
	}
}
Testing the Line by Line Algorithm
Now let’s test the entire code of the program. We try our test and it works as expected!
text.txt
Word? We have few words: first word, second word, third word.
Some passwords: PASSWORD123, @PaSsWoRd!456, AAaA, !PASSWORD
words.txt
Word
S
MissingWord
DS
aa
result.txt
Word --> 9
S --> 13
MissingWord --> 0
DS --> 2
aa --> 3
We also try the sample test from the problem description and it also works correctly. We try few other tests and all they work correctly. We try also few border cases like empty text and empty list of words. All these cases are handled correctly. It seems like our line by line word counting algorithm and its implementation correctly solve the problem.
We need to conduct only a performance test but let’s first implement the other algorithm to be able to compare which is faster.
Char by Char Algorithm: Step by Step Implementation
Let’s now implement the char by char string occurrences counting algorithm. We will need a StringBuilder to hold the characters we read and a method to check for a match at the end of the StringBuilder. Let’s define this method first. For more flexibility it can be implemented as extension method to the StringBuilder class (recall how extension methods work from the chapter "Lambda Expressions and LINQ"):
static bool EndsWith(this StringBuilder buffer, string str)
{
	for (int bufIndex = buffer.Length-str.Length, strIndex = 0;
		strIndex < str.Length;
		bufIndex++, strIndex++)
	{
		if (buffer[bufIndex] != str[strIndex])
		{
			return false;
		}
	}
	return true;
}
Let’s test the method with a sample text and its ending:
Console.WriteLine(
	new StringBuilder("say hello").EndsWith("hello"));
This test produces a correct result: True. Let’s test the negative case:
Console.WriteLine(new StringBuilder("abc").EndsWith("xx"));
This test produces a correct result: False. Let’s test what will happen if the ending is longer than the test:
Console.WriteLine(new StringBuilder("a").EndsWith("abcdef"));
We get IndexOutOfRangeException. We found a bug! It is easy to fix – we can return false if the ending string is longer than the text where it should be found:
static bool EndsWith(this StringBuilder buffer, string str)
{
	if (buffer.Length < str.Length)
	{
		return false;
	}
	for (int bufIndex = buffer.Length - str.Length, strIndex = 0;
		strIndex < str.Length;
		bufIndex++, strIndex++)
	{
		if (buffer[bufIndex] != str[strIndex])
		{
			return false;
		}
	}
	return true;
}
We run all the tests again and all of them pass. We assume the above method is correctly implemented.
Now let’s continue with the step-by-step implementation. Let’s implement the reading of the words:
string[] wordsOriginal = File.ReadAllLines("words.txt");
This is the same code from the line by line algorithm and it should work.
Let’s now implement the main program logic which reads the text char by char in a buffer of characters and after each letter checks all input words for matches at the ending of the buffer:
int[] occurrences = new int[words.Length];
using (StreamReader text = File.OpenText("text.txt"))
{
	StringBuilder buffer = new StringBuilder();
	int nextChar;
	while ((nextChar = text.Read()) != -1)
	{
		char ch = (char)nextChar;
		if (char.IsLetter(ch))
		{
			// A letter is found --> check all words for matches
			buffer.Append(ch);
			for (int i = 0; i < words.Length; i++)
			{
				string word = words[i];
				if (buffer.EndsWith(word))
				{
					occurrences[i]++;
				}
			}
		}
		else
		{
			// A non-letter character is found --> clean the buffer
			buffer.Clear();
		}
	}
}
To test the code we will need few lines of code to print the output:
using (StreamWriter result = File.CreateText("result.txt"))
{
	for (int i = 0; i < words.Length; i++)
	{
		result.WriteLine("{0} --> {1}",
			words[i], occurrences[i]);
	}
}
Now the program is completed and we should test it.
Testing the Char by Char Algorithm
Let’s test the entire code of the program. We try our test and it fails. The produced result is incorrect:
Word --> 1
S --> 6
MissingWord --> 0
DS --> 0
aa --> 0
What’s wrong? Maybe the character casing? Do we compare the characters in case-insensitive fashion? No. We found the problem.
How to fix the character casing? Maybe we need to fix the EndsWith(…) method. We search in MSDN and in Internet and we cannot find a method to compare case-insensitively characters. We can do something like this:
if (char.ToLower(ch1) != char.ToLower(ch2)) …
The above code will work but it will convert the characters to lowercase many times, at each character comparison. This may be slow so it is better to lowercase the words and the text preliminary before comparing. If we lowercase the words, they will be printed in lowercase at the output and this will be incorrect. So we need to remember the original words and to make a copy of them in lowercase. Let’s try it. We can use the built-in extension methods from System.Linq to perform the lowercase conversion:
string[] wordsOriginal = File.ReadAllLines("words.txt");
string[] wordsLowercase =
	wordsOriginal.Select(w => w.ToLower()).ToArray();
We need to apply few other fixes and finally we get the following full source code of the char by char algorithm for counting the occurrences of a list of substrings in given text:
CountSubstringsCharByChar.cs
using System.IO;
using System.Linq;
using System.Text;

public static class CountSubstringsCharByChar
{
	static void Main()
	{
		// Read the input list of words
		string[] wordsOriginal = File.ReadAllLines("words.txt");
		string[] wordsLowercase =
			wordsOriginal.Select(w => w.ToLower()).ToArray();

		// Process the file char by char
		int[] occurrences = new int[wordsLowercase.Length];
		StringBuilder buffer = new StringBuilder();
		using (StreamReader text = File.OpenText("text.txt"))
		{
			int nextChar;
			while ((nextChar = text.Read()) != -1)
			{
				char ch = (char)nextChar;
				if (char.IsLetter(ch))
				{
					// A letter is found --> check all words for matches
					ch = char.ToLower(ch);
					buffer.Append(ch);
					for (int i = 0; i < wordsLowercase.Length; i++)
					{
						string word = wordsLowercase[i];
						if (buffer.EndsWith(word))
						{
							occurrences[i]++;
						}
					}
				}
				else
				{
					// A non-letter is found --> clean the buffer
					buffer.Clear();
				}
			}
		}

		// Print the result
		using (StreamWriter result = File.CreateText("result.txt"))
		{
			for (int i = 0; i < wordsOriginal.Length; i++)
			{
				result.WriteLine("{0} --> {1}",
					wordsOriginal[i], occurrences[i]);
			}
		}
	}

	static bool EndsWith(this StringBuilder buffer, string str)
	{
		if (buffer.Length < str.Length)
		{
			return false;
		}
		for (int bufIndex = buffer.Length-str.Length, strIndex = 0;
			strIndex < str.Length;
			bufIndex++, strIndex++)
		{
			if (buffer[bufIndex] != str[strIndex])
			{
				return false;
			}
		}
		return true;
	}
}
We need to test again with our example. Now the program works. The result is correct:
Word --> 9
S --> 13
MissingWord --> 0
DS --> 2
aa --> 3
We test with all other tests we have (the test from the problem statement, the border cases, etc.) and all of them pass correctly.
Testing for Performance
Now it is time to test for performance both our solutions. We need a big test. We can do it with copy-paste. It is easy to copy-paste the text from our text example 10,000 times and its words 100 times. The repeating words might cause inaccuracies in performance measuring so we manually replace the last 26 words with the letters from "a" to "z". We also play a bit with the rectangular selection in Visual Studio ([Alt] + mouse selection) and we insert the alphabet as a vertical column in few other places. All this will result in 20,000 lines of text (1.2 MB) and 500 words (3 KB).
To measure the execution time we add two lines of code – before the first line of the Main() method and after the last line of the Main() method:
static void Main()
{
	DateTime startTime = DateTime.Now;
	// The original code goes here
	Console.WriteLine(DateTime.Now - startTime);
}
Now we execute first the line by line algorithm and it seems not very fast. On average computer from 2008 it prints the following result:
00:01:33.6393559
After that we execute the char by char algorithm. It produces the following output:
00:00:18.1080357
Unbelievable! Our char by char processing algorithm is more than 5 times faster than the line by line processing algorithm! But … it still is slow! 18 seconds for 1 MB file is not fast. How about processing 500 MB input and search for 10,000 words?
Invent a Better Idea (Again)
If we are at exam, we could decide whether to take the risk to submit the char by char solution or spend more time to think of faster algorithm. This depends on how much time we have to the end of the exam and how much problems we have already solved, how hard are the unsolved problems, etc. Suppose we have enough time and we want to think more.
What makes our solution slow? If we have 500 words, we check for each of them at each character. We do 500 * length(text) string comparisons. The text is scanned only once (char by char). This cannot be improved, right? If we do not scan the entire text, we will be unable to find all occurrences. So if we want to improve the performance, we should look how to check the words faster after each character is read, right? For 500 words we perform 500 checks after each character is read. This is slow! Can’t we do it faster?
In fact we perform a kind of searching for a matching word in a list of words? From the data structures we know that this takes linear time. Also, from the data structures we know that the fastest data structure for searching is the hash-table. OK, can’t we use a hash table? Instead of searching the words by trying each of them one by one, can’t we directly find the word we need through a hast-table lookup?
We take a sheet of paper and the pencil and we start making sketches and thinking. Suppose we have the text "passwords" and the word "s". We can check the word that we obtain when we append the letters one after another:
p, pa, pas, pass, passw, passwo, passwor, password, passwords
In this case we will not match the word "s", right. In fact, when we find a word in the text, we should check all its substrings in the hash table. For example if the text is "password", all its substrings are:
p, pa, a, pas, as, s, pass, ass, ss, s, passw, assw, ssw, sw, w, passwo, asswo, sswo, swo, wo, o, passwor, asswor, sswor, swor, wor, or, r, password, assword, ssword, sword, word, ord, rd, d, passwords, asswords, sswords, swords, words, ords, rds, ds, s
There are 45 substrings of the word "password". In a word of n characters we have n*(n+1)/2 substrings. This will work well with short words (e.g. 3-4 characters) and will be slow for the long words (e.g. 15-20 characters).
We get into another idea? This multi-pattern matching problem should have a standard solution. Why don’t we search for it in Internet? We try to search for "multi-pattern matching algorithm" in Google and after exploring the first few results we learn about the "Aho-Corasick string matching algorithm". Once we know the algorithm name we search for "Aho Corasick C#" and we find a nice C# implementation: https://github.com/tupunco/Tup.AhoCorasick. The theory says that after we have a new idea, we should check it for correctness. The best way to check this idea is by putting the code we found in action. In fact we do not implement the algorithm. We just try to adopt it to solve the problem we have.
Counting Substrings with the Aho-Corasick Algorithm
From the open-source implementation of the Aho-Corasick multi-pattern string matching algorithm mentioned above we can take the class AhoCorasickSearch and put it in action. We write a new solution of the substring counting problem based on what we have learned from the previous solutions. We find all matches of all words by the SearchAll(…) method of the AhoCorasickSearch class. Then we use a hash-table to count the number of occurrences for each of the words. To ensure we ignore the character casing we convert the text and the words into lowercase. This is the code:
CountSubstringsAhoCorasick.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;

class CountSubstringsAhoCorasick
{
	static void Main()
	{
		DateTime startTime = DateTime.Now;

		// Read the input list of words
		string[] wordsOriginal = File.ReadAllLines("words.txt");
		string[] wordsLowercase =
			wordsOriginal.Select(w => w.ToLower()).ToArray();

		// Read the text
		string text = File.ReadAllText("text.txt").ToLower();

		// Find all word matches and count them
		var search = new AhoCorasickSearch();
		var matches = search.SearchAll(text, wordsLowercase);
		Dictionary<string, int> occurrences =
			new Dictionary<string, int>();
		foreach (string word in wordsLowercase)
		{
			occurrences[word] = 0;
		}
		foreach (var match in matches)
		{
			string word = match.Match;
			occurrences[word]++;
		}

		// Print the result
		using (StreamWriter result = File.CreateText("result.txt"))
		{
			foreach (string word in wordsOriginal)
			{
				result.WriteLine("{0} --> {1}", word,
					occurrences[word.ToLower()]);
			}
		}

		Console.WriteLine(DateTime.Now - startTime);
	}
}
We test the above code with all tests we already have and it seems to work correctly. We try the performance test and this time we can be amazed by its speed:
00:00:00.6540374
It runs really fast. This is the solution we needed and if we are allowed to use Internet at the exam, the best way to start when we have a standard well-known problem is to look for a well-known solution.
Problem 3: School
Students, which are studying in a school, are separated into groups. Each of the groups has a teacher. The following information is kept for the students: first name and last name. The following information is kept for the groups: name, a list of students and teacher. The following information is kept for the teachers: first name, last name and a list of groups he is teaching. Each teacher can teach more than one group. The following information is kept for the school: name, list of the teachers, list of the groups and list of the students. Your task is to:
	Design a set of classes and relationships between them to model the school, its students, teachers and groups.
	Implement functionality for add / edit / delete teachers, students, groups and their properties.
	Implement functionality for printing in human-readable form the school, the teachers, the students, the groups and their properties.
	Write a sample test program, which demonstrates the work of the implemented classes and methods.
Example of school with teachers, students and groups:
School "Freedom". Teachers: Tom Johnson, Elizabeth Hall.
Group "English": David Russell, Nicholas Grant, Emma Fletcher, John Brown, Emily Cooper, teacher Elizabeth Hall.
Group "French": Kevin Simmons, Ian Hayes, teacher Elizabeth Hall.
Group "Informatics": Jessica Carter, Andrew Cooper, Ashley Moore, Olivia Adams, Jonathan Smith, teacher Tom Johnson.
Start Thinking on the Problem
This is a good example of an exam assignment the purpose of which is to test your abilities to use object-oriented programming (OOP) for modeling problems from the real life, design classes and relationships between them as well as working with collections.
All we need to solve this problem is to use our object-oriented modeling skills that we have gained from chapter "Object-Oriented Programming Principles", especially from the section "Object-Oriented Modeling (OOM)".
Inventing an Idea for Solution
In this task there is nothing complex to invent. It is not algorithmic and there is not anything to be thought up. We must define a class for each of the described in the problem description objects (students, teachers, school students, groups, school, etc.) and after that we should define in each class properties to describe its characteristics and methods to implements the actions the class can do, e.g. printing in human-readable form. That’s all.
Following the directions from the section "Object-Oriented Modeling (OOM)" we could identify the nouns in the problem description. Some of them should be modeled as classes; some of them as properties; and some of them may not be important and could be disregarded.
Reading the text from the problem description and analyzing the nouns, we could come to the idea to model the school through defining few interrelated classes: Student, Group, Teacher and School. For testing the classes we could create a class SchoolTest, which will create few objects of each class and will demonstrate their work in action.
Checking the Idea
We will not check the idea because there is nothing to be proven or checked. We need to write few classes to model a real-world situation: a school with students, teachers and groups.
Dividing the Problem into Subproblems
The implementation of each of the classes we already identified can be considered a subproblem of the given school modeling problem. Thus we have the following subproblems:
	Class for the students – Student. Students will have first name, last name and a method for printing in human-readable form – ToString().
	Class for the groups – Group. Groups will have a name, a teacher and a list of students. It will also have ŕ method for printing in human-readable form.
	Class for the teachers – Teacher. Teachers will have first name, last name and a list of groups, as well as ŕ method for printing in human-readable form.
	Class for the school – School. It will have a name and will hold all students, all teachers and all groups.
	Class for testing the other classes – SchoolTest. It will create a school with a few students, a few groups holding subsets of the students and a few teachers. It will assign one teacher per group and a few groups per teacher accordingly. Finally the class will print the school and all its teachers, groups and students.
Think about the Data Structures
The data structures, needed for this problem, are of two main groups: classes and relationships between the classes. Classes will be classes. We have nothing to decide here. The interesting part is how to describe the relationships between the classes, e.g. when a group has a collection of students.
To describe a relationship (link) between two classes we can use an array. With an array we have access to its elements by index, but once it is created we will not be able to add or delete items (arrays have a fixed size). This makes it uncomfortable for our problem, because we don’t know how many students we will have in the school and more students can be added or removed after the school is once created.
List<T> seems more comfortable. It has the advantages of an array and also has a variable length – it is easy to add or delete elements. List<T> can hold lists of students (inside the school and inside a group), lists of teachers (inside a school) and lists of groups (inside a school and inside a teacher).
So far it seems List<T> is the most appropriate for holding aggregations of objects inside another object. To be convinced we will analyze a few more data structures. For example hash-table – it is not appropriate in this case, because the school, teachers, students and groups are not of a key-value type. A hash-table would be appropriate if we need to search a student by its unique student ID, but this is not the case. Structures like stack and queue are inappropriate – we do not have LIFO or FIFO behavior.
The structure "set" and its implementation HashSet<T> may be used when we need to have uniqueness for given key. It would be good sometimes to use this structure to avoid duplicates. We must recall that HashSet<T> requires the methods GetHashCode() and Equals(…) to be correctly defined by the T type. Shall we use sets and where? To answer this question we need to recall the problem description. What is says? We need to design a set of classes to model the school, its students, teachers and groups and functionality for add / edit / delete teachers, students, groups and their properties. The easiest way to implement it is to hold a list of students in the school, a list of groups for each teacher, etc. Lists are easier to implement. Sets give uniqueness, but require Equals() and GetHashCode(). Sets need more effort to be used. So we may use lists to simplify our work.
According to the requirements the school should allow add / edit / delete of students, teachers and groups. The easiest way to implement this is to expose the lists of students, teachers and groups as public properties. List<T> already have methods for add and delete of its elements and its elements are accessible by index and editable. It does the job.
Finally we choose to use List<T> for all aggregations in our classes and we will expose all the class members as properties with read and write access. We do not have a good reason to restrict the access to the members or implement immutable behavior.
Implementation: Step by Step
It’s appropriate to start the implementation with the class Student because it does not depend on any of the other classes.
Step 1: Class Student
In the problem definition we have only two fields representing the first name and the last name of a student. We may add a property Name, which returns a string with the full name of the student and a ToString() implementation to print the student in human-readable form. We might define the class Student as follows:
Student.cs
public class Student
{
	public string FirstName { get; set; }
	public string LastName { get; set; }

	public Student(string firstName, string lastName)
	{
		this.FirstName = firstName;
		this.LastName = lastName;
	}

	public string Name
	{
		get
		{
			return this.FirstName + " " + this.LastName;
		}
	}

	public override string ToString()
	{
		return "Student: " + this.Name;
	}
}
We want to allow the class members to be editable so we define the FirstName and LastName as public read-write properties.
Testing the Class Student
Before continuing forward we want to test the class Student to be sure it is correct. Let’s create a testing class with a Main() method and create a student in it and print the student:
class TestSchool
{
	static void Main()
	{
		Student studentPeter = new Student("Peter", "Lee");
		Console.WriteLine(studentPeter);
	}
}
We run the testing program and we get a correct result:
Student: Peter Lee
Now we can continue with the implementation of the other classes.
Step 2: Class Group
The next class we can define is Group. We choose it because the only one required for its definition is the class Student. The properties, which we will define, are the name of the group, a list of the students, which belong to the group, and a teacher who teaches the group. To implement the list with of the students we will use List<Student>. We will add a ToString() method to enable printing the group in a human-readable text form. Let’s see the implementation of the class Group:
Group.cs
using System.Collections.Generic;

public class Group
{
	public string Name { get; set; }
	public List<Student> Students { get; set; }

	public Group(string name)
	{
		this.Name = name;
		this.Students = new List<Student>();
	}

	public override string ToString()
	{
		StringBuilder groupAsString = new StringBuilder();
		groupAsString.AppendLine("Group name: " + this.Name);
		groupAsString.Append("Students in the group: " +
			this.Students);
		return groupAsString.ToString();
	}
}
It is important when we create a group to assign an empty list of students to it. If we leave the list of students unassigned, it will be null and when we try to add a student, we will get an exception.
Testing the Class Group
Let’s now test the Group class. Let’s create a sample group, add few students to it and print the group at the console:
static void Main()
{
	Student studentPeter = new Student("Peter", "Lee");
	Student studentMaria = new Student("Maria", "Steward");
	Group groupEnglish = new Group("English language course");
	groupEnglish.Students.Add(studentPeter);
	groupEnglish.Students.Add(studentMaria);
	Console.WriteLine(groupEnglish);
}
We run the above testing code and we find a bug:
Group name: English language course
Students in the group: System.Collections.Generic.List`1[Student]
It seems like the list of students is printed incorrectly. It is easy to find why. The List<T> class does not correctly implement ToString() and we need to use another way to print a list of students. We can do this with a for-loop but let’s try something shorter and more elegant:
using System.Linq;
…
groupAsString.Append("Students in the group: " +
	string.Join(", ", this.Students.Select(s => s.Name)));
The above code uses an extension method and a lambda expression to select all students’ names as IEnumerable<string> and then combines them into a string using a comma as separator. Let’s test the Group class again after the fix:
Group name: English language course
Students in the group: Peter Lee, Maria Steward
The group class now works correctly.
Let’s think a bit: who is teaching the students in the group? We should have a teacher, right. Let’s try to add the simplest possible class Teacher and define a property of it in the Group class:
public class Teacher
{
	public string FirstName { get; set; }
	public string LastName { get; set; }

	public string Name
	{
		get
		{
			return this.FirstName + ' ' + this.LastName;
		}
	}
}

public class Group
{
	public string Name { get; set; }
	public List<Student> Students { get; set; }
	public Teacher Teacher { get; set; }

	public Group(string name)
	{
		this.Name = name;
		this.Students = new List<Student>();
	}

	public override string ToString()
	{
		StringBuilder groupAsString = new StringBuilder();
		groupAsString.AppendLine("Group name: " + this.Name);
		groupAsString.Append("Students in the group: " +
			string.Join(", ", this.Students.Select(s => s.Name)));
		groupAsString.Append("\nGroup teacher: " +
			this.Teacher.Name);
		return groupAsString.ToString();
	}
}
Let’s test again with our sample groups of two students studying English:
Student studentPeter = new Student("Peter", "Lee");
Student studentMaria = new Student("Maria", "Steward");
Group groupEnglish = new Group("English language course");
groupEnglish.Students.Add(studentPeter);
groupEnglish.Students.Add(studentMaria);
Console.WriteLine(groupEnglish);
We find another bug:
Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.
   at Group.ToString() …
We step through the debugger and we see that we try to print the teacher’s name but there is no teacher (it is null). This is easy to fix. We could check whether the teacher exists prior to printing it in the ToString() method:
if (this.Teacher != null)
{
	groupAsString.Append("\nGroup teacher: " +	this.Teacher.Name);
}
Let’s test again after the fix. Now we get the following correct result:
Group name: English language course
Students in the group: Peter Lee, Maria Steward
Let’s now add a teacher to the testing group and check what happens:
Student studentPeter = new Student("Peter", "Lee");
Student studentMaria = new Student("Maria", "Steward");
Group groupEnglish = new Group("English language course");
groupEnglish.Students.Add(studentPeter);
groupEnglish.Students.Add(studentMaria);
Teacher teacherNatasha = new Teacher() {
	FirstName = "Natasha", LastName = "Walters" };
groupEnglish.Teacher = teacherNatasha;
Console.WriteLine(groupEnglish);
The result is correct:
Group name: English language course
Students in the group: Peter Lee, Maria Steward
Group teacher: Natasha Walters
Now the Group class works correctly. We can continue with the next class.
Step 3: Class Teacher
Let’s define the class Teacher. We already have some piece of it, but let’s define it in a better way. The teacher should have first name, last name and a list of group he teaches and should be printable in human-readable form. We can define it directly repeating the logic in the Group class:
Teacher.cs
public class Teacher
{
	public string FirstName { get; set; }
	public string LastName { get; set; }
	public List<Group> Groups { get; set; }

	public Teacher(string firstName, string lastName)
	{
		this.FirstName = firstName;
		this.LastName = lastName;
		this.Groups = new List<Group>();
	}

	public string Name
	{
		get
		{
			return this.FirstName + " " + this.LastName;
		}
	}

	public override string ToString()
	{
		StringBuilder teacherAsString = new StringBuilder();
		teacherAsString.AppendLine("Teacher name: " + this.Name);
		teacherAsString.Append("Groups of this teacher: " +
			string.Join(", ", this.Groups.Select(s => s.Name)));
		return teacherAsString.ToString();
	}
}
Like in the class Group, it is important to create and empty list of groups instead of leaving the Groups property uninitialized.
Testing the Class Teacher
Before going further, let’s test the class Teacher. We can create a teacher with a few groups and print it at the console:
static void Main()
{
	Teacher teacherNatasha = new Teacher("Natasha", "Walters");
	Group groupEnglish = new Group("English language");
	Group groupFrench= new Group("French language");
	teacherNatasha.Groups.Add(groupEnglish);
	teacherNatasha.Groups.Add(groupFrench);
	Console.WriteLine(teacherNatasha);
}
The result is correct:
Teacher name: Natasha Walters
Groups of this teacher: English language, French language
This was expected. We just repeated the same logic like in the Group class which was already tested and all bugs in it was fixed. We found once again how important is to write the code step by step with testing and bug-fixing after each step, right? The bug with incorrectly printing the list of students would have been repeated when printing the list of groups, right?
Step 4: Class School
We finish our object model with the definition of the class School, which uses all of the classes we already defined. It should have a name and should hold a list of students, a list of teachers and a list of groups:
public class School
{
	public string Name { get; set; }
	public List<Teacher> Teachers { get; set; }
	public List<Group> Groups { get; set; }
	public List<Student> Students { get; set; }

	public School(string name)
	{
		this.Name = name;
		this.Teachers = new List<Teacher>();
		this.Groups = new List<Group>();
		this.Students = new List<Student>();
	}
}
Before testing the class, let’s think what the class School is expected to do. It should hold the students, teachers and groups and should be printable at the console, right? If we print the school, what should be printed? Maybe we should print its name, all its students (with their inner details), all its teachers (with their inner details) and all its groups (with their inner details). Let’s try to define the ToString() method for the class School:
public override string ToString()
{
	StringBuilder schoolAsString = new StringBuilder();
	schoolAsString.AppendLine("School name: " + this.Name);
	schoolAsString.AppendLine("Teachers: " +
		string.Join(", ", this.Teachers.Select(s => s.Name)));
	schoolAsString.AppendLine("Students: " +
		string.Join(", ", this.Students.Select(s => s.Name)));
	schoolAsString.Append("Groups: " +
		string.Join(", ", this.Groups.Select(s => s.Name)));
	foreach (var teacher in this.Teachers)
	{
		schoolAsString.Append("\n---\n");
		schoolAsString.Append(teacher);
	}
	foreach (var group in this.Groups)
	{
		schoolAsString.Append("\n---\n");
		schoolAsString.Append(group);
	}
	foreach (var student in this.Students)
	{
		schoolAsString.Append("\n---\n");
		schoolAsString.Append(student);
	}
	return schoolAsString.ToString();
}
We shall not test the class School, because this will be the main purpose of our last class: SchoolTest.
Step 5: Class SchoolTest
The final thing is the implementation of the class SchoolTest the purpose of which is to demonstrate all the classes we have defined (Student, Group, Teacher and School) and their methods and properties. This is our last subproblem. For the demonstration we create a sample school with a few students, a few teachers and a few groups and we print it:
SchoolTest.cs
class TestSchool
{
	static void Main()
	{
		// Create a few students
		Student studentPeter = new Student("Peter", "Lee");
		Student studentGeorge = new Student("George", "Redwood");
		Student studentMaria = new Student("Maria", "Steward");
		Student studentMike = new Student("Michael", "Robinson");

		// Create a group and add a few students to it
		Group groupEnglish = new Group("English language course");
		groupEnglish.Students.Add(studentPeter);
		groupEnglish.Students.Add(studentMike);
		groupEnglish.Students.Add(studentMaria);
		groupEnglish.Students.Add(studentGeorge);

		// Create a group and add a few students to it
		Group groupJava = new Group("Java Programming course");
		groupJava.Students.Add(studentMaria);
		groupJava.Students.Add(studentPeter);

		// Create a teacher and assign it to few groups
		Teacher teacherNatasha = new Teacher("Natasha", "Walters");
		teacherNatasha.Groups.Add(groupEnglish);
		teacherNatasha.Groups.Add(groupJava);
		groupEnglish.Teacher = teacherNatasha;
		groupJava.Teacher = teacherNatasha;

		// Create another teacher and a group he teaches
		Teacher teacherSteve = new Teacher("Steve", "Porter");
		Group groupHTML = new Group("HTML course");
		groupHTML.Students.Add(studentMike);
		groupHTML.Students.Add(studentMaria);
		groupHTML.Teacher = teacherSteve;
		teacherSteve.Groups.Add(groupHTML);

		// Create a school with few students, groups and teachers
		School school = new School("Saint George High School");
		school.Students.Add(studentPeter);
		school.Students.Add(studentGeorge);
		school.Students.Add(studentMaria);
		school.Students.Add(studentMike);
		school.Groups.Add(groupEnglish);
		school.Groups.Add(groupJava);
		school.Groups.Add(groupHTML);
		school.Teachers.Add(teacherNatasha);
		school.Teachers.Add(teacherSteve);

		// Modify some of the groups, student and teachers
		groupEnglish.Name = "Advanced English";
		groupEnglish.Students.RemoveAt(0);
		studentPeter.LastName = "White";
		teacherNatasha.LastName = "Hudson";

		// Print the school
		Console.WriteLine(school);
	}
}
We run the program and we get the expected result:
School name: Saint George High School
Teachers: Natasha Hudson, Steve Porter
Students: Peter White, George Redwood, Maria Steward, Michael Robinson
Groups: Advanced English, Java Programming course, HTML course
---
Teacher name: Natasha Hudson
Groups of this teacher: Advanced English, Java Programming course
---
Teacher name: Steve Porter
Groups of this teacher: HTML course
---
Group name: Advanced English
Students in the group: Michael Robinson, Maria Steward, George Redwood
Group teacher: Natasha Hudson
---
Group name: Java Programming course
Students in the group: Maria Steward, Peter White
Group teacher: Natasha Hudson
---
Group name: HTML course
Students in the group: Michael Robinson, Maria Steward
Group teacher: Steve Porter
---
Student: Peter White
---
Student: George Redwood
---
Student: Maria Steward
---
Student: Michael Robinson
Of course in real life programs do not start from the first time, but in this task the mistakes you could make are trivial so there’s no point in discussing them. All classes are implemented and tested. We are almost finished with this problem.
Testing the Solution
As usually, it remains to test if the entire solution is working correctly. We’ve already done this. We tested all the classes in their nominal case.
We can do some tests with the border cases, for instance a group without students, empty school, etc. It seems like these cases work correctly. We might test a student without a name, but it is unclear whether the class should keep itself of incorrect names and what is a correct name. We can leave these classes without checks for the names. It will be a responsibility of their caller to put correct names though their constructors and properties. The problem description says nothing about this.
It is interesting how we delete a student. In our current implementation, if we delete a student, we will need to remove it from the school and to remove it from all groups he belongs to. The removal itself will require the student to have the Equals() method defined correctly or we should compare students by hand (property by property). It is unclear from the problem description how exactly the "delete student" operation should work.
We assume we don’t have time and we submit the solution in its current state without efficient delete operation. Sometimes it takes too much time to fix something and it is better to leave it in not perfect form. Below is the full source code of the solution of the school modeling problem:
School.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Student
{
	public string FirstName { get; set; }
	public string LastName { get; set; }

	public Student(string firstName, string lastName)
	{
		this.FirstName = firstName;
		this.LastName = lastName;
	}

	public string Name
	{
		get
		{
			return this.FirstName + " " + this.LastName;
		}
	}

	public override string ToString()
	{
		return "Student: " + this.Name;
	}
}


public class Group
{
	public string Name { get; set; }
	public List<Student> Students { get; set; }
	public Teacher Teacher { get; set; }

	public Group(string name)
	{
		this.Name = name;
		this.Students = new List<Student>();
	}

	public override string ToString()
	{
		StringBuilder groupAsString = new StringBuilder();
		groupAsString.AppendLine("Group name: " + this.Name);
		groupAsString.Append("Students in the group: " +
			string.Join(", ", this.Students.Select(s => s.Name)));
		if (this.Teacher != null)
		{
			groupAsString.Append("\nGroup teacher: " +
				this.Teacher.Name);
		}
		return groupAsString.ToString();
	}
}

public class Teacher
{
	public string FirstName { get; set; }
	public string LastName { get; set; }
	public List<Group> Groups { get; set; }

	public Teacher(string firstName, string lastName)
	{
		this.FirstName = firstName;
		this.LastName = lastName;
		this.Groups = new List<Group>();
	}

	public string Name
	{
		get
		{
			return this.FirstName + " " + this.LastName;
		}
	}

	public override string ToString()
	{
		StringBuilder teacherAsString = new StringBuilder();
		teacherAsString.AppendLine("Teacher name: " + this.Name);
		teacherAsString.Append("Groups of this teacher: " +
			string.Join(", ", this.Groups.Select(s => s.Name)));
		return teacherAsString.ToString();
	}
}

public class School
{
	public string Name { get; set; }
	public List<Teacher> Teachers { get; set; }
	public List<Group> Groups { get; set; }
	public List<Student> Students { get; set; }

	public School(string name)
	{
		this.Name = name;
		this.Teachers = new List<Teacher>();
		this.Groups = new List<Group>();
		this.Students = new List<Student>();
	}

	public override string ToString()
	{
		StringBuilder schoolAsString = new StringBuilder();
		schoolAsString.AppendLine("School name: " + this.Name);
		schoolAsString.AppendLine("Teachers: " +
			string.Join(", ", this.Teachers.Select(s => s.Name)));
		schoolAsString.AppendLine("Students: " +
			string.Join(", ", this.Students.Select(s => s.Name)));
		schoolAsString.Append("Groups: " +
			string.Join(", ", this.Groups.Select(s => s.Name)));
		foreach (var teacher in this.Teachers)
		{
			schoolAsString.Append("\n---\n");
			schoolAsString.Append(teacher);
		}
		foreach (var group in this.Groups)
		{
			schoolAsString.Append("\n---\n");
			schoolAsString.Append(group);
		}
		foreach (var student in this.Students)
		{
			schoolAsString.Append("\n---\n");
			schoolAsString.Append(student);
		}
		return schoolAsString.ToString();
	}
}

class TestSchool
{
	static void Main()
	{
		// Create a few students
		Student studentPeter = new Student("Peter", "Lee");
		Student studentGeorge = new Student("George", "Redwood");
		Student studentMaria = new Student("Maria", "Steward");
		Student studentMike = new Student("Michael", "Robinson");

		// Create a group and add a few students to it
		Group groupEnglish = new Group("English language course");
		groupEnglish.Students.Add(studentPeter);
		groupEnglish.Students.Add(studentMike);
		groupEnglish.Students.Add(studentMaria);
		groupEnglish.Students.Add(studentGeorge);

		// Create a group and add a few students to it
		Group groupJava = new Group("Java Programming course");
		groupJava.Students.Add(studentMaria);
		groupJava.Students.Add(studentPeter);

		// Create a teacher and assign it to few groups
		Teacher teacherNatasha = new Teacher("Natasha", "Walters");
		teacherNatasha.Groups.Add(groupEnglish);
		teacherNatasha.Groups.Add(groupJava);
		groupEnglish.Teacher = teacherNatasha;
		groupJava.Teacher = teacherNatasha;

		// Create another teacher and a group he teaches
		Teacher teacherSteve = new Teacher("Steve", "Porter");
		Group groupHTML = new Group("HTML course");
		groupHTML.Students.Add(studentMike);
		groupHTML.Students.Add(studentMaria);
		groupHTML.Teacher = teacherSteve;
		teacherSteve.Groups.Add(groupHTML);

		// Create a school with few students, groups and teachers
		School school = new School("Saint George High School");
		school.Students.Add(studentPeter);
		school.Students.Add(studentGeorge);
		school.Students.Add(studentMaria);
		school.Students.Add(studentMike);
		school.Groups.Add(groupEnglish);
		school.Groups.Add(groupJava);
		school.Groups.Add(groupHTML);
		school.Teachers.Add(teacherNatasha);
		school.Teachers.Add(teacherSteve);

		// Modify some of the groups, student and teachers
		groupEnglish.Name = "Advanced English";
		groupEnglish.Students.RemoveAt(0);
		studentPeter.LastName = "White";
		teacherNatasha.LastName = "Hudson";

		// Print the school
		Console.WriteLine(school);
	}
}
We will not run performance tests because the task is not of a computational nature which requires a fast algorithm. Operations that could be slow are deleting of elements from a collection. Creating objects, assigning their properties and adding elements to their collections of child elements are all fast operations. Only the deletion could be slow. We could improve its performance by using HashSet<T> instead of List<T> in all aggregations. We leave this to the reader.
Let’s make just one more note. Why we did not notice the performance problem with deleting elements earlier? Let’s recall how we proceeded with solving this problem. After thinking about the data structures we had to thing about the performance right? Did we do this step? We omitted this step and we found the problem too late. The conclusion is: follow the guidelines for problem solving. They are very wise.
Exercises
	Write a program, which prints a square spiral matrix beginning from the number 1 in the upper right corner and moving clockwise. Examples for N=3 and N=4:
 
	Write a program, which counts the phrases in a text file. Any sequence of characters could be given as phrase for counting, even sequences containing separators. For instance in the text "I am a student in Sofia" the phrases "s", "stu", "a" and "I am" are found respectively 2, 1, 3 and 1 times.
	Model with OOP the file system of a computer running Windows. We have devices, directories and files. The devices are for instance floppy disk, HDD, CD-ROM, etc. They have a name and a tree of directories and files. Each directory has a name, date of last change and list of files and directories, which it holds. Each file has a name, date of creation, date of last change and content. Each file is placed in one of the directories. Each file can be text or binary. Text files contain text (string), and the binary ones – sequence of bytes (byte[]). Create a class, which tests the other classes and demonstrates how we can build a model for devices, directories and files in the computer.
	Using the classes from the previous task write a program which takes the real file system from your computer and loads it in your classes (just the names of the devices, directories and files, without the content of the files because you will run out of memory).
Solutions and Guidelines
	The task is analogical to the first task of the sample exam. You can modify the sample solution given above.
	You may read the text char by char and after each char to append it to the current buffer buf and check each of the searched word for a match with EndsWith() in the buffer’s end. Of course you cannot use efficiently hash-table and you will have a loop for each letter from the text, which is not the fastest solution. This is a modification of the "char by char algorithm for word counting".
Implementing a faster solution needs to adapt the Aho-Corasick algorithm. Try to play with it and modify the code from the section "Counting Substrings with the Aho-Corasick Algorithm".
	The problem is analogical with the "School" problem from the sample exam and it can be solved by using the same approach. Define classes Device, Directory, File, ComputerStorage and ComputerStorageTest. Think of what properties each of these classes has and what are the relationships between the classes. Create a base abstract class File and inherit it from TextFile and BinaryFile. Test your code with sample hierarchy of devices, files and folders. Note: a file can be listed in more than one directory at the same time (unlike in the file system).
	Use the class System.IO.Directory and its static methods GetFiles(), GetDirectories() and GetLogicalDrives(). Traverse the files system using the BFS or DFS graph traversal algorithm. Load partially the content of long files (e.g. the first 128 bytes / chars) to save memory.

	
Conclusion

If you are reading this conclusion and if you have read carefully the entire book, then please accept our well-deserved congratulations! We are certain that you have earned valuable knowledge in the principles of programming that will stick for life. Even if the years pass, even if technology evolves and computers are far from their current state, the fundamental knowledge of data structures in programming and the algorithmic way of thinking as well as the experience gained in solving programming problems will always aid you, if you work in the field of information technology.
Did You Solve All Problems?
If you have solved all problems from all chapters, in addition to reading carefully the entire book, then you can proudly declare yourself a programmer. Whatever technology you pick up from now on will be child’s play. Now that you have grasped the basics and fundamental principles of programming, you’ll easily learn to use databases and SQL, develop Web applications and server-side software (e.g. with ASP.NET and WCF), write HTML5 applications, develop for mobile devices and whatever else you’d like. You have a great advantage over the majority of programmers who do not know what a hash-table is, how searching in a tree works and what algorithm complexity is. If you have really made the tremendous effort to solve all problems from the book, then you have most certainly reached a level of fundamental understanding of the concepts of programming and a programmer’s way of thinking, which will aid you for many years.
Have You Encountered Difficulties with the Exercises?
If you haven’t solved all exercise problems or at least the vast majority of them, turn back and solve them! Yes, it does take a lot of time, but that’s the way to learn programming – with a lot of work and effort. You won’t learn programming without practicing it diligently!
If you have encountered difficulties, use the discussion forum of the courses on fundamentals of programming at the Software Academy, which follow this book: http://forums.academy.telerik.com. Several hundred people have taken these courses and the majority of them have solved all problems and shared their solutions. So, examine them, try solving the problems and then try again without using any guides.
Many lectures and video tutorials have been uploaded on the book’s Web site (http://www.introprogramming.info). We have free PowerPoint slides and videos in English and Bulgarian for each chapter of the book. They will be of great use to you, especially if this is the first time you are getting involved in programming. If you decide to teach C#, programming or data structures and algorithms, the slides and exercises will help you focus on the training and save time preparing the content. It’s worth checking them out.
Also, check out the free courses available from Telerik Software Academy (http://academy.telerik.com). All of their lectures' study materials and video recordings have been made available for free download on each course’s respective Web site. These courses are an excellent follow-up to your progress as software engineers and professionals in software development. All materials (lecture slides, exercises, demos) and some video recordings, both at this book’s and at Telerik Academy’s Web site, are available in English.
How Do You Proceed After Reading the Book?
Maybe you are wondering how you should continue your development as a software engineer. You’ve laid solid foundations with this book, so it won’t be difficult. We can give you the following instructions:
	Choose a language and a programming platform, e. g. C# + .NET Framework, Java + Java EE, Ruby + Rails or PHP + CakePHP. There’s nothing wrong with giving up C#. Focus on the technologies your platform supports; you’ll learn the corresponding language quickly. For example, if you choose Objective-C and iPhone / iPad / iOS / Xcode programming, the algorithmic way of thinking you have acquired with this book will help you make progress.
	Read a book on databases and learn how to model your application’s data using tables and relations between them. Learn how to build queries for selecting and updating data in SQL. Learn how to work with a database server, like Oracle, SQL Server or MySQL. The next natural course of action is to acquire some ORM technology, like ADO.NET Entity Framework, Hibernate or JPA. You might also try the NoSQL database systems available in the public clouds.
	Acquire a technology for building dynamic Web sites. Start with a book on HTML, CSS, JavaScript and jQuery, or with our free course on HTML5, CSS3 and JavaScript (http://html5course.telerik.com). Then explore the web development tools your platform supports, such as ASP.NET Web Forms / ASP.NET MVC using the .NET Platform and C#, Servlets / JSP / JSF using the Java platform, CakePHP / Symfony / Zend Framework with PHP, Ruby on Rails using Ruby or Django using Python. Learn how to make simple Web sites with dynamic content. Try creating a Web application for mobile devices using some mobile UI toolkit.
	Learn to write mobile applications. Start for example with HTML5 and Cordova, try to deploy your apps in the large marketplaces maintained by Google, Apple, Microsoft and Amazon. Try to learn native mobile development (e.g. Java and Android development or Objective C and iOS development). Create a mobile app (e.g. some game) and deploy it in some major marketplace. Thus you will pass through the entire design / develop /publish cycle and this will give you real-world mobile development experience.
	Take up working on a more serious project, like a Web market or a program for managing warehouse or accounting software. This will give you the opportunity to encounter the practical problems of practical software development. You’ll gain the more valuable practical experience and you’ll see for yourself that coding advanced software is much more difficult than coding simple programs.
	Get a job at a software company! This is very important. If you have really solved all problems from this book, you’ll easily get a job offer. By working on practical software projects you’ll learn a great deal of new software technologies, unlike your colleagues, and you’ll come to realize that, even though you know a lot about programming, you are only at the very beginning of your career as a software engineer. You’ll only get to tackle the challenges of team work in practice, and acquire the tools for dealing with them by working on actual software projects at an actual work environment. You’ll have to work at least for a few years until you establish yourself as a software development professional. Then, perhaps, you’ll remember about this book and you’ll realize that you haven’t gone wrong by starting with data structures and algorithms rather than directly with Web technologies, databases and mobile development.
Free Courses at Telerik Software Academy
You can save yourself a lot of trouble and nerves, if you decide to go through all of the above steps of your development as a software engineer at Telerik Software Academy. You’ll learn under the guidance of Svetlin Nakov and instructors with practical experience in the software industry. The Academy is the easiest and absolutely free-of-charge way to lay the foundations of your development career, but it is not the only way. Everything depends on you!
Good Luck to Everyone!
On behalf of the entire panel of authors, we wish you endless success in your career and personal life!

Svetlin Nakov,
Manager of the "Technical Training" Department, Telerik Corporation,
Telerik Software Academy – http://academy.telerik.com
August 24th, 2013 

Fundamentals of Computer Programming with C#
(The Bulgarian C# Programming Book)
by Svetlin Nakov and Co.

http://www.introprogramming.info

Book Back Cover