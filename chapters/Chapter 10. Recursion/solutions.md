# Chapter 10 Solutions and Guidelines

1. Create a recursive method Loops(int k), perform a for-loop from 1 to n and make a recursive call Loops(k-1) in the loop. The bottom of the recursion is when k < 0. Initially invoke Loops(n-1).
1. The recursive solution is to modify the algorithm for generating N nested loops. In fact you need k nested loops from 1 to n.
	- The iterative solution is as follows: start from the first variation in the lexicographical order: {1, 1, …, 1} k times. To obtain the next variation, increase the last number. If it becomes greater than n, change it to 1 and increase the next number on the left. Do the same on the left until the first number goes greater than n.
1. Modify the algorithms from the previous problem and always keep each number equal or greater than the number on the left of it. The easiest way to achieve this is to generate k nested loops from 1 to n and print only these combinations in which each number is greater or equal than the number on its left. You may optimize this approach to get generate directly an increasing sequence for better performance.
1. Let the strings’ count be n. Use the implementation of k nested loops (recursive or iterative) with additional limitation that each number is greater than the previous one. Thus you will generate all different subsets of k elements in the range [0…n-1]. For each set consider the numbers from it as indices in the array of strings and print for each number the corresponding string. For the example above, the set {0, 2} corresponds to the strings at position 0 and position 2, i.e. (test, fun).
	- The iterative algorithm is similar to the iterative algorithm for generating n nested loops, but is more complicated because it needs to guarantee that each number is greater than the number on its left.
1. You can use the previous task and call it N times in order to generate consequently the empty set (k=0), followed by the all subsets with one element (k=1), all subsets with 2 elements (k=2), all subsets with 3 elements (k=3), etc.
	- The problem has another very smart iterative solution: run a loop from 0 to 2N-1 and convert each of these numbers to binary numeral system. For example, for N=3 you will have the following binary representations of the numbers between 0 to 2N-1:
	- 000, 001, 010, 011, 100, 101, 110, 111
	- Now for each binary representation take those words from the subset for which have bit 1 on the corresponding position in the binary representation. For instance, for the binary representation "101" take the first and the last string (at these positions there is 1) and omit the second string (at this position there is 0). Smart, isn’t it?
1. In case you have any difficulties search in Internet for "merge sort". You are going to find hundreds of implementations, including in C#. The challenge is to avoid allocating a new array for the result at each recursive call, because this is inefficient, and to use only three arrays in the whole program: two arrays to be merged merge and a third for the result from the merging. You will have to implement merging of two ranges of an array into a range of another array.
1. Recursive algorithm: suppose that the method Perm(k) permutes in all possible ways the elements of the array p[] at positions from 0 to k-1 (inclusive). Firstly, initialize the array p with the numbers from 1 to N. Implement recursively Perm(k) in the following way:
1. If k == 0, print the current permutation and exit the recursion (bottom of the recursion).
1. Call Perm(k-1).
1. For each position i from 0 to k-1 do the following:
1. Swap p[i] with p[k].
1. Recursively call Perm(k-1).
1. Swap back p[i] with p[k].
	- In the beginning call Perm(n-1) to start the recursive generation.
	- Iterative algorithm: read in Wikipedia how to generate from given permutation the next permutation in the lexicographic order iteratively: en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order.
1. The problem is not very different from the task with finding all subsets among a given list of strings. Shall it work fast enough with 500 numbers? Pay attention that we have to print all subsets with sum N which can be really big amount if N is very big and proper numbers exist in the array. For this reason the task has no efficient solution.
1. If we approach the problem by the method of generating of all possibilities, the solution will not work for more than 20-30 numbers. That’s why we may approach it in a very different way in case the elements of the array are only positive, or are limited in a certain range (for example [-50…50]). Then we could use the following optimized algorithm  based on dynamic programming:
	- Assume we are given an array of numbers p[]. Let’s denote by possible(k, sum) whether we could obtain sum by using only the numbers first k numbers (p[0], p[1], …, p[k]). Then, the following recurrent dependencies are valid:
1. possible(0, sum) = true if p[0] == sum
1. possible(k, sum) = true if possible[k-1, sum] == true or possible[k-1, sum-p[k]] == true
	- The formula above shows that we can obtain sum from the elements of the array at positions 0 to k if one of the following two statements remains:
1. The element p[k] does not participate in the sum and the sum is obtained from the rest of the elements (from 0 to k-1);
1. The element p[k] participates in sum and the remainder sum-p[k] is obtained from the rest of the elements (from 0 to k-1).
	- The implementation is not complex. Just calculate the recursive formulas by recursive method. We should be careful and not let already calculated values from the two-dimensional array possible[,] to be calculated twice. For this purpose we should keep for each possible k and sum the value possible[k, sum]. Otherwise the algorithm will not work for more than 20-30 elements.
	- The regeneration of the numbers, which compose the found sum, may be implemented if we go backwards from the sum n, obtained from the first k numbers. At each step we examine how this sum can be obtained from the first k–1 numbers (by taking the kth number or omitting it).
	- Bear in mind that in the general case all possible sums of the numbers from the input array may be an awful lot. For instance, possible sums of 50 int numbers in the range [Int32.MinValue … Int32.MaxValue] are enough so that we could not sum them in whatever data structure. If, however, all numbers in the input array are positive (as in our case), we could keep the sums in the range [1…S] because from the rest we could not obtain sum S by adding one or more numbers from the input array.
	- If the numbers in the input array are not mandatory positive, but are limited in a range, then all possible sums are limited in some range too and we could use the algorithm described above. For example, if the range of numbers is from -50 to 50, then the least sum is -50*S and the greatest is 50*S.
	- If the numbers in the input array are random and not limited in a range, then the problem has no efficient solution.
	- You could read more about this classical optimization problem in computer science called "Subset Sum Problem" in the following article in Wikipedia: http://en.wikipedia.org/wiki/Subset_sum_problem.
1. Follow the algorithms described in the section "Searching for Paths in a Labyrinth". Note that you need to find all possible paths (not just one of them) so don’t expect your program to run fast for large input data.
1. Read the article about BFS in Wikipedia: http://en.wikipedia.org/wiki/
	- Breadth-first_search. There are enough explanations and sample code. In order to implement a queue in C#, just an array or the .NET system class System.Collections.Generics.Queue<T>. For the elements of the queue you could use your own structure Point, containing x and y coordinates, or use two queues (one for each of the coordinates). You may also check the section BFS in the chapter "Trees and Graphs".
1. Follow the algorithms described in the section "Searching for Paths in a Labyrinth". You should run some graph traversal algorithm like Depth-First Search (DFS) or Breath-First Search (BFS). You may read about them in Internet or check the sections about DFS and BFS in the chapter "Trees and Graphs". Your program should visit each cell at most once and should be fast, even on large matrices (like 1,000 x 1,000).
1. The same like the previous exercise: use DFS or BFS. By a recursive traversal or BFS traversal, find the areas of neighbor cells in the matrix one after another and mark each area’s cells as visited. Do not visit again a visited cell. From all the areas found, remember the largest.
1. For each folder (starting from C:\) print the name and the files from the current folder and call a recursion for each subfolder. The problem is solved as example in the sections DFS and BFS in the chapter "Trees and Graphs". Your program may crash with UnauthorizedAccessException in case you do not have access permissions for some folders on the hard disk. This is typical for some Windows installations so you could start the traversal from another directory or catch the exception (see the "Catching Exceptions" section in the "Exception Handling" chapter).
