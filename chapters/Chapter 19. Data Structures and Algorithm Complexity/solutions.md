# Chapter 19 Solutions and Guidelines

	You can use Dictionary<key, List<value>> or create your own class ValuesCollection, which can take care of the values with the same key and use Dictionary<key, ValuesCollection>.
	You can use SortedSet<List<int>> and its operations Add() and First(). SortedSet<T> keeps the elements in it sorted and can accept external IComparer<T>.
The problem has a more efficient solution though – the data structure called "binary heap". You can read about it on Wikipedia: http://en.wikipedia.org/wiki/Binary_heap.
	The task is similar to the one from the section "Sorting Students".
	One of the solutions to this task is to use two instances of the class Dictionary<K,T> for each of the two keys and when you add or remove an element from BiDictionary<K1,K2,T>, you add or remove the element from the two hash-tables correspondingly. When you search by first or second key, you should check the elements in the first or the second hash-table respectively. When you search by two keys, you could search in the two hash-tables separately and intersect the matching subsets.
Another, simpler approach is to hold 3 hash tables: Dictionary<K1,T>, Dictionary<K2,T> and Dictionary<Tuple<K1,K2>,T>. The system generic class Tuple<K1,K2> can be used to combine two keys and use it as a composite key.
	If we keep the products sorted by price in an array (for example in List<Product>, which we firstly fill and then sort), in order to find all the products which cost between 5 and 10 bucks we can use a binary search twice. Firstly we can find the smallest index start, in which lies a product costing at least 5 bucks. After that we can find the biggest index end, in which lies a product costing at most 10 bucks. All the products at positions in the interval [start … end] will cost between 5 and 10 dollars. If you are interested in the algorithm binary search in a sorted array you could inform yourself reading Wikipedia: http://en.wikipedia.org/wiki/Binary_search.
Generally the approach using a sorted array and binary search in it works excellent, but there is a disadvantage: the addition in a sorted array is a very slow operation, because it requires moving a linear number of elements with one position ahead of the inserted new element.
To overcome this we can use the class SortedSet<T>. It supports fast insertion keeping the elements in a sorted order. It has an operation SortedSet<T>.GetViewBetween(lowerBound, upperBound) that returns a subset of the elements in certain range (interval).
You may also use the class OrderedSet<T> from "Wintellect’s Power Collections for .NET" library (http://www.codeplex.com/PowerCollections) which is more powerful and more flexible. It has a method for extracting a sub-range of values: OrderedSet<T>.Range(from, fromInclusive, to, toInclusive).
	We can create two sorted arrays (List<Event>): the first will keep the events sorted in ascending order by starting date and time; the second will keep the same events sorted by ending date and time. By using binary search we can find all the events which can be partly or fully found between the two moments of time [start, end] by doing the following:
	Find the set S of all events starting after the moment start (using binary search).
	We can find all the set E of all events ending before the moment end (using binary search).
	Intersect these two sets: C = S ? E. If the intersection S of the two sets of events have common elements (S in non-empty set), then in the searched interval [start … end] the hall is occupied. Otherwise it is available.
This solution has a disadvantage: adding elements in the sorted arrays will be slow. We should either add all elements initially and then sort the two arrays and never change them afterwards or try to keep the arrays sorted when adding new elements (which will be slow).
Another solution, which is easier to implement and more efficient, is to use two instances of the class OrderedBag<T> from the "Power Collections for .NET" library (the first with event’s start date and time as a key and the second with event’s end date and time as a key). The class has methods to extract the subsets S and E: RangeFrom(from, fromInclusive) and RangeTo(to, toInclusive). We still will need to intersect these sets and check whether their intersection is empty or not.
The most efficient solution is to use a data structure called "interval tree". Read more in Wikipedia: http://en.wikipedia.org/wiki/Interval_tree. You may find an open source C# interval tree implementation in CodePlex: http://intervaltree.codeplex.com.
	Since there is no internal implementation of the data structure "priority queue" in .NET, you can use the data structure OrderedBag<T> from Wintellect’s Power Collections. It had Add(…) and GetFirst() and RemoveFirst() methods. You can read more about priority queues on Wikipedia: http://en.wikipedia.org/wiki/Priority_Queue.
The classic, simplest efficient priority queue implementation the data structure "binary heap": http://en.wikipedia.org/wiki/Binary_heap.
An efficient ready-to-use C# implementation of priority queue is the class IntervalHeap<T> in the C5 Collections: http://www.itu.dk/research/c5/.
	For searching by brand, model and color we can use one hash-table per each, which will search by a given criteria and return a list of cars (Dictionary<string, List<Car>>).
For searching by year of production and price range we can use lists List<Car>, sorted in ascending order (and binary search).
To search by several criteria at once we can extract the cars' subsets by the first criteria, after that the cars' subsets by the second criteria and so on. At the end we can find the intersection of the sets. Intersection of two sets can be found by looking for every element in the smaller set in the bigger set. The easiest way is Car to implement Equals() and GetHashCode() and after that to use the class HashSet<Car> for set intersections.